import {
  Comment,
  Fragment,
  Suspense,
  Teleport,
  Text,
  Transition,
  TransitionGroup,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createSlots,
  createTextVNode,
  createVNode,
  defineComponent,
  defineCustomElement,
  getCurrentInstance,
  guardReactiveProps,
  h,
  inject,
  mergeProps,
  nextTick,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onMounted,
  onUpdated,
  openBlock,
  provide,
  render,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDynamicComponent,
  toHandlers,
  vModelDynamic,
  vModelText,
  vShow,
  watch,
  watchEffect,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-BAEBKS4H.js";
import {
  capitalize,
  getCurrentScope,
  isRef,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onScopeDispose,
  reactive,
  ref,
  shallowReactive,
  shallowReadonly,
  shallowRef,
  toDisplayString,
  toRef,
  toRefs,
  unref
} from "./chunk-QIK6ZMEG.js";
import "./chunk-34KZWS7D.js";

// node_modules/vuestic-ui/dist/es/src/services/color/presets.js
var presets = {
  light: {
    // Accent
    primary: "#154EC1",
    secondary: "#767C88",
    success: "#3D9209",
    info: "#158DE3",
    danger: "#E42222",
    warning: "#FFD43A",
    // Background Colors
    backgroundPrimary: "#f6f6f6",
    backgroundSecondary: "#FFFFFF",
    backgroundElement: "#ECF0F1",
    backgroundBorder: "#DEE5F2",
    // Text Colors
    textPrimary: "#262824",
    textInverted: "#FFFFFF",
    // Misc
    shadow: "rgba(0, 0, 0, 0.12)",
    focus: "#49A8FF",
    transparent: "rgba(0, 0, 0, 0)"
  },
  dark: {
    // Accent
    primary: "#3472F0",
    secondary: "#767C88",
    success: "#66BE33",
    info: "#3EAAF8",
    danger: "#F34030",
    warning: "#FFD952",
    // Background Colors
    backgroundPrimary: "#050A10",
    backgroundSecondary: "#1F262F",
    backgroundElement: "#131A22",
    backgroundBorder: "#3D4C58",
    // Text Colors
    textPrimary: "#F1F1F1",
    textInverted: "#0B121A",
    // Misc
    shadow: "rgba(255, 255, 255, 0.12)",
    focus: "#49A8FF",
    transparent: "rgba(0, 0, 0, 0)"
  }
};

// node_modules/vuestic-ui/dist/es/src/services/breakpoint/index.js
var vaBreakpointSymbol = Symbol("vaBreakpoint");
var defaultThresholds = {
  xs: 0,
  sm: 640,
  md: 1024,
  lg: 1440,
  xl: 1920
};
var getBreakpointDefaultConfig = () => ({
  enabled: true,
  bodyClass: true,
  thresholds: defaultThresholds
});

// node_modules/vuestic-ui/dist/es/src/services/global-config/types.js
var defineVuesticConfig = (config) => config;

// node_modules/vuestic-ui/dist/es/src/utils/env.js
var processShim = typeof process !== "undefined" ? process : {};
var envShim = processShim.env || {};
var nodeEnv = envShim.NODE_ENV || "";
var isDev = typeof __DEV__ !== "undefined" ? __DEV__ : !["prod", "production"].includes(nodeEnv);

// node_modules/vuestic-ui/dist/es/src/utils/console.js
var warn = (...attrs) => {
  if (isDev) {
    console.warn(...attrs);
  }
  return false;
};
var throwError = (message) => {
  throw new Error(`[Vuestic] ${message}`);
};

// node_modules/vuestic-ui/dist/es/src/services/current-app.js
var currentApp = null;
var prevRegisteredApp = null;
var setCurrentApp = (newApp) => {
  if ((prevRegisteredApp == null ? void 0 : prevRegisteredApp._instance) === null) {
    prevRegisteredApp = null;
  }
  if (newApp === null && prevRegisteredApp === null) {
    return;
  }
  prevRegisteredApp = currentApp;
  currentApp = newApp;
};
var getCurrentApp = () => currentApp;
var inject2 = (key, value = void 0) => {
  var _a2;
  const injectedFromApp = (_a2 = getCurrentApp()) == null ? void 0 : _a2._context.provides[key];
  const vm = getCurrentInstance();
  if (vm) {
    return inject(key, value);
  }
  return injectedFromApp ?? throwError("You're using Vuestic composable outside Vue app. Since you registered Vuestic in multiple apps, composables can not be used outside setup function anymore.");
};

// node_modules/vuestic-ui/dist/es/__commonjsHelpers__.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}

// node_modules/vuestic-ui/dist/es/vendor.js
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$4(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$4;
var eq$3 = eq_1;
function assocIndexOf$4(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$3(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index = assocIndexOf$3(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data = this.__data__, index = assocIndexOf$2(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear;
var listCacheDelete = _listCacheDelete;
var listCacheGet = _listCacheGet;
var listCacheHas = _listCacheHas;
var listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$9 = freeGlobal || freeSelf || Function("return this")();
var _root = root$9;
var root$8 = _root;
var Symbol$6 = root$8.Symbol;
var _Symbol = Symbol$6;
var Symbol$5 = _Symbol;
var objectProto$d = Object.prototype;
var hasOwnProperty$a = objectProto$d.hasOwnProperty;
var nativeObjectToString$1 = objectProto$d.toString;
var symToStringTag$1 = Symbol$5 ? Symbol$5.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$a.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$c = Object.prototype;
var nativeObjectToString = objectProto$c.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$4 = _Symbol;
var getRawTag = _getRawTag;
var objectToString = _objectToString;
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$4 ? Symbol$4.toStringTag : void 0;
function baseGetTag$9(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$9;
function isObject$c(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$c;
var isObject$d = getDefaultExportFromCjs(isObject_1);
var baseGetTag$8 = _baseGetTag;
var isObject$b = isObject_1;
var asyncTag = "[object AsyncFunction]";
var funcTag$2 = "[object Function]";
var genTag$1 = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction$3(value) {
  if (!isObject$b(value)) {
    return false;
  }
  var tag = baseGetTag$8(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$3;
var isFunction$4 = getDefaultExportFromCjs(isFunction_1);
var root$7 = _root;
var coreJsData$1 = root$7["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$2 = isFunction_1;
var isMasked = _isMasked;
var isObject$a = isObject_1;
var toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype;
var objectProto$b = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$9).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(value) {
  if (!isObject$a(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object, key) {
  return object == null ? void 0 : object[key];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative;
var getValue = _getValue;
function getNative$7(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$7;
var getNative$6 = _getNative;
var root$6 = _root;
var Map$3 = getNative$6(root$6, "Map");
var _Map = Map$3;
var getNative$5 = _getNative;
var nativeCreate$4 = getNative$5(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var objectProto$a = Object.prototype;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? void 0 : result;
  }
  return hasOwnProperty$8.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$9 = Object.prototype;
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$7.call(data, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear;
var hashDelete = _hashDelete;
var hashGet = _hashGet;
var hashHas = _hashHas;
var hashSet = _hashSet;
function Hash$1(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
var Hash = _Hash;
var ListCache$2 = _ListCache;
var Map$2 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache$2)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data = getMapData(this, key), size3 = data.size;
  data.set(key, value);
  this.size += data.size == size3 ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear;
var mapCacheDelete = _mapCacheDelete;
var mapCacheGet = _mapCacheGet;
var mapCacheHas = _mapCacheHas;
var mapCacheSet = _mapCacheSet;
function MapCache$2(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache$2.prototype.clear = mapCacheClear;
MapCache$2.prototype["delete"] = mapCacheDelete;
MapCache$2.prototype.get = mapCacheGet;
MapCache$2.prototype.has = mapCacheHas;
MapCache$2.prototype.set = mapCacheSet;
var _MapCache = MapCache$2;
var ListCache$1 = _ListCache;
var Map$1 = _Map;
var MapCache$1 = _MapCache;
var LARGE_ARRAY_SIZE = 200;
function stackSet$1(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$1(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache;
var stackClear = _stackClear;
var stackDelete = _stackDelete;
var stackGet = _stackGet;
var stackHas = _stackHas;
var stackSet = _stackSet;
function Stack$2(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack$2.prototype.clear = stackClear;
Stack$2.prototype["delete"] = stackDelete;
Stack$2.prototype.get = stackGet;
Stack$2.prototype.has = stackHas;
Stack$2.prototype.set = stackSet;
var _Stack = Stack$2;
function arrayEach$1(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}
var _arrayEach = arrayEach$1;
var getNative$4 = _getNative;
var defineProperty$2 = function() {
  try {
    var func = getNative$4(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
var _defineProperty = defineProperty$2;
var defineProperty$1 = _defineProperty;
function baseAssignValue$3(object, key, value) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var _baseAssignValue = baseAssignValue$3;
var baseAssignValue$2 = _baseAssignValue;
var eq$2 = eq_1;
var objectProto$8 = Object.prototype;
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
function assignValue$3(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$6.call(object, key) && eq$2(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue$2(object, key, value);
  }
}
var _assignValue = assignValue$3;
var assignValue$2 = _assignValue;
var baseAssignValue$1 = _baseAssignValue;
function copyObject$6(source, props2, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length = props2.length;
  while (++index < length) {
    var key = props2[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue$1(object, key, newValue);
    } else {
      assignValue$2(object, key, newValue);
    }
  }
  return object;
}
var _copyObject = copyObject$6;
function baseTimes$1(n2, iteratee) {
  var index = -1, result = Array(n2);
  while (++index < n2) {
    result[index] = iteratee(index);
  }
  return result;
}
var _baseTimes = baseTimes$1;
function isObjectLike$b(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$b;
var baseGetTag$7 = _baseGetTag;
var isObjectLike$a = isObjectLike_1;
var argsTag$2 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$a(value) && baseGetTag$7(value) == argsTag$2;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments;
var isObjectLike$9 = isObjectLike_1;
var objectProto$7 = Object.prototype;
var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable;
var isArguments$4 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$9(value) && hasOwnProperty$5.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments_1 = isArguments$4;
var isArray$a = Array.isArray;
var isArray_1 = isArray$a;
var isBuffer$3 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
isBuffer$3.exports;
(function(module, exports) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer2;
})(isBuffer$3, isBuffer$3.exports);
var isBufferExports = isBuffer$3.exports;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$4(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex = isIndex$4;
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$3(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$3;
var baseGetTag$6 = _baseGetTag;
var isLength$2 = isLength_1;
var isObjectLike$8 = isObjectLike_1;
var argsTag$1 = "[object Arguments]";
var arrayTag$1 = "[object Array]";
var boolTag$2 = "[object Boolean]";
var dateTag$3 = "[object Date]";
var errorTag$1 = "[object Error]";
var funcTag$1 = "[object Function]";
var mapTag$4 = "[object Map]";
var numberTag$3 = "[object Number]";
var objectTag$3 = "[object Object]";
var regexpTag$2 = "[object RegExp]";
var setTag$4 = "[object Set]";
var stringTag$3 = "[object String]";
var weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]";
var dataViewTag$3 = "[object DataView]";
var float32Tag$2 = "[object Float32Array]";
var float64Tag$2 = "[object Float64Array]";
var int8Tag$2 = "[object Int8Array]";
var int16Tag$2 = "[object Int16Array]";
var int32Tag$2 = "[object Int32Array]";
var uint8Tag$2 = "[object Uint8Array]";
var uint8ClampedTag$2 = "[object Uint8ClampedArray]";
var uint16Tag$2 = "[object Uint16Array]";
var uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$8(value) && isLength$2(value.length) && !!typedArrayTags[baseGetTag$6(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$4(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$4;
var _nodeUtil = { exports: {} };
_nodeUtil.exports;
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e2) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var _nodeUtilExports = _nodeUtil.exports;
var baseIsTypedArray = _baseIsTypedArray;
var baseUnary$3 = _baseUnary;
var nodeUtil$3 = _nodeUtilExports;
var nodeIsTypedArray = nodeUtil$3 && nodeUtil$3.isTypedArray;
var isTypedArray$2 = nodeIsTypedArray ? baseUnary$3(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$2;
var baseTimes = _baseTimes;
var isArguments$3 = isArguments_1;
var isArray$9 = isArray_1;
var isBuffer$2 = isBufferExports;
var isIndex$3 = _isIndex;
var isTypedArray$1 = isTypedArray_1;
var objectProto$6 = Object.prototype;
var hasOwnProperty$4 = objectProto$6.hasOwnProperty;
function arrayLikeKeys$2(value, inherited) {
  var isArr = isArray$9(value), isArg = !isArr && isArguments$3(value), isBuff = !isArr && !isArg && isBuffer$2(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex$3(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$2;
var objectProto$5 = Object.prototype;
function isPrototype$3(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$5;
  return value === proto;
}
var _isPrototype = isPrototype$3;
function overArg$2(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$2;
var overArg$1 = _overArg;
var nativeKeys$1 = overArg$1(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype$2 = _isPrototype;
var nativeKeys = _nativeKeys;
var objectProto$4 = Object.prototype;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
function baseKeys$1(object) {
  if (!isPrototype$2(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$3.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
var isFunction$1 = isFunction_1;
var isLength$1 = isLength_1;
function isArrayLike$4(value) {
  return value != null && isLength$1(value.length) && !isFunction$1(value);
}
var isArrayLike_1 = isArrayLike$4;
var arrayLikeKeys$1 = _arrayLikeKeys;
var baseKeys = _baseKeys;
var isArrayLike$3 = isArrayLike_1;
function keys$3(object) {
  return isArrayLike$3(object) ? arrayLikeKeys$1(object) : baseKeys(object);
}
var keys_1 = keys$3;
var copyObject$5 = _copyObject;
var keys$2 = keys_1;
function baseAssign$1(object, source) {
  return object && copyObject$5(source, keys$2(source), object);
}
var _baseAssign = baseAssign$1;
function nativeKeysIn$1(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn$1;
var isObject$9 = isObject_1;
var isPrototype$1 = _isPrototype;
var nativeKeysIn = _nativeKeysIn;
var objectProto$3 = Object.prototype;
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
function baseKeysIn$1(object) {
  if (!isObject$9(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype$1(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$2.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn$1;
var arrayLikeKeys = _arrayLikeKeys;
var baseKeysIn = _baseKeysIn;
var isArrayLike$2 = isArrayLike_1;
function keysIn$5(object) {
  return isArrayLike$2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var keysIn_1 = keysIn$5;
var copyObject$4 = _copyObject;
var keysIn$4 = keysIn_1;
function baseAssignIn$1(object, source) {
  return object && copyObject$4(source, keysIn$4(source), object);
}
var _baseAssignIn = baseAssignIn$1;
var _cloneBuffer = { exports: {} };
_cloneBuffer.exports;
(function(module, exports) {
  var root2 = _root;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  module.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBuffer.exports);
var _cloneBufferExports = _cloneBuffer.exports;
function copyArray$2(source, array) {
  var index = -1, length = source.length;
  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}
var _copyArray = copyArray$2;
function arrayFilter$1(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$1;
function stubArray$2() {
  return [];
}
var stubArray_1 = stubArray$2;
var arrayFilter = _arrayFilter;
var stubArray$1 = stubArray_1;
var objectProto$2 = Object.prototype;
var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var _getSymbols = getSymbols$3;
var copyObject$3 = _copyObject;
var getSymbols$2 = _getSymbols;
function copySymbols$1(source, object) {
  return copyObject$3(source, getSymbols$2(source), object);
}
var _copySymbols = copySymbols$1;
function arrayPush$3(array, values) {
  var index = -1, length = values.length, offset2 = array.length;
  while (++index < length) {
    array[offset2 + index] = values[index];
  }
  return array;
}
var _arrayPush = arrayPush$3;
var overArg = _overArg;
var getPrototype$3 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$3;
var arrayPush$2 = _arrayPush;
var getPrototype$2 = _getPrototype;
var getSymbols$1 = _getSymbols;
var stubArray = stubArray_1;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush$2(result, getSymbols$1(object));
    object = getPrototype$2(object);
  }
  return result;
};
var _getSymbolsIn = getSymbolsIn$2;
var copyObject$2 = _copyObject;
var getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(source, object) {
  return copyObject$2(source, getSymbolsIn$1(source), object);
}
var _copySymbolsIn = copySymbolsIn$1;
var arrayPush$1 = _arrayPush;
var isArray$8 = isArray_1;
function baseGetAllKeys$2(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$8(object) ? result : arrayPush$1(result, symbolsFunc(object));
}
var _baseGetAllKeys = baseGetAllKeys$2;
var baseGetAllKeys$1 = _baseGetAllKeys;
var getSymbols = _getSymbols;
var keys$1 = keys_1;
function getAllKeys$1(object) {
  return baseGetAllKeys$1(object, keys$1, getSymbols);
}
var _getAllKeys = getAllKeys$1;
var baseGetAllKeys = _baseGetAllKeys;
var getSymbolsIn = _getSymbolsIn;
var keysIn$3 = keysIn_1;
function getAllKeysIn$2(object) {
  return baseGetAllKeys(object, keysIn$3, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$2;
var getNative$3 = _getNative;
var root$5 = _root;
var DataView$1 = getNative$3(root$5, "DataView");
var _DataView = DataView$1;
var getNative$2 = _getNative;
var root$4 = _root;
var Promise$2 = getNative$2(root$4, "Promise");
var _Promise = Promise$2;
var getNative$1 = _getNative;
var root$3 = _root;
var Set$1 = getNative$1(root$3, "Set");
var _Set = Set$1;
var getNative = _getNative;
var root$2 = _root;
var WeakMap$1 = getNative(root$2, "WeakMap");
var _WeakMap = WeakMap$1;
var DataView = _DataView;
var Map2 = _Map;
var Promise$1 = _Promise;
var Set2 = _Set;
var WeakMap = _WeakMap;
var baseGetTag$5 = _baseGetTag;
var toSource = _toSource;
var mapTag$3 = "[object Map]";
var objectTag$2 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag$3 = "[object Set]";
var weakMapTag$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = toSource(DataView);
var mapCtorString = toSource(Map2);
var promiseCtorString = toSource(Promise$1);
var setCtorString = toSource(Set2);
var weakMapCtorString = toSource(WeakMap);
var getTag$3 = baseGetTag$5;
if (DataView && getTag$3(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map2 && getTag$3(new Map2()) != mapTag$3 || Promise$1 && getTag$3(Promise$1.resolve()) != promiseTag || Set2 && getTag$3(new Set2()) != setTag$3 || WeakMap && getTag$3(new WeakMap()) != weakMapTag$1) {
  getTag$3 = function(value) {
    var result = baseGetTag$5(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;
        case mapCtorString:
          return mapTag$3;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$3;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var _getTag = getTag$3;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function initCloneArray$1(array) {
  var length = array.length, result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty$1.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var _initCloneArray = initCloneArray$1;
var root$1 = _root;
var Uint8Array$1 = root$1.Uint8Array;
var _Uint8Array = Uint8Array$1;
var Uint8Array = _Uint8Array;
function cloneArrayBuffer$3(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer$3;
var cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneDataView$1(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$2(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView$1;
var reFlags = /\w*$/;
function cloneRegExp$1(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var _cloneRegExp = cloneRegExp$1;
var Symbol$3 = _Symbol;
var symbolProto$1 = Symbol$3 ? Symbol$3.prototype : void 0;
var symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol$1(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol$1;
var cloneArrayBuffer$1 = _cloneArrayBuffer;
function cloneTypedArray$2(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$1(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$2;
var cloneArrayBuffer = _cloneArrayBuffer;
var cloneDataView = _cloneDataView;
var cloneRegExp = _cloneRegExp;
var cloneSymbol = _cloneSymbol;
var cloneTypedArray$1 = _cloneTypedArray;
var boolTag$1 = "[object Boolean]";
var dateTag$2 = "[object Date]";
var mapTag$2 = "[object Map]";
var numberTag$2 = "[object Number]";
var regexpTag$1 = "[object RegExp]";
var setTag$2 = "[object Set]";
var stringTag$2 = "[object String]";
var symbolTag$2 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]";
var dataViewTag$1 = "[object DataView]";
var float32Tag$1 = "[object Float32Array]";
var float64Tag$1 = "[object Float64Array]";
var int8Tag$1 = "[object Int8Array]";
var int16Tag$1 = "[object Int16Array]";
var int32Tag$1 = "[object Int32Array]";
var uint8Tag$1 = "[object Uint8Array]";
var uint8ClampedTag$1 = "[object Uint8ClampedArray]";
var uint16Tag$1 = "[object Uint16Array]";
var uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag$1(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object);
    case boolTag$1:
    case dateTag$2:
      return new Ctor(+object);
    case dataViewTag$1:
      return cloneDataView(object, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray$1(object, isDeep);
    case mapTag$2:
      return new Ctor();
    case numberTag$2:
    case stringTag$2:
      return new Ctor(object);
    case regexpTag$1:
      return cloneRegExp(object);
    case setTag$2:
      return new Ctor();
    case symbolTag$2:
      return cloneSymbol(object);
  }
}
var _initCloneByTag = initCloneByTag$1;
var isObject$8 = isObject_1;
var objectCreate = Object.create;
var baseCreate$1 = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject$8(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate$1;
var baseCreate = _baseCreate;
var getPrototype$1 = _getPrototype;
var isPrototype = _isPrototype;
function initCloneObject$2(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype$1(object)) : {};
}
var _initCloneObject = initCloneObject$2;
var getTag$2 = _getTag;
var isObjectLike$7 = isObjectLike_1;
var mapTag$1 = "[object Map]";
function baseIsMap$1(value) {
  return isObjectLike$7(value) && getTag$2(value) == mapTag$1;
}
var _baseIsMap = baseIsMap$1;
var baseIsMap = _baseIsMap;
var baseUnary$2 = _baseUnary;
var nodeUtil$2 = _nodeUtilExports;
var nodeIsMap = nodeUtil$2 && nodeUtil$2.isMap;
var isMap$1 = nodeIsMap ? baseUnary$2(nodeIsMap) : baseIsMap;
var isMap_1 = isMap$1;
var getTag$1 = _getTag;
var isObjectLike$6 = isObjectLike_1;
var setTag$1 = "[object Set]";
function baseIsSet$1(value) {
  return isObjectLike$6(value) && getTag$1(value) == setTag$1;
}
var _baseIsSet = baseIsSet$1;
var baseIsSet = _baseIsSet;
var baseUnary$1 = _baseUnary;
var nodeUtil$1 = _nodeUtilExports;
var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
var isSet$1 = nodeIsSet ? baseUnary$1(nodeIsSet) : baseIsSet;
var isSet_1 = isSet$1;
var Stack$1 = _Stack;
var arrayEach = _arrayEach;
var assignValue$1 = _assignValue;
var baseAssign = _baseAssign;
var baseAssignIn = _baseAssignIn;
var cloneBuffer$1 = _cloneBufferExports;
var copyArray$1 = _copyArray;
var copySymbols = _copySymbols;
var copySymbolsIn = _copySymbolsIn;
var getAllKeys = _getAllKeys;
var getAllKeysIn$1 = _getAllKeysIn;
var getTag = _getTag;
var initCloneArray = _initCloneArray;
var initCloneByTag = _initCloneByTag;
var initCloneObject$1 = _initCloneObject;
var isArray$7 = isArray_1;
var isBuffer$1 = isBufferExports;
var isMap = isMap_1;
var isObject$7 = isObject_1;
var isSet = isSet_1;
var keys = keys_1;
var keysIn$2 = keysIn_1;
var CLONE_DEEP_FLAG$2 = 1;
var CLONE_FLAT_FLAG$1 = 2;
var CLONE_SYMBOLS_FLAG$2 = 4;
var argsTag = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag$1 = "[object Date]";
var errorTag = "[object Error]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var mapTag = "[object Map]";
var numberTag$1 = "[object Number]";
var objectTag$1 = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag$1 = "[object String]";
var symbolTag$1 = "[object Symbol]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone$2(value, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$2, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$7(value)) {
    return value;
  }
  var isArr = isArray$7(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray$1(value, result);
    }
  } else {
    var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer$1(value)) {
      return cloneBuffer$1(value, isDeep);
    }
    if (tag == objectTag$1 || tag == argsTag || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject$1(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack$1());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone$2(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone$2(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn$1 : getAllKeys : isFlat ? keysIn$2 : keys;
  var props2 = isArr ? void 0 : keysFunc(value);
  arrayEach(props2 || value, function(subValue, key2) {
    if (props2) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue$1(result, key2, baseClone$2(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var _baseClone = baseClone$2;
var baseClone$1 = _baseClone;
var CLONE_DEEP_FLAG$1 = 1;
var CLONE_SYMBOLS_FLAG$1 = 4;
function cloneDeep(value) {
  return baseClone$1(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
}
var cloneDeep_1 = cloneDeep;
var cloneDeep$1 = getDefaultExportFromCjs(cloneDeep_1);
function arrayReduce$1(array, iteratee, accumulator, initAccum) {
  var index = -1, length = array == null ? 0 : array.length;
  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}
var _arrayReduce = arrayReduce$1;
function basePropertyOf$1(object) {
  return function(key) {
    return object == null ? void 0 : object[key];
  };
}
var _basePropertyOf = basePropertyOf$1;
var basePropertyOf = _basePropertyOf;
var deburredLetters = {
  // Latin-1 Supplement block.
  "À": "A",
  "Á": "A",
  "Â": "A",
  "Ã": "A",
  "Ä": "A",
  "Å": "A",
  "à": "a",
  "á": "a",
  "â": "a",
  "ã": "a",
  "ä": "a",
  "å": "a",
  "Ç": "C",
  "ç": "c",
  "Ð": "D",
  "ð": "d",
  "È": "E",
  "É": "E",
  "Ê": "E",
  "Ë": "E",
  "è": "e",
  "é": "e",
  "ê": "e",
  "ë": "e",
  "Ì": "I",
  "Í": "I",
  "Î": "I",
  "Ï": "I",
  "ì": "i",
  "í": "i",
  "î": "i",
  "ï": "i",
  "Ñ": "N",
  "ñ": "n",
  "Ò": "O",
  "Ó": "O",
  "Ô": "O",
  "Õ": "O",
  "Ö": "O",
  "Ø": "O",
  "ò": "o",
  "ó": "o",
  "ô": "o",
  "õ": "o",
  "ö": "o",
  "ø": "o",
  "Ù": "U",
  "Ú": "U",
  "Û": "U",
  "Ü": "U",
  "ù": "u",
  "ú": "u",
  "û": "u",
  "ü": "u",
  "Ý": "Y",
  "ý": "y",
  "ÿ": "y",
  "Æ": "Ae",
  "æ": "ae",
  "Þ": "Th",
  "þ": "th",
  "ß": "ss",
  // Latin Extended-A block.
  "Ā": "A",
  "Ă": "A",
  "Ą": "A",
  "ā": "a",
  "ă": "a",
  "ą": "a",
  "Ć": "C",
  "Ĉ": "C",
  "Ċ": "C",
  "Č": "C",
  "ć": "c",
  "ĉ": "c",
  "ċ": "c",
  "č": "c",
  "Ď": "D",
  "Đ": "D",
  "ď": "d",
  "đ": "d",
  "Ē": "E",
  "Ĕ": "E",
  "Ė": "E",
  "Ę": "E",
  "Ě": "E",
  "ē": "e",
  "ĕ": "e",
  "ė": "e",
  "ę": "e",
  "ě": "e",
  "Ĝ": "G",
  "Ğ": "G",
  "Ġ": "G",
  "Ģ": "G",
  "ĝ": "g",
  "ğ": "g",
  "ġ": "g",
  "ģ": "g",
  "Ĥ": "H",
  "Ħ": "H",
  "ĥ": "h",
  "ħ": "h",
  "Ĩ": "I",
  "Ī": "I",
  "Ĭ": "I",
  "Į": "I",
  "İ": "I",
  "ĩ": "i",
  "ī": "i",
  "ĭ": "i",
  "į": "i",
  "ı": "i",
  "Ĵ": "J",
  "ĵ": "j",
  "Ķ": "K",
  "ķ": "k",
  "ĸ": "k",
  "Ĺ": "L",
  "Ļ": "L",
  "Ľ": "L",
  "Ŀ": "L",
  "Ł": "L",
  "ĺ": "l",
  "ļ": "l",
  "ľ": "l",
  "ŀ": "l",
  "ł": "l",
  "Ń": "N",
  "Ņ": "N",
  "Ň": "N",
  "Ŋ": "N",
  "ń": "n",
  "ņ": "n",
  "ň": "n",
  "ŋ": "n",
  "Ō": "O",
  "Ŏ": "O",
  "Ő": "O",
  "ō": "o",
  "ŏ": "o",
  "ő": "o",
  "Ŕ": "R",
  "Ŗ": "R",
  "Ř": "R",
  "ŕ": "r",
  "ŗ": "r",
  "ř": "r",
  "Ś": "S",
  "Ŝ": "S",
  "Ş": "S",
  "Š": "S",
  "ś": "s",
  "ŝ": "s",
  "ş": "s",
  "š": "s",
  "Ţ": "T",
  "Ť": "T",
  "Ŧ": "T",
  "ţ": "t",
  "ť": "t",
  "ŧ": "t",
  "Ũ": "U",
  "Ū": "U",
  "Ŭ": "U",
  "Ů": "U",
  "Ű": "U",
  "Ų": "U",
  "ũ": "u",
  "ū": "u",
  "ŭ": "u",
  "ů": "u",
  "ű": "u",
  "ų": "u",
  "Ŵ": "W",
  "ŵ": "w",
  "Ŷ": "Y",
  "ŷ": "y",
  "Ÿ": "Y",
  "Ź": "Z",
  "Ż": "Z",
  "Ž": "Z",
  "ź": "z",
  "ż": "z",
  "ž": "z",
  "Ĳ": "IJ",
  "ĳ": "ij",
  "Œ": "Oe",
  "œ": "oe",
  "ŉ": "'n",
  "ſ": "s"
};
var deburrLetter$1 = basePropertyOf(deburredLetters);
var _deburrLetter = deburrLetter$1;
function arrayMap$2(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var _arrayMap = arrayMap$2;
var baseGetTag$4 = _baseGetTag;
var isObjectLike$5 = isObjectLike_1;
var symbolTag = "[object Symbol]";
function isSymbol$4(value) {
  return typeof value == "symbol" || isObjectLike$5(value) && baseGetTag$4(value) == symbolTag;
}
var isSymbol_1 = isSymbol$4;
var Symbol$2 = _Symbol;
var arrayMap$1 = _arrayMap;
var isArray$6 = isArray_1;
var isSymbol$3 = isSymbol_1;
var INFINITY$1 = 1 / 0;
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString$1(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$6(value)) {
    return arrayMap$1(value, baseToString$1) + "";
  }
  if (isSymbol$3(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
var _baseToString = baseToString$1;
var baseToString = _baseToString;
function toString$6(value) {
  return value == null ? "" : baseToString(value);
}
var toString_1 = toString$6;
var deburrLetter = _deburrLetter;
var toString$5 = toString_1;
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange$3 = "\\u0300-\\u036f";
var reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$3 = "\\u20d0-\\u20ff";
var rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3;
var rsCombo$2 = "[" + rsComboRange$3 + "]";
var reComboMark = RegExp(rsCombo$2, "g");
function deburr$1(string) {
  string = toString$5(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
}
var deburr_1 = deburr$1;
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords$1(string) {
  return string.match(reAsciiWord) || [];
}
var _asciiWords = asciiWords$1;
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord$1(string) {
  return reHasUnicodeWord.test(string);
}
var _hasUnicodeWord = hasUnicodeWord$1;
var rsAstralRange$2 = "\\ud800-\\udfff";
var rsComboMarksRange$2 = "\\u0300-\\u036f";
var reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$2 = "\\u20d0-\\u20ff";
var rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2;
var rsDingbatRange = "\\u2700-\\u27bf";
var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
var rsPunctuationRange = "\\u2000-\\u206f";
var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
var rsVarRange$2 = "\\ufe0e\\ufe0f";
var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos$1 = "['’]";
var rsBreak = "[" + rsBreakRange + "]";
var rsCombo$1 = "[" + rsComboRange$2 + "]";
var rsDigits = "\\d+";
var rsDingbat = "[" + rsDingbatRange + "]";
var rsLower = "[" + rsLowerRange + "]";
var rsMisc = "[^" + rsAstralRange$2 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
var rsFitz$1 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier$1 = "(?:" + rsCombo$1 + "|" + rsFitz$1 + ")";
var rsNonAstral$1 = "[^" + rsAstralRange$2 + "]";
var rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsUpper = "[" + rsUpperRange + "]";
var rsZWJ$2 = "\\u200d";
var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
var rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?";
var rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?";
var reOptMod$1 = rsModifier$1 + "?";
var rsOptVar$1 = "[" + rsVarRange$2 + "]?";
var rsOptJoin$1 = "(?:" + rsZWJ$2 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*";
var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
var rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1;
var rsEmoji = "(?:" + [rsDingbat, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsSeq$1;
var reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords$1(string) {
  return string.match(reUnicodeWord) || [];
}
var _unicodeWords = unicodeWords$1;
var asciiWords = _asciiWords;
var hasUnicodeWord = _hasUnicodeWord;
var toString$4 = toString_1;
var unicodeWords = _unicodeWords;
function words$1(string, pattern, guard) {
  string = toString$4(string);
  pattern = guard ? void 0 : pattern;
  if (pattern === void 0) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}
var words_1 = words$1;
var arrayReduce = _arrayReduce;
var deburr = deburr_1;
var words = words_1;
var rsApos = "['’]";
var reApos = RegExp(rsApos, "g");
function createCompounder$3(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
  };
}
var _createCompounder = createCompounder$3;
var createCompounder$2 = _createCompounder;
var kebabCase = createCompounder$2(function(result, word, index) {
  return result + (index ? "-" : "") + word.toLowerCase();
});
var kebabCase_1 = kebabCase;
var kebabCase$1 = getDefaultExportFromCjs(kebabCase_1);
function baseSlice$2(array, start, end) {
  var index = -1, length = array.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}
var _baseSlice = baseSlice$2;
var baseSlice$1 = _baseSlice;
function castSlice$1(array, start, end) {
  var length = array.length;
  end = end === void 0 ? length : end;
  return !start && end >= length ? array : baseSlice$1(array, start, end);
}
var _castSlice = castSlice$1;
var rsAstralRange$1 = "\\ud800-\\udfff";
var rsComboMarksRange$1 = "\\u0300-\\u036f";
var reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$1 = "\\u20d0-\\u20ff";
var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
var rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsZWJ$1 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + "]");
function hasUnicode$2(string) {
  return reHasUnicode.test(string);
}
var _hasUnicode = hasUnicode$2;
function asciiToArray$1(string) {
  return string.split("");
}
var _asciiToArray = asciiToArray$1;
var rsAstralRange = "\\ud800-\\udfff";
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsVarRange = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange + "]";
var rsCombo = "[" + rsComboRange + "]";
var rsFitz = "\\ud83c[\\udffb-\\udfff]";
var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
var rsNonAstral = "[^" + rsAstralRange + "]";
var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ = "\\u200d";
var reOptMod = rsModifier + "?";
var rsOptVar = "[" + rsVarRange + "]?";
var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray$1(string) {
  return string.match(reUnicode) || [];
}
var _unicodeToArray = unicodeToArray$1;
var asciiToArray = _asciiToArray;
var hasUnicode$1 = _hasUnicode;
var unicodeToArray = _unicodeToArray;
function stringToArray$1(string) {
  return hasUnicode$1(string) ? unicodeToArray(string) : asciiToArray(string);
}
var _stringToArray = stringToArray$1;
var castSlice = _castSlice;
var hasUnicode = _hasUnicode;
var stringToArray = _stringToArray;
var toString$3 = toString_1;
function createCaseFirst$1(methodName) {
  return function(string) {
    string = toString$3(string);
    var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
    return chr[methodName]() + trailing;
  };
}
var _createCaseFirst = createCaseFirst$1;
var createCaseFirst = _createCaseFirst;
var upperFirst$2 = createCaseFirst("toUpperCase");
var upperFirst_1 = upperFirst$2;
var toString$2 = toString_1;
var upperFirst$1 = upperFirst_1;
function capitalize$1(string) {
  return upperFirst$1(toString$2(string).toLowerCase());
}
var capitalize_1 = capitalize$1;
var capitalize2 = capitalize_1;
var createCompounder$1 = _createCompounder;
var camelCase = createCompounder$1(function(result, word, index) {
  word = word.toLowerCase();
  return result + (index ? capitalize2(word) : word);
});
var camelCase_1 = camelCase;
var camelCase$1 = getDefaultExportFromCjs(camelCase_1);
function isNil(value) {
  return value == null;
}
var isNil_1 = isNil;
var isNil$1 = getDefaultExportFromCjs(isNil_1);
var root = _root;
var now$1 = function() {
  return root.Date.now();
};
var now_1 = now$1;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {
  }
  return index;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$1(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var _baseTrim = baseTrim$1;
var baseTrim = _baseTrim;
var isObject$6 = isObject_1;
var isSymbol$2 = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$2(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol$2(value)) {
    return NAN;
  }
  if (isObject$6(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$6(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_1 = toNumber$2;
var isObject$5 = isObject_1;
var now = now_1;
var toNumber$1 = toNumber_1;
var FUNC_ERROR_TEXT$2 = "Expected a function";
var nativeMax$1 = Math.max;
var nativeMin = Math.min;
function debounce$1(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  wait = toNumber$1(wait) || 0;
  if (isObject$5(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax$1(toNumber$1(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now());
  }
  function debounced() {
    var time = now(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_1 = debounce$1;
var debounce$2 = getDefaultExportFromCjs(debounce_1);
var isArray$5 = isArray_1;
var isSymbol$1 = isSymbol_1;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey$1(value, object) {
  if (isArray$5(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$1(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var _isKey = isKey$1;
var MapCache = _MapCache;
var FUNC_ERROR_TEXT$1 = "Expected a function";
function memoize$1(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache)();
  return memoized;
}
memoize$1.Cache = MapCache;
var memoize_1 = memoize$1;
var memoize = memoize_1;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$1;
var memoizeCapped = _memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath$1 = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var _stringToPath = stringToPath$1;
var isArray$4 = isArray_1;
var isKey = _isKey;
var stringToPath = _stringToPath;
var toString$1 = toString_1;
function castPath$6(value, object) {
  if (isArray$4(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString$1(value));
}
var _castPath = castPath$6;
var isSymbol = isSymbol_1;
var INFINITY = 1 / 0;
function toKey$4(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var _toKey = toKey$4;
var castPath$5 = _castPath;
var toKey$3 = _toKey;
function baseGet$2(object, path) {
  path = castPath$5(path, object);
  var index = 0, length = path.length;
  while (object != null && index < length) {
    object = object[toKey$3(path[index++])];
  }
  return index && index == length ? object : void 0;
}
var _baseGet = baseGet$2;
var assignValue = _assignValue;
var castPath$4 = _castPath;
var isIndex$2 = _isIndex;
var isObject$4 = isObject_1;
var toKey$2 = _toKey;
function baseSet$1(object, path, value, customizer) {
  if (!isObject$4(object)) {
    return object;
  }
  path = castPath$4(path, object);
  var index = -1, length = path.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index < length) {
    var key = toKey$2(path[index]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$4(objValue) ? objValue : isIndex$2(path[index + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var _baseSet = baseSet$1;
var baseGet$1 = _baseGet;
var baseSet = _baseSet;
var castPath$3 = _castPath;
function basePickBy$1(object, paths, predicate) {
  var index = -1, length = paths.length, result = {};
  while (++index < length) {
    var path = paths[index], value = baseGet$1(object, path);
    if (predicate(value, path)) {
      baseSet(result, castPath$3(path, object), value);
    }
  }
  return result;
}
var _basePickBy = basePickBy$1;
function baseHasIn$1(object, key) {
  return object != null && key in Object(object);
}
var _baseHasIn = baseHasIn$1;
var castPath$2 = _castPath;
var isArguments$2 = isArguments_1;
var isArray$3 = isArray_1;
var isIndex$1 = _isIndex;
var isLength = isLength_1;
var toKey$1 = _toKey;
function hasPath$1(object, path, hasFunc) {
  path = castPath$2(path, object);
  var index = -1, length = path.length, result = false;
  while (++index < length) {
    var key = toKey$1(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex$1(key, length) && (isArray$3(object) || isArguments$2(object));
}
var _hasPath = hasPath$1;
var baseHasIn = _baseHasIn;
var hasPath = _hasPath;
function hasIn$1(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}
var hasIn_1 = hasIn$1;
var basePickBy = _basePickBy;
var hasIn = hasIn_1;
function basePick$1(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}
var _basePick = basePick$1;
var Symbol$1 = _Symbol;
var isArguments$1 = isArguments_1;
var isArray$2 = isArray_1;
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable$1(value) {
  return isArray$2(value) || isArguments$1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var _isFlattenable = isFlattenable$1;
var arrayPush = _arrayPush;
var isFlattenable = _isFlattenable;
function baseFlatten$1(array, depth, predicate, isStrict, result) {
  var index = -1, length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten$1(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var _baseFlatten = baseFlatten$1;
var baseFlatten = _baseFlatten;
function flatten$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}
var flatten_1 = flatten$1;
var flatten$2 = getDefaultExportFromCjs(flatten_1);
function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var _apply = apply$1;
var apply = _apply;
var nativeMax = Math.max;
function overRest$2(func, start, transform) {
  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}
var _overRest = overRest$2;
function constant$1(value) {
  return function() {
    return value;
  };
}
var constant_1 = constant$1;
function identity$2(value) {
  return value;
}
var identity_1 = identity$2;
var constant = constant_1;
var defineProperty = _defineProperty;
var identity$1 = identity_1;
var baseSetToString$1 = !defineProperty ? identity$1 : function(func, string) {
  return defineProperty(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var _baseSetToString = baseSetToString$1;
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut$1(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$1;
var baseSetToString = _baseSetToString;
var shortOut = _shortOut;
var setToString$2 = shortOut(baseSetToString);
var _setToString = setToString$2;
var flatten = flatten_1;
var overRest$1 = _overRest;
var setToString$1 = _setToString;
function flatRest$2(func) {
  return setToString$1(overRest$1(func, void 0, flatten), func + "");
}
var _flatRest = flatRest$2;
var basePick = _basePick;
var flatRest$1 = _flatRest;
var pick = flatRest$1(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});
var pick_1 = pick;
var pick$1 = getDefaultExportFromCjs(pick_1);
var toString = toString_1;
var idCounter = 0;
function uniqueId(prefix2) {
  var id = ++idCounter;
  return toString(prefix2) + id;
}
var uniqueId_1 = uniqueId;
var uniqueId$1 = getDefaultExportFromCjs(uniqueId_1);
var baseGetTag$3 = _baseGetTag;
var isArray$1 = isArray_1;
var isObjectLike$4 = isObjectLike_1;
var stringTag = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray$1(value) && isObjectLike$4(value) && baseGetTag$3(value) == stringTag;
}
var isString_1 = isString;
var isString$1 = getDefaultExportFromCjs(isString_1);
var baseAssignValue = _baseAssignValue;
var eq$1 = eq_1;
function assignMergeValue$2(object, key, value) {
  if (value !== void 0 && !eq$1(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
var _assignMergeValue = assignMergeValue$2;
function createBaseFor$1(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props2 = keysFunc(object), length = props2.length;
    while (length--) {
      var key = props2[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var _createBaseFor = createBaseFor$1;
var createBaseFor = _createBaseFor;
var baseFor$1 = createBaseFor();
var _baseFor = baseFor$1;
var isArrayLike$1 = isArrayLike_1;
var isObjectLike$3 = isObjectLike_1;
function isArrayLikeObject$1(value) {
  return isObjectLike$3(value) && isArrayLike$1(value);
}
var isArrayLikeObject_1 = isArrayLikeObject$1;
var baseGetTag$2 = _baseGetTag;
var getPrototype = _getPrototype;
var isObjectLike$2 = isObjectLike_1;
var objectTag = "[object Object]";
var funcProto = Function.prototype;
var objectProto = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject$2(value) {
  if (!isObjectLike$2(value) || baseGetTag$2(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var isPlainObject_1 = isPlainObject$2;
function safeGet$2(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var _safeGet = safeGet$2;
var copyObject$1 = _copyObject;
var keysIn$1 = keysIn_1;
function toPlainObject$1(value) {
  return copyObject$1(value, keysIn$1(value));
}
var toPlainObject_1 = toPlainObject$1;
var assignMergeValue$1 = _assignMergeValue;
var cloneBuffer = _cloneBufferExports;
var cloneTypedArray = _cloneTypedArray;
var copyArray = _copyArray;
var initCloneObject = _initCloneObject;
var isArguments = isArguments_1;
var isArray = isArray_1;
var isArrayLikeObject = isArrayLikeObject_1;
var isBuffer = isBufferExports;
var isFunction = isFunction_1;
var isObject$3 = isObject_1;
var isPlainObject$1 = isPlainObject_1;
var isTypedArray = isTypedArray_1;
var safeGet$1 = _safeGet;
var toPlainObject = toPlainObject_1;
function baseMergeDeep$1(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet$1(object, key), srcValue = safeGet$1(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue$1(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject$1(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject$3(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue$1(object, key, newValue);
}
var _baseMergeDeep = baseMergeDeep$1;
var Stack = _Stack;
var assignMergeValue = _assignMergeValue;
var baseFor = _baseFor;
var baseMergeDeep = _baseMergeDeep;
var isObject$2 = isObject_1;
var keysIn = keysIn_1;
var safeGet = _safeGet;
function baseMerge$1(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack());
    if (isObject$2(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge$1, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}
var _baseMerge = baseMerge$1;
var identity = identity_1;
var overRest = _overRest;
var setToString = _setToString;
function baseRest$1(func, start) {
  return setToString(overRest(func, start, identity), func + "");
}
var _baseRest = baseRest$1;
var eq = eq_1;
var isArrayLike = isArrayLike_1;
var isIndex = _isIndex;
var isObject$1 = isObject_1;
function isIterateeCall$1(value, index, object) {
  if (!isObject$1(object)) {
    return false;
  }
  var type = typeof index;
  if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
    return eq(object[index], value);
  }
  return false;
}
var _isIterateeCall = isIterateeCall$1;
var baseRest = _baseRest;
var isIterateeCall = _isIterateeCall;
function createAssigner$1(assigner) {
  return baseRest(function(object, sources) {
    var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}
var _createAssigner = createAssigner$1;
var baseMerge = _baseMerge;
var createAssigner = _createAssigner;
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});
var merge_1 = merge;
var merge$1 = getDefaultExportFromCjs(merge_1);
function last$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : void 0;
}
var last_1 = last$1;
var baseGet = _baseGet;
var baseSlice = _baseSlice;
function parent$1(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}
var _parent = parent$1;
var castPath$1 = _castPath;
var last = last_1;
var parent = _parent;
var toKey = _toKey;
function baseUnset$1(object, path) {
  path = castPath$1(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last(path))];
}
var _baseUnset = baseUnset$1;
var isPlainObject = isPlainObject_1;
function customOmitClone$1(value) {
  return isPlainObject(value) ? void 0 : value;
}
var _customOmitClone = customOmitClone$1;
var arrayMap = _arrayMap;
var baseClone = _baseClone;
var baseUnset = _baseUnset;
var castPath = _castPath;
var copyObject = _copyObject;
var customOmitClone = _customOmitClone;
var flatRest = _flatRest;
var getAllKeysIn = _getAllKeysIn;
var CLONE_DEEP_FLAG = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG = 4;
var omit = flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap(paths, function(path) {
    path = castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object, getAllKeysIn(object), result);
  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset(result, paths[length]);
  }
  return result;
});
var omit_1 = omit;
var omit$1 = getDefaultExportFromCjs(omit_1);
function baseClamp$1(number, lower, upper) {
  if (number === number) {
    if (upper !== void 0) {
      number = number <= upper ? number : upper;
    }
    if (lower !== void 0) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}
var _baseClamp = baseClamp$1;
var baseClamp = _baseClamp;
var toNumber = toNumber_1;
function clamp(number, lower, upper) {
  if (upper === void 0) {
    upper = lower;
    lower = void 0;
  }
  if (upper !== void 0) {
    upper = toNumber(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower !== void 0) {
    lower = toNumber(lower);
    lower = lower === lower ? lower : 0;
  }
  return baseClamp(toNumber(number), lower, upper);
}
var clamp_1 = clamp;
var clamp$1 = getDefaultExportFromCjs(clamp_1);
function noop() {
}
var noop_1 = noop;
var noop$1 = getDefaultExportFromCjs(noop_1);
var debounce = debounce_1;
var isObject = isObject_1;
var FUNC_ERROR_TEXT = "Expected a function";
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_1 = throttle;
var throttle$1 = getDefaultExportFromCjs(throttle_1);
var createCompounder = _createCompounder;
var upperFirst = upperFirst_1;
var startCase = createCompounder(function(result, word, index) {
  return result + (index ? " " : "") + upperFirst(word);
});
var startCase_1 = startCase;
var startCase$1 = getDefaultExportFromCjs(startCase_1);
var baseGetTag$1 = _baseGetTag;
var isObjectLike$1 = isObjectLike_1;
var dateTag = "[object Date]";
function baseIsDate$1(value) {
  return isObjectLike$1(value) && baseGetTag$1(value) == dateTag;
}
var _baseIsDate = baseIsDate$1;
var baseIsDate = _baseIsDate;
var baseUnary = _baseUnary;
var nodeUtil = _nodeUtilExports;
var nodeIsDate = nodeUtil && nodeUtil.isDate;
var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
var isDate_1 = isDate;
var isDate$1 = getDefaultExportFromCjs(isDate_1);
var baseGetTag = _baseGetTag;
var isObjectLike = isObjectLike_1;
var numberTag = "[object Number]";
function isNumber(value) {
  return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
}
var isNumber_1 = isNumber;
var isNumber$1 = getDefaultExportFromCjs(isNumber_1);

// node_modules/vuestic-ui/dist/es/src/utils/merge-deep.js
var isObject2 = (obj) => obj && typeof obj === "object" && !Array.isArray(obj);
var mergeDeep = (target, source) => {
  if (!isObject2(target) || !isObject2(source)) {
    return source;
  }
  Object.keys(source).forEach((key) => {
    const targetValue = target[key];
    const sourceValue = source[key];
    if (isObject2(targetValue) && isObject2(sourceValue)) {
      target[key] = mergeDeep(Object.create(
        Object.getPrototypeOf(targetValue),
        Object.getOwnPropertyDescriptors(targetValue)
      ), sourceValue);
    } else {
      target[key] = sourceValue;
    }
  });
  return target;
};

// node_modules/vuestic-ui/dist/es/src/services/colors-classes/config/default.js
var ColorsClassesPresets = [
  {
    prefix: "bg",
    property: "background-color"
  },
  {
    prefix: "text",
    property: ["color", "fill"]
  }
];
var getColorsClassesDefaultConfig = () => ColorsClassesPresets;

// node_modules/vuestic-ui/dist/es/src/services/color/config/make-config.js
var makeColorsConfig = (values) => ({
  ...values,
  get variables() {
    return this.presets[this.currentPresetName];
  },
  set variables(value) {
    this.presets[this.currentPresetName] = value;
  }
});

// node_modules/vuestic-ui/dist/es/src/services/color/config/default.js
var getColorDefaultConfig = () => makeColorsConfig({
  threshold: 150,
  presets: {
    light: presets.light,
    dark: presets.dark
  },
  currentPresetName: "light"
});

// node_modules/vuestic-ui/dist/es/src/services/icon/presets/vuestic-aliases.js
var VuesticIconAliases = [
  {
    name: "va-arrow-first",
    to: "mi-first_page"
  },
  {
    name: "va-arrow-last",
    to: "mi-last_page"
  },
  {
    name: "va-arrow-right",
    to: "mi-chevron_right"
  },
  {
    name: "va-arrow-left",
    to: "mi-chevron_left"
  },
  {
    name: "va-arrow-down",
    to: "mi-expand_more"
  },
  {
    name: "va-arrow-up",
    to: "mi-expand_less"
  },
  {
    name: "va-calendar",
    to: "mi-calendar_today"
  },
  {
    name: "va-delete",
    to: "mi-delete_outline"
  },
  {
    name: "va-check",
    to: "mi-check"
  },
  {
    name: "va-check-circle",
    to: "mi-check_circle"
  },
  {
    name: "va-warning",
    to: "mi-warning"
  },
  {
    name: "va-clear",
    to: "mi-highlight_off"
  },
  {
    name: "va-close",
    to: "mi-close"
  },
  {
    name: "va-loading",
    to: "mi-loop"
  }
];

// node_modules/vuestic-ui/dist/es/src/services/icon/presets/fonts.js
var VuesticIconFonts = [
  {
    name: "mi-{icon}",
    class: "material-icons",
    resolve: ({ icon }) => ({ content: icon })
  },
  // Fallback
  {
    name: "{icon}",
    class: "material-icons",
    resolve: ({ icon }) => ({ content: icon })
  }
];

// node_modules/vuestic-ui/dist/es/src/services/icon/create-icons-config.js
var createIconsConfig = (config) => {
  config.aliases = config.aliases || [];
  config.fonts = config.fonts || [];
  return [
    ...config.aliases,
    ...VuesticIconAliases,
    ...config.fonts,
    ...VuesticIconFonts
  ];
};

// node_modules/vuestic-ui/dist/es/src/services/icon/config/default.js
var getIconDefaultConfig = () => createIconsConfig({});

// node_modules/vuestic-ui/dist/es/src/services/component-config/config/default.js
var getComponentsDefaultConfig = () => (
  // TODO: Should be handled in size service
  {
    VaIcon: {
      sizesConfig: {
        defaultSize: 18,
        sizes: {
          small: 14,
          medium: 18,
          large: 24
        }
      }
    },
    VaRating: {
      sizesConfig: {
        defaultSize: 18,
        sizes: {
          small: 14,
          medium: 18,
          large: 24
        }
      }
    },
    all: {},
    presets: {
      VaButton: {
        default: {
          backgroundOpacity: 1,
          hoverBehavior: "mask",
          hoverOpacity: 0.15,
          pressedBehavior: "mask",
          pressedOpacity: 0.13
        },
        primary: {
          backgroundOpacity: 0.1,
          hoverBehavior: "opacity",
          hoverOpacity: 0.07,
          pressedBehavior: "opacity",
          pressedOpacity: 0.13
        },
        secondary: {
          backgroundOpacity: 0,
          hoverBehavior: "opacity",
          hoverOpacity: 0.07,
          pressedBehavior: "opacity",
          pressedOpacity: 0.13
        },
        plain: {
          plain: true,
          hoverBehavior: "mask",
          hoverOpacity: 0.15,
          pressedBehavior: "mask",
          pressedOpacity: 0.13
        },
        plainOpacity: {
          plain: true,
          textOpacity: 0.6,
          hoverBehavior: "opacity",
          hoverOpacity: 1,
          pressedBehavior: "opacity",
          pressedOpacity: 0.9
        }
      },
      VaInputWrapper: {
        solid: {
          background: "backgroundElement"
        },
        bordered: {
          class: "va-input-wrapper--bordered",
          background: "backgroundElement"
        }
      },
      VaCheckbox: {
        solid: {
          style: "--va-checkbox-background: var(--va-background-element)"
        }
      },
      VaRadio: {
        solid: {
          style: "--va-radio-background: var(--va-background-element)"
        }
      },
      VaMenu: {
        context: {
          cursor: true,
          placement: "right-start",
          trigger: "right-click"
        }
      }
    }
  }
);

// node_modules/vuestic-ui/dist/es/src/services/i18n/config/default.js
var getI18nConfigDefaults = () => ({
  // PROPS
  /** Select search field default text */
  search: "Search",
  /** Select no options text */
  noOptions: "Items not found",
  /** Modal Ok button default text */
  ok: "OK",
  /** Modal Cancel button default text */
  cancel: "Cancel",
  /** FileUpload default button text */
  uploadFile: "Upload file",
  /** FileUpload default undo button text */
  undo: "Undo",
  /** FileUpload default dropzone text */
  dropzone: "Drop files here to upload",
  /** FileUpload default file deleted alert text */
  fileDeleted: "File deleted",
  // Aria attributes
  /** Alert close button aria-label */
  closeAlert: "close alert",
  backToTop: "back to top",
  toggleDropdown: "toggle dropdown",
  carousel: "carousel",
  goPreviousSlide: "go previous slide",
  goNextSlide: "go next slide",
  goSlide: "go slide {index}",
  slideOf: "slide {index} of {length}",
  close: "close",
  openColorPicker: "open color picker",
  colorSelection: "color selection",
  colorName: "color {color}",
  decreaseCounter: "decrease counter",
  increaseCounter: "increase counter",
  selectAllRows: "select all rows",
  sortColumnBy: "sort column by {name}",
  selectRowByIndex: "select row {index}",
  resetDate: "reset date",
  nextPeriod: "next period",
  switchView: "switch view",
  previousPeriod: "previous period",
  removeFile: "remove file",
  reset: "reset",
  pagination: "pagination",
  goToTheFirstPage: "go to the first page",
  goToPreviousPage: "go to the previous page",
  goToSpecificPage: "go to the {page} page",
  goToSpecificPageInput: "enter the page number to go",
  goNextPage: "go next page",
  goLastPage: "go last page",
  /** Rating aria-label */
  currentRating: "current rating {value} of {max}",
  /** Rating item aria-label */
  voteRating: "vote rating {value} of {max}",
  /** Select search input aria-label */
  optionsFilter: "options filter",
  splitPanels: "split panels",
  movePaginationLeft: "move pagination left",
  movePaginationRight: "move pagination right",
  resetTime: "reset time",
  closeToast: "close toast",
  /**
   * Select aria-label selected option prefix
   *
   * @example
   *
   * `Selected option: {option}` or `Selected option: Animal`
   */
  selectedOption: "Selected option",
  /** Select aria-label if no option is selected */
  noSelectedOption: "Option is not selected",
  breadcrumbs: "breadcrumbs",
  counterValue: "counter value",
  selectedDate: "selected date",
  selectedTime: "selected time",
  progressState: "progress state",
  color: "color",
  /** Stepper next button text */
  next: "Next",
  /** Stepper previous button text */
  back: "Previous",
  /** Stepper finish button text */
  finish: "Finish",
  step: "step",
  progress: "progress",
  /** Skeleton aria label */
  loading: "Loading",
  /** Slider aria label */
  sliderValue: "Current slider value is {value}",
  /** Switch aria label */
  switch: "Switch",
  /** Input aria label */
  inputField: "Input field"
});

// node_modules/vuestic-ui/dist/es/src/services/global-config/global-config.js
var GLOBAL_CONFIG = Symbol("GLOBAL_CONFIG");
var getDefaultConfig = () => ({
  colors: getColorDefaultConfig(),
  icons: getIconDefaultConfig(),
  components: getComponentsDefaultConfig(),
  breakpoint: getBreakpointDefaultConfig(),
  i18n: getI18nConfigDefaults(),
  colorsClasses: getColorsClassesDefaultConfig(),
  /**
   * global config variable to pass nuxt-link component to vuestic-ui via @vuestic/nuxt
   * TODO: give a try to integrate inertia js router components via this option
   * TODO: if this try won't be success, may be remake to provide/inject
   */
  routerComponent: void 0
});
var createGlobalConfig = (defaultConfig = {}) => {
  const globalConfig = ref(mergeDeep(getDefaultConfig(), defaultConfig));
  const getGlobalConfig = () => globalConfig.value;
  const setGlobalConfig = (updater) => {
    const config = typeof updater === "function" ? updater(globalConfig.value) : updater;
    globalConfig.value = cloneDeep$1(config);
  };
  const mergeGlobalConfig = (updater) => {
    const config = typeof updater === "function" ? updater(globalConfig.value) : updater;
    globalConfig.value = mergeDeep(cloneDeep$1(globalConfig.value), config);
  };
  return {
    getGlobalConfig,
    setGlobalConfig,
    mergeGlobalConfig,
    globalConfig
  };
};
var provideForCurrentApp = (provide2) => {
  var _a2, _b;
  const provides = ((_a2 = getCurrentInstance()) == null ? void 0 : _a2.appContext.provides) || ((_b = getCurrentApp()) == null ? void 0 : _b._context.provides);
  if (!provides) {
    throw new Error("Vue app not found for provide");
  }
  provides[GLOBAL_CONFIG] = provide2;
  return provide2;
};

// node_modules/vuestic-ui/dist/es/src/composables/useGlobalConfig.js
function useGlobalConfig() {
  let injected = inject2(GLOBAL_CONFIG);
  if (!injected) {
    injected = createGlobalConfig();
    provideForCurrentApp(injected);
  }
  return injected;
}

// node_modules/vuestic-ui/dist/es/src/services/vue-plugin/utils/define-vuestic-plugin.js
var defineVuesticPlugin = (fabric) => fabric;

// node_modules/vuestic-ui/dist/es/src/services/cache/plugin/index.js
var VaAppCachePluginKey = Symbol("VaAppCachePlugin");
var CachePlugin = defineVuesticPlugin(() => ({
  install(app) {
    const cache = {
      colorContrast: {}
    };
    app.provide(VaAppCachePluginKey, cache);
  }
}));

// node_modules/vuestic-ui/dist/es/src/composables/useCache.js
var useCache = () => {
  const cache = inject2(VaAppCachePluginKey);
  if (!cache) {
    return {
      colorContrast: {}
    };
  }
  return cache;
};

// node_modules/vuestic-ui/dist/es/src/composables/useReactiveComputed.js
var useReactiveComputed = (obj) => {
  const objectRef = typeof obj === "function" ? computed(obj) : computed(obj);
  const proxy = new Proxy(objectRef, {
    get(target, p2, receiver) {
      if (typeof objectRef.value !== "object") {
        return void 0;
      }
      return unref(Reflect.get(objectRef.value, p2, receiver));
    },
    set(target, p2, value) {
      if (isRef(objectRef.value[p2]) && !isRef(value)) {
        objectRef.value[p2].value = value;
      } else {
        objectRef.value[p2] = value;
      }
      return true;
    },
    deleteProperty(target, p2) {
      return Reflect.deleteProperty(objectRef.value, p2);
    },
    has(target, p2) {
      if (typeof objectRef.value !== "object") {
        return false;
      }
      return Reflect.has(objectRef.value, p2);
    },
    ownKeys() {
      if (typeof objectRef.value !== "object") {
        return [];
      }
      return Object.keys(objectRef.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }
  });
  return reactive(proxy);
};

// node_modules/colortranslator/esm/index.js
var t = function() {
  return t = Object.assign || function(t2) {
    for (var e2, r2 = 1, n2 = arguments.length; r2 < n2; r2++)
      for (var a2 in e2 = arguments[r2])
        Object.prototype.hasOwnProperty.call(e2, a2) && (t2[a2] = e2[a2]);
    return t2;
  }, t.apply(this, arguments);
};
function e(t2, e2, r2) {
  if (r2 || 2 === arguments.length)
    for (var n2, a2 = 0, o2 = e2.length; a2 < o2; a2++)
      !n2 && a2 in e2 || (n2 || (n2 = Array.prototype.slice.call(e2, 0, a2)), n2[a2] = e2[a2]);
  return t2.concat(n2 || Array.prototype.slice.call(e2));
}
var r;
var n;
var a;
var o;
!function(t2) {
  t2.HEX = "HEX", t2.RGB = "RGB", t2.HSL = "HSL", t2.CMYK = "CMYK";
}(r || (r = {})), function(t2) {
  t2.ANALOGOUS = "ANALOGOUS", t2.COMPLEMENTARY = "COMPLEMENTARY", t2.SPLIT_COMPLEMENTARY = "SPLIT_COMPLEMENTARY", t2.TRIADIC = "TRIADIC", t2.TETRADIC = "TETRADIC", t2.SQUARE = "SQUARE";
}(n || (n = {})), function(t2) {
  t2.ADDITIVE = "ADDITIVE", t2.SUBTRACTIVE = "SUBTRACTIVE";
}(a || (a = {})), function(t2) {
  t2.black = "#000000", t2.silver = "#C0C0C0", t2.gray = "#808080", t2.white = "#FFFFFF", t2.maroon = "#800000", t2.red = "#FF0000", t2.purple = "#800080", t2.fuchsia = "#FF00FF", t2.green = "#008000", t2.lime = "#00FF00", t2.olive = "#808000", t2.yellow = "#FFFF00", t2.navy = "#000080", t2.blue = "#0000FF", t2.teal = "#008080", t2.aqua = "#00FFFF", t2.orange = "#FFA500", t2.aliceblue = "#F0F8FF", t2.antiquewhite = "#FAEBD7", t2.aquamarine = "#7FFFD4", t2.azure = "#F0FFFF", t2.beige = "#F5F5DC", t2.bisque = "#FFE4C4", t2.blanchedalmond = "#FFEBCD", t2.blueviolet = "#8A2BE2", t2.brown = "#A52A2A", t2.burlywood = "#DEB887", t2.cadetblue = "#5F9EA0", t2.chartreuse = "#7FFF00", t2.chocolate = "#D2691E", t2.coral = "#FF7F50", t2.cornflowerblue = "#6495ED", t2.cornsilk = "#FFF8DC", t2.crimson = "#DC143C", t2.cyan = "#00FFFF", t2.darkblue = "#00008B", t2.darkcyan = "#008B8B", t2.darkgoldenrod = "#B8860B", t2.darkgray = "#A9A9A9", t2.darkgreen = "#006400", t2.darkgrey = "#A9A9A9", t2.darkkhaki = "#BDB76B", t2.darkmagenta = "#8B008B", t2.darkolivegreen = "#556B2F", t2.darkorange = "#FF8C00", t2.darkorchid = "#9932CC", t2.darkred = "#8B0000", t2.darksalmon = "#E9967A", t2.darkseagreen = "#8FBC8F", t2.darkslateblue = "#483D8B", t2.darkslategray = "#2F4F4F", t2.darkslategrey = "#2F4F4F", t2.darkturquoise = "#00CED1", t2.darkviolet = "#9400D3", t2.deeppink = "#FF1493", t2.deepskyblue = "#00BFFF", t2.dimgray = "#696969", t2.dimgrey = "#696969", t2.dodgerblue = "#1E90FF", t2.firebrick = "#B22222", t2.floralwhite = "#FFFAF0", t2.forestgreen = "#228B22", t2.gainsboro = "#DCDCDC", t2.ghostwhite = "#F8F8FF", t2.gold = "#FFD700", t2.goldenrod = "#DAA520", t2.greenyellow = "#ADFF2F", t2.grey = "#808080", t2.honeydew = "#F0FFF0", t2.hotpink = "#FF69B4", t2.indianred = "#CD5C5C", t2.indigo = "#4B0082", t2.ivory = "#FFFFF0", t2.khaki = "#F0E68C", t2.lavender = "#E6E6FA", t2.lavenderblush = "#FFF0F5", t2.lawngreen = "#7CFC00", t2.lemonchiffon = "#FFFACD", t2.lightblue = "#ADD8E6", t2.lightcoral = "#F08080", t2.lightcyan = "#E0FFFF", t2.lightgoldenrodyellow = "#FAFAD2", t2.lightgray = "#D3D3D3", t2.lightgreen = "#90EE90", t2.lightgrey = "#D3D3D3", t2.lightpink = "#FFB6C1", t2.lightsalmon = "#FFA07A", t2.lightseagreen = "#20B2AA", t2.lightskyblue = "#87CEFA", t2.lightslategray = "#778899", t2.lightslategrey = "#778899", t2.lightsteelblue = "#B0C4DE", t2.lightyellow = "#FFFFE0", t2.limegreen = "#32CD32", t2.linen = "#FAF0E6", t2.magenta = "#FF00FF", t2.mediumaquamarine = "#66CDAA", t2.mediumblue = "#0000CD", t2.mediumorchid = "#BA55D3", t2.mediumpurple = "#9370DB", t2.mediumseagreen = "#3CB371", t2.mediumslateblue = "#7B68EE", t2.mediumspringgreen = "#00FA9A", t2.mediumturquoise = "#48D1CC", t2.mediumvioletred = "#C71585", t2.midnightblue = "#191970", t2.mintcream = "#F5FFFA", t2.mistyrose = "#FFE4E1", t2.moccasin = "#FFE4B5", t2.navajowhite = "#FFDEAD", t2.oldlace = "#FDF5E6", t2.olivedrab = "#6B8E23", t2.orangered = "#FF4500", t2.orchid = "#DA70D6", t2.palegoldenrod = "#EEE8AA", t2.palegreen = "#98FB98", t2.paleturquoise = "#AFEEEE", t2.palevioletred = "#DB7093", t2.papayawhip = "#FFEFD5", t2.peachpuff = "#FFDAB9", t2.peru = "#CD853F", t2.pink = "#FFC0CB", t2.plum = "#DDA0DD", t2.powderblue = "#B0E0E6", t2.rosybrown = "#BC8F8F", t2.royalblue = "#4169E1", t2.saddlebrown = "#8B4513", t2.salmon = "#FA8072", t2.sandybrown = "#F4A460", t2.seagreen = "#2E8B57", t2.seashell = "#FFF5EE", t2.sienna = "#A0522D", t2.skyblue = "#87CEEB", t2.slateblue = "#6A5ACD", t2.slategray = "#708090", t2.slategrey = "#708090", t2.snow = "#FFFAFA", t2.springgreen = "#00FF7F", t2.steelblue = "#4682B4", t2.tan = "#D2B48C", t2.thistle = "#D8BFD8", t2.tomato = "#FF6347", t2.turquoise = "#40E0D0", t2.violet = "#EE82EE", t2.wheat = "#F5DEB3", t2.whitesmoke = "#F5F5F5", t2.yellowgreen = "#9ACD32", t2.rebeccapurple = "#663399";
}(o || (o = {}));
var i;
var u;
var c;
var s;
var d;
var h2;
var l;
var f = Object.keys(o);
var g = ((i = {})[r.HEX] = /^#(?:([a-f\d])([a-f\d])([a-f\d])([a-f\d])?|([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?)$/i, i[r.RGB] = /^rgba?\s*\(\s*(?:((?:\d*\.)?\d+%?)\s*,\s*((?:\d*\.)?\d+%?)\s*,\s*((?:\d*\.)?\d+%?)(?:\s*,\s*((?:\d*\.)?\d+))?|((?:\d*\.)?\d+%?)\s*((?:\d*\.)?\d+%?)\s*((?:\d*\.)?\d+%?)(?:\s*\/\s*((?:\d*\.)?\d+%?))?)\s*\)$/, i[r.HSL] = /^hsla?\s*\(\s*(?:(-?(?:\d*\.)?\d+(?:deg|grad|rad|turn)?)\s*,\s*((?:\d*\.)?\d+)%\s*,\s*((?:\d*\.)?\d+)%(?:\s*,\s*((?:\d*\.)?\d+))?|(-?(?:\d*\.)?\d+(?:deg|grad|rad|turn)?)\s*((?:\d*\.)?\d+)%\s*((?:\d*\.)?\d+)%(?:\s*\/\s*((?:\d*\.)?\d+%?))?)\s*\)$/, i[r.CMYK] = /^(?:device-cmyk|cmyk)\s*\(\s*(?:((?:\d*\.)?\d+%?)\s*,\s*((?:\d*\.)?\d+%?)\s*,\s*((?:\d*\.)?\d+%?)\s*,\s*((?:\d*\.)?\d+%?)(?:\s*,\s*((?:\d*\.)?\d+))?|((?:\d*\.)?\d+%?)\s*((?:\d*\.)?\d+%?)\s*((?:\d*\.)?\d+%?)\s*((?:\d*\.)?\d+%?)(?:\s*\/\s*((?:\d*\.)?\d+%?))?)\s*\)$/, i);
var p = /^(-?(?:\d*\.)?\d+)((?:deg|grad|rad|turn)?)$/;
var b = /^(\d+(?:\.\d+)?|\.\d+)%$/;
var F = /^0x([a-f\d]{1,2})$/i;
var y = "The provided string color doesn't have a correct format";
var m = "The provided color object doesn't have the proper keys or format";
var A = function(t2, e2, r2) {
  return r2 < 0 && (r2 += 6), r2 >= 6 && (r2 -= 6), r2 < 1 ? Math.round(255 * ((e2 - t2) * r2 + t2)) : r2 < 3 ? Math.round(255 * e2) : r2 < 4 ? Math.round(255 * ((e2 - t2) * (4 - r2) + t2)) : Math.round(255 * t2);
};
var E = function(t2, e2, r2) {
  e2 /= 100;
  var n2 = (r2 /= 100) <= 0.5 ? r2 * (e2 + 1) : r2 + e2 - r2 * e2, a2 = 2 * r2 - n2;
  return { r: A(a2, n2, (t2 /= 60) + 2), g: A(a2, n2, t2), b: A(a2, n2, t2 - 2) };
};
var H = function(t2, e2, r2, n2) {
  return n2 = 1 - n2, { r: Math.round(255 * (1 - t2) * n2), g: Math.round(255 * (1 - e2) * n2), b: Math.round(255 * (1 - r2) * n2) };
};
var v = function(t2, e2, r2) {
  t2 /= 255, e2 /= 255, r2 /= 255;
  var n2 = 1 - Math.max(t2, e2, r2), a2 = 1 - n2, o2 = (a2 - t2) / a2, i2 = (a2 - e2) / a2, u2 = (a2 - r2) / a2;
  return { c: Math.round(100 * o2), m: Math.round(100 * i2), y: Math.round(100 * u2), k: Math.round(100 * n2) };
};
var B = function(t2, e2, r2, n2) {
  void 0 === n2 && (n2 = 1), t2 /= 255, e2 /= 255, r2 /= 255, n2 = Math.min(n2, 1);
  var a2 = Math.max(t2, e2, r2), o2 = Math.min(t2, e2, r2), i2 = a2 - o2, u2 = 0, c2 = 0, s2 = (a2 + o2) / 2;
  if (0 === i2)
    u2 = 0, c2 = 0;
  else {
    switch (a2) {
      case t2:
        u2 = (e2 - r2) / i2 % 6;
        break;
      case e2:
        u2 = (r2 - t2) / i2 + 2;
        break;
      case r2:
        u2 = (t2 - e2) / i2 + 4;
    }
    (u2 = Math.round(60 * u2)) < 0 && (u2 += 360), c2 = i2 / (1 - Math.abs(2 * s2 - 1));
  }
  return { h: u2, s: Math.round(100 * c2), l: Math.round(100 * s2), a: n2 };
};
var M = function(t2, e2) {
  if (t2 < 0 && (t2 += 360), t2 > 360 && (t2 -= 360), 360 === t2 || 0 === t2)
    return t2;
  var r2 = [[0, 120], [120, 180], [180, 240], [240, 360]], n2 = [[0, 60], [60, 120], [120, 240], [240, 360]], a2 = e2 ? n2 : r2, o2 = 0, i2 = 0, u2 = 0, c2 = 0;
  return (e2 ? r2 : n2).find(function(e3, r3) {
    return t2 >= e3[0] && t2 < e3[1] && (o2 = e3[0], i2 = e3[1], u2 = a2[r3][0], c2 = a2[r3][1], true);
  }), u2 + (c2 - u2) / (i2 - o2) * (t2 - o2);
};
var C = function(t2, e2) {
  return Object.prototype.hasOwnProperty.call(t2, e2);
};
var D = function(t2) {
  return b.test("".concat(t2)) ? +"".concat(t2).replace(b, "$1") : Math.min(+t2, 100);
};
var R = function(t2) {
  return 1 === t2.length && (t2 += t2), parseInt(t2, 16);
};
var S = function(t2) {
  var e2 = X(t2).toString(16).toUpperCase();
  return 1 === e2.length ? "0x0".concat(e2) : "0x".concat(e2);
};
var L = function(t2) {
  var e2 = X(t2).toString(16).toUpperCase();
  return 1 === e2.length && (e2 = "0".concat(e2)), e2;
};
var G = function(t2, e2) {
  return void 0 === e2 && (e2 = false), !e2 && b.test(t2) ? Math.min(255 * +t2.replace(b, "$1") / 100, 255) : F.test(t2) ? 3 === t2.length ? e2 ? parseInt(t2 + t2.slice(-1)) / 255 : parseInt(t2 + t2.slice(-1)) : e2 ? X(t2, 6) / 255 : X(t2, 6) : Math.min(+t2, e2 ? 1 : 255);
};
var k = function(t2) {
  return Math.min(b.test(t2) ? +t2.replace(b, "$1") / 100 : +t2, 1);
};
var O = function(t2) {
  return t2.sort().join("").toUpperCase();
};
var X = function(t2, e2) {
  void 0 === e2 && (e2 = 0);
  var r2 = Math.pow(10, e2);
  return Math.round(+t2 * r2) / r2;
};
var j = function(t2, e2, r2) {
  return Math.max(e2, Math.min(t2, r2));
};
var I = ((u = {})[r.HEX] = function(t2) {
  return "#".concat(L(t2.r)).concat(L(t2.g)).concat(L(t2.b)).concat(C(t2, "a") && L(t2.a) || "");
}, u[r.RGB] = function(t2) {
  return "rgb".concat(C(t2, "a") ? "a" : "", "(").concat(X(t2.r), ",").concat(X(t2.g), ",").concat(X(t2.b)).concat(C(t2, "a") && ",".concat(X(t2.a, 2)) || "", ")");
}, u[r.HSL] = function(t2) {
  return "hsl".concat(C(t2, "a") ? "a" : "", "(").concat(X(t2.h), ",").concat(X(t2.s), "%,").concat(X(t2.l), "%").concat(C(t2, "a") && ",".concat(X(t2.a, 2)) || "", ")");
}, u[r.CMYK] = function(t2) {
  return "cmyk(".concat(X(t2.c), "%,").concat(X(t2.m), "%,").concat(X(t2.y), "%,").concat(X(t2.k), "%").concat(C(t2, "a") && ",".concat(X(t2.a, 2)) || "", ")");
}, u);
var Y = function(t2) {
  if ("string" == typeof t2) {
    var e2 = t2.match(p), r2 = +e2[1];
    switch (e2[2]) {
      case "rad":
        t2 = Math.round(180 * r2 / Math.PI);
        break;
      case "turn":
        t2 = Math.round(360 * r2);
        break;
      default:
        t2 = r2;
    }
  }
  return (t2 > 360 || t2 < 0) && (t2 -= 360 * Math.floor(t2 / 360)), t2;
};
var T = function(t2) {
  return "string" == typeof t2 && (t2 = b.test(t2) ? +t2.replace(b, "$1") / 100 : +t2), isNaN(+t2) || t2 > 1 ? 1 : X(t2, 6);
};
var K = function(r2, n2, o2) {
  return n2.reduce(function(n3, i2) {
    return e(e([], n3, true), [t(t({}, r2), { h: o2 === a.ADDITIVE ? Y(r2.h + i2) : Y(M(M(r2.h, false) + i2, true)) })], false);
  }, [t({}, r2)]);
};
var P = function(t2, e2) {
  return K(t2, [30, -30], e2);
};
var w = function(t2, e2) {
  return K(t2, [180], e2);
};
var x = function(t2, e2) {
  return K(t2, [150, -150], e2);
};
var N = function(t2, e2) {
  return K(t2, [120, -120], e2);
};
var V = function(t2, e2) {
  return K(t2, [60, -120, 180], e2);
};
var U = function(t2, e2) {
  return K(t2, [90, -90, 180], e2);
};
var $ = Object.entries(r).reduce(function(t2, e2) {
  var n2 = e2[0], a2 = e2[1];
  if (n2 !== r.HEX) {
    var o2 = O(n2.split(""));
    t2[o2] = a2, t2["A" + o2] = a2;
  }
  return t2;
}, {});
var q = function(t2) {
  return "string" == typeof t2 ? function(t3) {
    var e2;
    if (Object.keys(r).some(function(r2) {
      if (g[r2].test(t3))
        return e2 = r2, true;
    }), !e2 && ~f.indexOf(t3) && (e2 = r.HEX), !e2)
      throw new Error(y);
    return e2;
  }(t2) : function(t3) {
    var e2, n2 = false, a2 = O(Object.keys(t3));
    if ($[a2] && (e2 = $[a2]), e2 && e2 === r.RGB) {
      var o2 = Object.entries(t3).some(function(t4) {
        return !F.test("".concat(t4[1]));
      }), i2 = Object.entries(t3).some(function(t4) {
        return !(b.test("".concat(t4[1])) || !F.test("".concat(t4[1])) && !isNaN(+t4[1]) && +t4[1] <= 255);
      });
      o2 && i2 && (n2 = true), o2 || (e2 = r.HEX);
    }
    if (!e2 || n2)
      throw new Error(m);
    return e2;
  }(t2);
};
var Q = ((c = {})[r.HEX] = function(t2) {
  var e2 = (~f.indexOf(t2) ? o[t2] : t2).match(g.HEX), r2 = { r: R(e2[1] || e2[5]), g: R(e2[2] || e2[6]), b: R(e2[3] || e2[7]) }, n2 = e2[4] || e2[8];
  return void 0 !== n2 && (r2.a = R(n2) / 255), r2;
}, c[r.RGB] = function(t2) {
  var e2 = t2.match(g.RGB), r2 = G(e2[1] || e2[5]), n2 = G(e2[2] || e2[6]), a2 = G(e2[3] || e2[7]), o2 = e2[4] || e2[8], i2 = { r: Math.min(r2, 255), g: Math.min(n2, 255), b: Math.min(a2, 255) };
  return void 0 !== o2 && (i2.a = T(o2)), i2;
}, c[r.HSL] = function(t2) {
  var e2 = t2.match(g.HSL), r2 = Y(e2[1] || e2[5]), n2 = D(e2[2] || e2[6]), a2 = D(e2[3] || e2[7]), o2 = e2[4] || e2[8], i2 = E(r2, n2, a2);
  return void 0 !== o2 && (i2.a = T(o2)), i2;
}, c[r.CMYK] = function(t2) {
  var e2 = t2.match(g.CMYK), r2 = k(e2[1] || e2[6]), n2 = k(e2[2] || e2[7]), a2 = k(e2[3] || e2[8]), o2 = k(e2[4] || e2[9]), i2 = e2[5] || e2[10], u2 = H(r2, n2, a2, o2);
  return void 0 !== i2 && (u2.a = T(i2)), u2;
}, c);
var _ = ((s = {})[r.HEX] = function(t2) {
  var e2 = { r: G("".concat(t2.r)), g: G("".concat(t2.g)), b: G("".concat(t2.b)) };
  return C(t2, "a") && (e2.a = Math.min(G("".concat(t2.a), true), 1)), e2;
}, s[r.RGB] = function(t2) {
  return this.HEX(t2);
}, s[r.HSL] = function(t2) {
  var e2 = D("".concat(t2.s)), r2 = D("".concat(t2.l)), n2 = E(Y(t2.h), e2, r2);
  return C(t2, "a") && (n2.a = T(t2.a)), n2;
}, s[r.CMYK] = function(t2) {
  var e2 = k("".concat(t2.c)), r2 = k("".concat(t2.m)), n2 = k("".concat(t2.y)), a2 = k("".concat(t2.k)), o2 = H(e2, r2, n2, a2);
  return C(t2, "a") && (o2.a = T(t2.a)), o2;
}, s);
var z = function(t2, e2) {
  return void 0 === e2 && (e2 = q(t2)), "string" == typeof t2 ? Q[e2](t2) : _[e2](t2);
};
var J = ((d = {})[r.HEX] = function(t2) {
  return { r: S(t2.r), g: S(t2.g), b: S(t2.b) };
}, d.HEXA = function(t2) {
  var e2 = J.HEX(t2);
  return e2.a = C(t2, "a") ? S(255 * t2.a) : "0xFF", e2;
}, d[r.RGB] = function(t2) {
  return C(t2, "a") && delete t2.a, t2;
}, d.RGBA = function(t2) {
  return t2.a = C(t2, "a") ? X(t2.a, 2) : 1, t2;
}, d[r.HSL] = function(t2) {
  var e2 = B(t2.r, t2.g, t2.b);
  return delete e2.a, e2;
}, d.HSLA = function(t2) {
  var e2 = J.HSL(t2);
  return e2.a = C(t2, "a") ? X(t2.a, 2) : 1, e2;
}, d[r.CMYK] = function(t2) {
  return v(t2.r, t2.g, t2.b);
}, d.CMYKA = function(t2) {
  var e2 = v(t2.r, t2.g, t2.b);
  return e2.a = C(t2, "a") ? X(t2.a, 2) : 1, e2;
}, d);
var W = function(e2, n2, a2) {
  var o2 = q(e2), i2 = "string" == typeof e2, u2 = z(e2, o2), c2 = "string" == typeof e2 && C(u2, "a") || "string" != typeof e2 && C(e2, "a"), s2 = B(u2.r, u2.g, u2.b, u2.a);
  c2 || delete s2.a;
  var d2 = a2 ? s2.l / (n2 + 1) : (100 - s2.l) / (n2 + 1), h3 = Array(n2).fill(null).map(function(e3, r2) {
    return t(t({}, s2), { l: s2.l + d2 * (r2 + 1) * (1 - 2 * +a2) });
  });
  switch (o2) {
    case r.HEX:
    default:
      return h3.map(function(e3) {
        var r2 = E(e3.h, e3.s, e3.l);
        return c2 && (r2.a = e3.a), i2 ? c2 ? I.HEX(t(t({}, r2), { a: X(255 * r2.a, 6) })) : I.HEX(r2) : c2 ? J.HEXA(r2) : J.HEX(r2);
      });
    case r.RGB:
      return h3.map(function(t2) {
        var e3 = E(t2.h, t2.s, t2.l);
        return c2 && (e3.a = t2.a), i2 ? I.RGB(e3) : c2 ? J.RGBA(e3) : J.RGB(e3);
      });
    case r.HSL:
      return h3.map(function(e3) {
        return i2 ? I.HSL(e3) : c2 ? J.HSLA(t(t({}, E(e3.h, e3.s, e3.l)), { a: e3.a })) : J.HSL(E(e3.h, e3.s, e3.l));
      });
  }
};
var Z = ((h2 = { buildHarmony: function(t2, e2, n2) {
  var a2 = q(t2), o2 = z(t2, a2), i2 = B(o2.r, o2.g, o2.b, o2.a), u2 = "string" == typeof t2 && C(o2, "a") || "string" != typeof t2 && C(t2, "a"), c2 = "string" == typeof t2;
  switch (a2) {
    case r.HEX:
    default:
      return u2 ? this.HEXA(i2, e2, n2, c2) : this.HEX(i2, e2, n2, c2);
    case r.HSL:
      return u2 ? this.HSLA(i2, e2, n2, c2) : this.HSL(i2, e2, n2, c2);
    case r.RGB:
      return u2 ? this.RGBA(i2, e2, n2, c2) : this.RGB(i2, e2, n2, c2);
  }
} })[r.HEX] = function(t2, e2, r2, n2) {
  return e2(t2, r2).map(function(t3) {
    return n2 ? I.HEX(E(t3.h, t3.s, t3.l)) : J.HEX(E(t3.h, t3.s, t3.l));
  });
}, h2.HEXA = function(e2, r2, n2, a2) {
  return r2(e2, n2).map(function(e3) {
    return a2 ? I.HEX(t(t({}, E(e3.h, e3.s, e3.l)), { a: 255 * T(e3.a) })) : J.HEXA(t(t({}, E(e3.h, e3.s, e3.l)), { a: T(e3.a) }));
  });
}, h2[r.RGB] = function(t2, e2, r2, n2) {
  return e2(t2, r2).map(function(t3) {
    return n2 ? I.RGB(E(t3.h, t3.s, t3.l)) : J.RGB(E(t3.h, t3.s, t3.l));
  });
}, h2.RGBA = function(e2, r2, n2, a2) {
  return r2(e2, n2).map(function(e3) {
    return a2 ? I.RGB(t(t({}, E(e3.h, e3.s, e3.l)), { a: T(e3.a) })) : J.RGBA(t(t({}, E(e3.h, e3.s, e3.l)), { a: T(e3.a) }));
  });
}, h2[r.HSL] = function(t2, e2, r2, n2) {
  return e2(t2, r2).map(function(t3) {
    return n2 ? I.HSL({ h: t3.h, s: t3.s, l: t3.l }) : J.HSL(E(t3.h, t3.s, t3.l));
  });
}, h2.HSLA = function(e2, r2, n2, a2) {
  return r2(e2, n2).map(function(e3) {
    return a2 ? I.HSL(t(t({}, e3), { a: T(e3.a) })) : J.HSLA(t(t({}, E(e3.h, e3.s, e3.l)), { a: T(e3.a) }));
  });
}, h2);
var tt = ((l = { mix: function(e2, r2) {
  var n2, o2, i2, u2, c2, s2, d2, h3, l2, f2, g2, p2, b2, F2, y2, m2 = e2.map(function(t2) {
    var e3 = q(t2);
    return z(t2, e3);
  }), A2 = r2 === a.SUBTRACTIVE ? m2.map(function(t2) {
    var e3, r3, n3, a2, o3, i3, u3, c3, s3, d3, h4, l3, f3, g3, p3 = (e3 = t2.r, r3 = t2.g, n3 = t2.b, a2 = Math.min(e3, r3, n3), o3 = Math.min(255 - e3, 255 - r3, 255 - n3), i3 = e3 - a2, u3 = r3 - a2, c3 = n3 - a2, s3 = Math.min(i3, u3), d3 = i3 - s3, h4 = (u3 + s3) / 2, l3 = (c3 + u3 - s3) / 2, f3 = Math.max(d3, h4, l3) / Math.max(i3, u3, c3), g3 = isNaN(f3) || f3 === 1 / 0 || f3 <= 0 ? 1 : f3, { r: d3 / g3 + o3, y: h4 / g3 + o3, b: l3 / g3 + o3 });
    return C(t2, "a") && (p3.a = t2.a), p3;
  }) : null;
  function E2(e3) {
    var n3 = r2 === a.ADDITIVE ? { r: 0, g: 0, b: 0, a: 0 } : { r: 0, y: 0, b: 0, a: 0 };
    return e3.reduce(function(e4, n4) {
      var o3 = C(n4, "a") ? n4.a : 1, i3 = { r: Math.min(e4.r + n4.r * o3, 255), b: Math.min(e4.b + n4.b * o3, 255), a: 1 - (1 - o3) * (1 - e4.a) }, u3 = "g" in e4 ? e4.g : e4.y, c3 = "g" in n4 ? n4.g : n4.y;
      return t(t({}, i3), r2 === a.ADDITIVE ? { g: Math.min(u3 + c3 * o3, 255) } : { y: Math.min(u3 + c3 * o3, 255) });
    }, n3);
  }
  if (r2 === a.ADDITIVE)
    n2 = E2(m2);
  else {
    var H2 = E2(A2);
    o2 = H2.r, i2 = H2.y, u2 = H2.b, c2 = Math.min(o2, i2, u2), s2 = Math.min(255 - o2, 255 - i2, 255 - u2), d2 = o2 - c2, h3 = i2 - c2, l2 = u2 - c2, f2 = Math.min(h3, l2), g2 = d2 + h3 - f2, p2 = h3 + f2, b2 = 2 * (l2 - f2), F2 = Math.max(g2, p2, b2) / Math.max(d2, h3, l2), y2 = isNaN(F2) || F2 === 1 / 0 || F2 <= 0 ? 1 : F2, (n2 = { r: g2 / y2 + s2, g: p2 / y2 + s2, b: b2 / y2 + s2 }).a = H2.a;
  }
  return { r: X(n2.r, 2), g: X(n2.g, 2), b: X(n2.b, 2), a: j(n2.a, 0, 1) };
} })[r.HEX] = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2);
  return delete n2.a, r2 ? I.HEX(n2) : J.HEX(n2);
}, l.HEXA = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2);
  return n2.a = r2 ? 255 * T(n2.a) : T(n2.a), r2 ? I.HEX(n2) : J.HEXA(n2);
}, l[r.RGB] = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2);
  return delete n2.a, r2 ? I.RGB(n2) : J.RGB(n2);
}, l.RGBA = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2);
  return r2 ? I.RGB(n2) : J.RGBA(n2);
}, l[r.HSL] = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2), a2 = B(n2.r, n2.g, n2.b);
  return delete n2.a, delete a2.a, r2 ? I.HSL(a2) : J.HSL(n2);
}, l.HSLA = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2), a2 = B(n2.r, n2.g, n2.b, n2.a);
  return r2 ? I.HSL(a2) : J.HSLA(n2);
}, l);
var et = function(t2, e2, r2, n2, a2) {
  var o2 = n2(z(t2, e2));
  return r2 ? a2(o2) : o2;
};
var rt = function(t2, e2, r2, n2, a2, o2) {
  r2 < 1 && (r2 = 5);
  var i2 = function(t3, e3, r3) {
    var n3 = r3 - 1, a3 = (e3.r - t3.r) / n3, o3 = (e3.g - t3.g) / n3, i3 = (e3.b - t3.b) / n3, u2 = T(t3.a), c2 = (T(e3.a) - u2) / n3;
    return Array(r3).fill(null).map(function(r4, s2) {
      return 0 === s2 ? t3 : s2 === n3 ? e3 : { r: X(t3.r + a3 * s2), g: X(t3.g + o3 * s2), b: X(t3.b + i3 * s2), a: X(u2 + c2 * s2, 2) };
    });
  }(z(t2), z(e2), r2);
  return i2.map(function(t3) {
    var e3 = a2(t3);
    return n2 ? o2(e3) : e3;
  });
};
var nt = function() {
  function e2(t2) {
    this.rgb = z(t2), this.updateHSL(), this.updateCMYK();
  }
  return e2.prototype.updateRGB = function() {
    this.rgb = t(t({}, E(this.hsl.h, this.hsl.s, this.hsl.l)), { a: this.hsl.a });
  }, e2.prototype.updateRGBFromCMYK = function() {
    this.rgb = t(t({}, H(this.cmyk.c, this.cmyk.m, this.cmyk.y, this.cmyk.k)), { a: this.rgb.a });
  }, e2.prototype.updateHSL = function() {
    this.hsl = B(this.rgb.r, this.rgb.g, this.rgb.b, this.rgb.a);
  }, e2.prototype.updateCMYK = function() {
    this.cmyk = v(this.rgb.r, this.rgb.g, this.rgb.b);
  }, e2.prototype.updateRGBAndCMYK = function() {
    return this.updateRGB(), this.updateCMYK(), this;
  }, e2.prototype.updateHSLAndCMYK = function() {
    return this.updateHSL(), this.updateCMYK(), this;
  }, e2.prototype.updateRGBAndHSL = function() {
    return this.updateRGBFromCMYK(), this.updateHSL(), this;
  }, e2.prototype.setH = function(t2) {
    return this.hsl.h = Y(t2), this.updateRGBAndCMYK();
  }, e2.prototype.setS = function(t2) {
    return this.hsl.s = j(t2, 0, 100), this.updateRGBAndCMYK();
  }, e2.prototype.setL = function(t2) {
    return this.hsl.l = j(t2, 0, 100), this.updateRGBAndCMYK();
  }, e2.prototype.setR = function(t2) {
    return this.rgb.r = j(t2, 0, 255), this.updateHSLAndCMYK();
  }, e2.prototype.setG = function(t2) {
    return this.rgb.g = j(t2, 0, 255), this.updateHSLAndCMYK();
  }, e2.prototype.setB = function(t2) {
    return this.rgb.b = j(t2, 0, 255), this.updateHSLAndCMYK();
  }, e2.prototype.setA = function(t2) {
    return this.hsl.a = this.rgb.a = j(t2, 0, 1), this;
  }, e2.prototype.setC = function(t2) {
    return this.cmyk.c = j(t2, 0, 100), this.updateRGBAndHSL();
  }, e2.prototype.setM = function(t2) {
    return this.cmyk.m = j(t2, 0, 100), this.updateRGBAndHSL();
  }, e2.prototype.setY = function(t2) {
    return this.cmyk.y = j(t2, 0, 100), this.updateRGBAndHSL();
  }, e2.prototype.setK = function(t2) {
    return this.cmyk.k = j(t2, 0, 100), this.updateRGBAndHSL();
  }, Object.defineProperty(e2.prototype, "H", { get: function() {
    return X(this.hsl.h);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "S", { get: function() {
    return X(this.hsl.s);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "L", { get: function() {
    return X(this.hsl.l);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "R", { get: function() {
    return X(this.rgb.r);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "G", { get: function() {
    return X(this.rgb.g);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "B", { get: function() {
    return X(this.rgb.b);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "A", { get: function() {
    return X(this.hsl.a, 2);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "C", { get: function() {
    return X(this.cmyk.c);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "M", { get: function() {
    return X(this.cmyk.m);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "Y", { get: function() {
    return X(this.cmyk.y);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "K", { get: function() {
    return X(this.cmyk.k);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "HEXObject", { get: function() {
    return J.HEX(this.rgb);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "HEXAObject", { get: function() {
    return J.HEXA(this.rgb);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "RGBObject", { get: function() {
    return { r: this.R, g: this.G, b: this.B };
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "RGBAObject", { get: function() {
    return t(t({}, this.RGBObject), { a: this.hsl.a });
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "HSLObject", { get: function() {
    return { h: this.H, s: this.S, l: this.L };
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "HSLAObject", { get: function() {
    return t(t({}, this.HSLObject), { a: this.hsl.a });
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "CMYKObject", { get: function() {
    return { c: this.C, m: this.M, y: this.Y, k: this.K };
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "CMYKAObject", { get: function() {
    return { c: this.C, m: this.M, y: this.Y, k: this.K, a: this.hsl.a };
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "HEX", { get: function() {
    var t2 = this.rgb, e3 = { r: t2.r, g: t2.g, b: t2.b };
    return I.HEX(e3);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "HEXA", { get: function() {
    var t2 = this.rgb, e3 = { r: t2.r, g: t2.g, b: t2.b, a: 255 * this.hsl.a };
    return I.HEX(e3);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "RGB", { get: function() {
    var t2 = this.rgb, e3 = { r: t2.r, g: t2.g, b: t2.b };
    return I.RGB(e3);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "RGBA", { get: function() {
    var t2 = this.rgb, e3 = { r: t2.r, g: t2.g, b: t2.b, a: this.hsl.a };
    return I.RGB(e3);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "HSL", { get: function() {
    var t2 = this.hsl, e3 = { h: t2.h, s: t2.s, l: t2.l };
    return I.HSL(e3);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "HSLA", { get: function() {
    return I.HSL(this.hsl);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "CMYK", { get: function() {
    return I.CMYK(this.cmyk);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "CMYKA", { get: function() {
    return I.CMYK(t(t({}, this.cmyk), { a: this.hsl.a }));
  }, enumerable: false, configurable: true }), e2.toHEX = function(t2, e3) {
    void 0 === e3 && (e3 = true);
    var r2 = q(t2);
    return et(t2, r2, e3, J.HEX, I.HEX);
  }, e2.toHEXA = function(t2, e3) {
    void 0 === e3 && (e3 = true);
    var r2 = q(t2);
    return et(t2, r2, e3, J.HEXA, I.HEX);
  }, e2.toRGB = function(t2, e3) {
    void 0 === e3 && (e3 = true);
    var r2 = q(t2);
    return et(t2, r2, e3, J.RGB, I.RGB);
  }, e2.toRGBA = function(t2, e3) {
    void 0 === e3 && (e3 = true);
    var r2 = q(t2);
    return et(t2, r2, e3, J.RGBA, I.RGB);
  }, e2.toHSL = function(t2, e3) {
    void 0 === e3 && (e3 = true);
    var r2 = q(t2);
    return et(t2, r2, e3, J.HSL, I.HSL);
  }, e2.toHSLA = function(t2, e3) {
    void 0 === e3 && (e3 = true);
    var r2 = q(t2);
    return et(t2, r2, e3, J.HSLA, I.HSL);
  }, e2.toCMYK = function(t2, e3) {
    void 0 === e3 && (e3 = true);
    var r2 = q(t2);
    return et(t2, r2, e3, J.CMYK, I.CMYK);
  }, e2.toCMYKA = function(t2, e3) {
    void 0 === e3 && (e3 = true);
    var r2 = q(t2);
    return et(t2, r2, e3, J.CMYKA, I.CMYK);
  }, e2.getBlendHEX = function(t2, e3, r2, n2) {
    return void 0 === r2 && (r2 = 5), void 0 === n2 && (n2 = true), rt(t2, e3, r2, n2, J.HEX, I.HEX);
  }, e2.getBlendHEXA = function(t2, e3, r2, n2) {
    return void 0 === r2 && (r2 = 5), void 0 === n2 && (n2 = true), rt(t2, e3, r2, n2, J.HEXA, I.HEX);
  }, e2.getBlendRGB = function(t2, e3, r2, n2) {
    return void 0 === r2 && (r2 = 5), void 0 === n2 && (n2 = true), rt(t2, e3, r2, n2, J.RGB, I.RGB);
  }, e2.getBlendRGBA = function(t2, e3, r2, n2) {
    return void 0 === r2 && (r2 = 5), void 0 === n2 && (n2 = true), rt(t2, e3, r2, n2, J.RGBA, I.RGB);
  }, e2.getBlendHSL = function(t2, e3, r2, n2) {
    return void 0 === r2 && (r2 = 5), void 0 === n2 && (n2 = true), rt(t2, e3, r2, n2, J.HSL, I.HSL);
  }, e2.getBlendHSLA = function(t2, e3, r2, n2) {
    return void 0 === r2 && (r2 = 5), void 0 === n2 && (n2 = true), rt(t2, e3, r2, n2, J.HSLA, I.HSL);
  }, e2.getMixHEX = function(t2, e3, r2) {
    return void 0 === e3 && (e3 = a.ADDITIVE), void 0 === r2 && (r2 = true), tt.HEX(t2, e3, r2);
  }, e2.getMixHEXA = function(t2, e3, r2) {
    return void 0 === e3 && (e3 = a.ADDITIVE), void 0 === r2 && (r2 = true), tt.HEXA(t2, e3, r2);
  }, e2.getMixRGB = function(t2, e3, r2) {
    return void 0 === e3 && (e3 = a.ADDITIVE), void 0 === r2 && (r2 = true), tt.RGB(t2, e3, r2);
  }, e2.getMixRGBA = function(t2, e3, r2) {
    return void 0 === e3 && (e3 = a.ADDITIVE), void 0 === r2 && (r2 = true), tt.RGBA(t2, e3, r2);
  }, e2.getMixHSL = function(t2, e3, r2) {
    return void 0 === e3 && (e3 = a.ADDITIVE), void 0 === r2 && (r2 = true), tt.HSL(t2, e3, r2);
  }, e2.getMixHSLA = function(t2, e3, r2) {
    return void 0 === e3 && (e3 = a.ADDITIVE), void 0 === r2 && (r2 = true), tt.HSLA(t2, e3, r2);
  }, e2.getShades = function(t2, e3) {
    return W(t2, e3, true);
  }, e2.getTints = function(t2, e3) {
    return W(t2, e3, false);
  }, e2.getHarmony = function(t2, e3, r2) {
    switch (void 0 === e3 && (e3 = n.COMPLEMENTARY), void 0 === r2 && (r2 = a.ADDITIVE), e3) {
      case n.ANALOGOUS:
        return Z.buildHarmony(t2, P, r2);
      case n.SPLIT_COMPLEMENTARY:
        return Z.buildHarmony(t2, x, r2);
      case n.TRIADIC:
        return Z.buildHarmony(t2, N, r2);
      case n.TETRADIC:
        return Z.buildHarmony(t2, V, r2);
      case n.SQUARE:
        return Z.buildHarmony(t2, U, r2);
      default:
        return Z.buildHarmony(t2, w, r2);
    }
  }, e2;
}();

// node_modules/vuestic-ui/dist/es/src/services/color/utils.js
var makeColor = (color) => {
  try {
    return new nt(color);
  } catch (e2) {
    throw new Error(`Color ${color} is not valid. Please, provide valid color.`, {
      cause: e2
    });
  }
};
var isCSSVariable = (strColor) => /var\(--.+\)/.test(strColor);
var cssVariableName = (colorName) => `--va-${kebabCase$1(colorName)}`;
var normalizeColorName = (colorName) => camelCase$1(colorName);
var colorToRgba = (color, opacity) => {
  return makeColor(color).setA(opacity).RGBA;
};
var getColorLightness = (color) => {
  const { R: R2, G: G2, B: B2 } = makeColor(color);
  return Math.sqrt(R2 * R2 * 0.241 + G2 * G2 * 0.691 + B2 * B2 * 0.068);
};
var getBoxShadowColor = (color, opacity = 0.4) => {
  return makeColor(color).setA(opacity).RGBA;
};
var getBoxShadowColorFromBg = (background, opacity = 0.4) => {
  return makeColor(background).setA(opacity).RGBA;
};
var getHoverColor = (color, opacity = 0.2) => {
  return makeColor(color).setA(opacity).RGBA;
};
var getFocusColor = (color, opacity = 0.3) => {
  return makeColor(color).setA(opacity).RGBA;
};
var shiftHSLAColor = (color, offset2) => {
  const result = makeColor(color);
  if (offset2.h) {
    result.setH(result.H + offset2.h);
  }
  if (offset2.s) {
    result.setS(result.S + offset2.s);
  }
  if (offset2.l) {
    result.setL(result.L + offset2.l);
  }
  if (offset2.a) {
    result.setA(result.A + offset2.a);
  }
  return result.HSLA;
};
var setHSLAColor = (color, newColor) => {
  const result = makeColor(color);
  if (newColor.h !== void 0) {
    result.setH(newColor.h);
  }
  if (newColor.s !== void 0) {
    result.setS(newColor.s);
  }
  if (newColor.l !== void 0) {
    result.setL(newColor.l);
  }
  if (newColor.a !== void 0) {
    result.setA(newColor.a);
  }
  return result.HSLA;
};
var shiftGradientColor = (color) => {
  const newColor = nt.toHSLA(color, false);
  if (newColor.s < 10) {
    return shiftHSLAColor(newColor, { h: 2, s: 5, l: 10 });
  }
  if (newColor.s < 30) {
    return shiftHSLAColor(newColor, { s: -14, l: 11 });
  }
  if (newColor.h >= 0 && newColor.h < 44 || newColor.h >= 285) {
    return shiftHSLAColor(newColor, { h: 11, s: 27, l: 8 });
  }
  if (newColor.h >= 44 && newColor.h < 85) {
    return shiftHSLAColor(newColor, { h: 3, l: 9 });
  }
  if (newColor.h >= 85 && newColor.h < 165) {
    return shiftHSLAColor(newColor, { h: 16, l: 14 });
  }
  if (newColor.h >= 165 && newColor.h < 285) {
    return shiftHSLAColor(newColor, { h: -15, s: 3, l: 2 });
  }
  throw new Error("This method should handle all colors. But it didn't for some reason.");
};
var getGradientBackground = (color) => {
  const colorLeft = shiftGradientColor(color);
  const colorRight = nt.toHSLA(color);
  return `linear-gradient(to right, ${colorLeft}, ${colorRight})`;
};
var getStateMaskGradientBackground = (color, maskColor, maskOpacity) => {
  const mask = colorToRgba(maskColor, maskOpacity);
  return `linear-gradient(0deg, ${mask}, ${mask}), ${color}`;
};
var isColor = (strColor) => {
  const cssColorRegex = /^#([\da-f]{3}){1,2}$|^#([\da-f]{4}){1,2}$|(rgb|hsl)a?\((\s*-?\d+%?\s*,){2}(\s*-?\d+%?\s*,?\s*\)?)(,\s*(0?\.\d+)?|1)?\)/;
  return cssColorRegex.test(strColor.toLocaleLowerCase());
};
var applyColors = (color1, color2) => {
  const c1 = makeColor(color1);
  const c2 = makeColor(color2);
  const weight = c2.A;
  if (weight === 1) {
    return c2.RGBA;
  }
  if (weight === 0) {
    return c1.RGBA;
  }
  c1.setR(Math.round(c1.R * (1 - weight) + c2.R * weight));
  c1.setG(Math.round(c1.G * (1 - weight) + c2.G * weight));
  c1.setB(Math.round(c1.B * (1 - weight) + c2.B * weight));
  return c1.RGBA;
};
var isColorTransparent = (color) => {
  if (!color) {
    return false;
  }
  if (color === "transparent") {
    return true;
  }
  return makeColor(color).A <= 0.1;
};

// node_modules/vuestic-ui/dist/es/src/composables/useColors.js
var useColorProps = {
  color: {
    type: String,
    default: ""
  }
};
var useColors = () => {
  const gc = useGlobalConfig();
  if (!gc) {
    throw new Error("useColors must be used in setup function or Vuestic GlobalConfigPlugin is not registered!");
  }
  const { globalConfig } = gc;
  const colors = useReactiveComputed({
    get: () => globalConfig.value.colors.presets[globalConfig.value.colors.currentPresetName],
    set: (v2) => {
      setColors(v2);
    }
  });
  const setColors = (colors2) => {
    globalConfig.value.colors.presets[globalConfig.value.colors.currentPresetName] = {
      ...globalConfig.value.colors.variables,
      ...colors2
    };
  };
  const getColors = () => {
    return colors;
  };
  const getColor = (prop, defaultColor, preferVariables) => {
    if (!defaultColor) {
      defaultColor = colors.primary;
    }
    if (prop === "transparent") {
      return "#ffffff00";
    }
    if (prop === "currentColor") {
      return prop;
    }
    if (prop == null ? void 0 : prop.startsWith("on")) {
      const colorName = prop.slice(2);
      if (colors[normalizeColorName(colorName)]) {
        return getColor(getTextColor(getColor(colorName)), void 0, preferVariables);
      }
    }
    if (!prop) {
      prop = getColor(defaultColor);
    }
    const colorValue = colors[prop] || colors[normalizeColorName(prop)];
    if (colorValue) {
      return preferVariables ? `var(${cssVariableName(prop)})` : colorValue;
    }
    if (isColor(prop)) {
      return prop;
    }
    if (preferVariables && isCSSVariable(prop)) {
      return prop;
    }
    warn(`'${prop}' is not a proper color! Use HEX or default color themes
      names (https://vuestic.dev/en/styles/colors#default-color-themes)`);
    return getColor(defaultColor);
  };
  const getComputedColor = (color) => {
    return computed({
      get() {
        return getColor(color);
      },
      set(v2) {
        setColors({ [color]: v2 });
      }
    });
  };
  const colorsToCSSVariable = (colors2, prefix2 = "va") => {
    return Object.keys(colors2).filter((key) => colors2[key] !== void 0).reduce((acc, colorName) => {
      acc[`--${prefix2}-${kebabCase$1(colorName)}`] = getColor(colors2[colorName], void 0, true);
      acc[`--${prefix2}-on-${kebabCase$1(colorName)}`] = getColor(getTextColor(getColor(colors2[colorName])), void 0, true);
      return acc;
    }, {});
  };
  const cache = useCache();
  const getColorLightnessFromCache = (color) => {
    if (typeof color !== "string") {
      return getColorLightness(color);
    }
    if (!cache.colorContrast[color]) {
      cache.colorContrast[color] = getColorLightness(color);
    }
    return cache.colorContrast[color];
  };
  const computedDarkColor = computed(() => {
    return getColorLightnessFromCache(getColor("textPrimary")) > 255 / 2 ? "textInverted" : "textPrimary";
  });
  const computedLightColor = computed(() => {
    return getColorLightnessFromCache(getColor("textPrimary")) > 255 / 2 ? "textPrimary" : "textInverted";
  });
  const getTextColor = (color, darkColor, lightColor) => {
    const onColorName = `on${capitalize(String(color))}`;
    if (colors[onColorName]) {
      return colors[onColorName];
    }
    darkColor = darkColor || computedDarkColor.value;
    lightColor = lightColor || computedLightColor.value;
    return getColorLightnessFromCache(color) > globalConfig.value.colors.threshold ? darkColor : lightColor;
  };
  const currentPresetName = computed({
    get: () => globalConfig.value.colors.currentPresetName,
    set: (v2) => {
      applyPreset(v2);
    }
  });
  const presets2 = computed(() => globalConfig.value.colors.presets);
  const applyPreset = (presetName) => {
    globalConfig.value.colors.currentPresetName = presetName;
    if (!globalConfig.value.colors.presets[presetName]) {
      return warn(`Preset ${presetName} does not exist`);
    }
  };
  return {
    colors,
    currentPresetName,
    presets: presets2,
    applyPreset,
    setColors,
    getColors,
    getColor,
    getComputedColor,
    getBoxShadowColor,
    getBoxShadowColorFromBg,
    getHoverColor,
    getFocusColor,
    getGradientBackground,
    getTextColor,
    shiftHSLAColor,
    setHSLAColor,
    colorsToCSSVariable,
    colorToRgba,
    getStateMaskGradientBackground
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useIsMounted.js
var useIsMounted = () => {
  const isMounted = ref(false);
  onMounted(() => {
    isMounted.value = true;
  });
  onBeforeUnmount(() => {
    isMounted.value = false;
  });
  return isMounted;
};

// node_modules/vuestic-ui/dist/es/src/composables/useBreakpoint.js
var helpersKeys = ["xs", "sm", "md", "lg", "xl", "smUp", "mdUp", "lgUp", "smDown", "mdDown", "lgDown"];
var defaultHelpers = helpersKeys.reduce((acc, key) => {
  acc[key] = false;
  return acc;
}, {});
var useBreakpoint = () => {
  const injected = inject(vaBreakpointSymbol, {});
  const isMounted = useIsMounted();
  const { globalConfig } = useGlobalConfig();
  const breakpointConfig = computed(() => {
    const breakpoint = globalConfig.value.breakpoint;
    if (!breakpoint) {
      warn("useBreakpoint: breakpointConfig is not defined!");
    }
    return breakpoint ?? {};
  });
  const defaultBreakpoint = computed(() => breakpointConfig.value.enabled ? {
    width: void 0,
    height: void 0,
    current: void 0,
    thresholds: breakpointConfig.value.thresholds,
    ...defaultHelpers
  } : {});
  return useReactiveComputed(() => isMounted.value ? injected : defaultBreakpoint.value);
};

// node_modules/vuestic-ui/dist/es/src/composables/useI18n.js
var useI18nConfig = () => {
  const { globalConfig, mergeGlobalConfig } = useGlobalConfig();
  const config = computed(() => globalConfig.value.i18n);
  const mergeIntoConfig = (newConfig) => {
    mergeGlobalConfig({
      i18n: {
        ...config.value,
        ...newConfig
      }
    });
  };
  return {
    config,
    mergeIntoConfig
  };
};

// node_modules/vuestic-ui/dist/es/src/services/icon/utils/regex.js
var isMatchRegex = (str, regex) => {
  return regex.test(str);
};
var regexGroupsValues = (str, regex) => {
  if (typeof regex !== "string" && regex.global) {
    return [...str.matchAll(regex)].map((g2) => g2.slice(1));
  }
  const match = str.match(regex) || [];
  if (!match) {
    return [];
  }
  if (match.length > 1) {
    return match.slice(1);
  }
  return match;
};

// node_modules/vuestic-ui/dist/es/src/services/icon/utils/dynamic-segment.js
var dynamicSegmentRegex = /{[^}]*}/g;
var dynamicSegmentStringToRegex = (template) => {
  return template.replace(dynamicSegmentRegex, "(.*)");
};
var dynamicSegmentsNames = (template) => {
  return (template.match(dynamicSegmentRegex) || []).map((g2) => g2.replace(/{|}/g, ""));
};
var dynamicSegmentsValues = (str, template) => {
  return regexGroupsValues(str, dynamicSegmentStringToRegex(template));
};
var dynamicSegments = (str, template) => {
  const params = dynamicSegmentsNames(template);
  const values = dynamicSegmentsValues(str, template);
  return params.reduce((acc, paramValue, i2) => ({ ...acc, [paramValue]: values[i2] }), {});
};
var strictMatch = (str, regex) => {
  return (str.match(regex) || [])[0] === str;
};
var isMatchDynamicSegments = (str, template) => {
  const templateRegex = dynamicSegmentStringToRegex(template);
  return strictMatch(str, new RegExp(templateRegex));
};

// node_modules/vuestic-ui/dist/es/src/services/icon/types.js
var isIconConfigurationString = (config) => {
  return typeof config.name === "string";
};
var isIconConfigurationRegex = (config) => {
  return config.name instanceof RegExp;
};

// node_modules/vuestic-ui/dist/es/src/services/icon/utils/get-icon-configuration.js
var isMatchConfiguration = (iconName, iconConfiguration) => {
  if (isIconConfigurationString(iconConfiguration)) {
    return isMatchDynamicSegments(iconName, iconConfiguration.name);
  }
  if (isIconConfigurationRegex(iconConfiguration)) {
    return isMatchRegex(iconName, iconConfiguration.name);
  }
  return false;
};
var resolveIconConfigurationString = (iconName, iconConfiguration) => {
  const args = dynamicSegments(iconName, iconConfiguration.name);
  return iconConfiguration.resolve && iconConfiguration.resolve(args);
};
var resolveIconConfigurationRegex = (iconName, iconConfig) => {
  if (iconConfig.name.global) {
    throw new Error(`Bad icon config with name ${iconConfig.name}. Please, don't use global regex as name.`);
  }
  const args = regexGroupsValues(iconName, iconConfig.name);
  return iconConfig.resolveFromRegex && iconConfig.resolveFromRegex(...args);
};
var resolveIconConfiguration = (iconName, iconConfiguration) => {
  if (isIconConfigurationString(iconConfiguration)) {
    return resolveIconConfigurationString(iconName, iconConfiguration);
  }
  if (isIconConfigurationRegex(iconConfiguration)) {
    return resolveIconConfigurationRegex(iconName, iconConfiguration);
  }
  throw Error("Unknown icon config");
};
var findMatchedIconConfiguration = (iconName, globalIconConfig, namesToIgnore = []) => {
  const matchedConfig = globalIconConfig.find((config) => {
    if (namesToIgnore.includes(config.name.toString())) {
      return false;
    }
    return isMatchConfiguration(iconName, config);
  });
  if (!matchedConfig) {
    throw new Error(`Can not find icon config from ${iconName}. Please provide default config.`);
  }
  return matchedConfig;
};
var findIconConfiguration = (iconName, globalIconConfig, namesToIgnore = []) => {
  if (!iconName) {
    return;
  }
  const matchedIconConfiguration = findMatchedIconConfiguration(iconName, globalIconConfig, namesToIgnore);
  const resolvedIconConfiguration = merge$1(resolveIconConfiguration(iconName, matchedIconConfiguration), matchedIconConfiguration);
  namesToIgnore = [...namesToIgnore, matchedIconConfiguration.name.toString()];
  return merge$1(
    findIconConfiguration(resolvedIconConfiguration.to, globalIconConfig, namesToIgnore),
    resolvedIconConfiguration
  );
};
var iconPropsFromIconConfiguration = (iconConfiguration) => {
  const junkKeys = ["name", "to", "resolve", "resolveFromRegex"];
  const configuration = iconConfiguration;
  junkKeys.forEach((key) => {
    delete configuration[key];
  });
  return configuration;
};
var getIconConfiguration = (name, iconConfig) => {
  const configuration = findIconConfiguration(name, iconConfig);
  if (configuration === void 0) {
    return {};
  }
  return iconPropsFromIconConfiguration(configuration);
};

// node_modules/vuestic-ui/dist/es/src/composables/useIcon.js
var useIcon = () => {
  const { globalConfig } = useGlobalConfig();
  return {
    getIcon: (name) => getIconConfiguration(name, globalConfig.value.icons)
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useTemplateRef.js
var useTemplateRef = (key) => {
  const vm = getCurrentInstance();
  const el = shallowRef();
  const updateEl = () => {
    var _a2;
    el.value = (_a2 = vm.proxy) == null ? void 0 : _a2.$refs[key];
  };
  onMounted(updateEl);
  onUpdated(updateEl);
  onBeforeUnmount(updateEl);
  return el;
};

// node_modules/vuestic-ui/dist/es/src/composables/useForm/useForm.js
var useForm = (ref2) => {
  const form = typeof ref2 === "string" ? useTemplateRef(ref2) : ref2;
  return {
    isValid: computed(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.isValid) || false;
    }),
    immediate: computed(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.immediate) || false;
    }),
    isLoading: computed(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.isLoading) || false;
    }),
    isDirty: computed(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.isDirty) || false;
    }),
    fields: computed(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.fields) ?? [];
    }),
    fieldsNamed: computed(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.fieldsNamed) ?? [];
    }),
    fieldNames: computed(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.fieldNames) ?? [];
    }),
    formData: computed(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.formData) ?? {};
    }),
    errorMessages: computed(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.errorMessages) || [];
    }),
    errorMessagesNamed: computed(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.errorMessagesNamed) || {};
    }),
    validate: () => {
      var _a2;
      return (_a2 = form.value) == null ? void 0 : _a2.validate();
    },
    reset: () => {
      var _a2;
      return (_a2 = form.value) == null ? void 0 : _a2.reset();
    },
    resetValidation: () => {
      var _a2;
      return (_a2 = form.value) == null ? void 0 : _a2.resetValidation();
    },
    focus: () => {
      var _a2;
      return (_a2 = form.value) == null ? void 0 : _a2.focus();
    },
    focusInvalidField: () => {
      var _a2;
      return (_a2 = form.value) == null ? void 0 : _a2.focusInvalidField();
    }
  };
};

// node_modules/vuestic-ui/dist/es/src/services/vue-plugin/utils/global-properties.js
var extractGlobalProperties = (app) => app.config.globalProperties;
var defineGlobalProperty = (app, key, v2) => {
  const globalProperties = extractGlobalProperties(app);
  globalProperties[key] = v2;
};
var getGlobalProperty = (app, key) => {
  return extractGlobalProperties(app)[key];
};

// node_modules/vuestic-ui/dist/es/src/services/global-config/plugin/index.js
var GlobalConfigPlugin = defineVuesticPlugin((config = {}) => ({
  install(app) {
    const globalConfig = createGlobalConfig(config);
    if (config == null ? void 0 : config.componentsAll) {
      console.warn("Global config -> `componentsAll` was moved to Global config -> components.all. Please replace this to make it work. More info here: https://github.com/epicmaxco/vuestic-ui/issues/1967");
    }
    app.provide(GLOBAL_CONFIG, globalConfig);
    defineGlobalProperty(app, "$vaConfig", globalConfig);
  }
}));

// node_modules/vuestic-ui/dist/es/src/utils/ssr.js
var isServer = () => typeof window === "undefined";
var isClient = () => !isServer();
var getWindow = () => typeof window === "undefined" ? void 0 : window;
var fakeGlobal = {};
var getGlobal = () => {
  if (isServer()) {
    if (typeof globalThis === "undefined") {
      return fakeGlobal;
    }
    return globalThis;
  } else {
    return window;
  }
};

// node_modules/vuestic-ui/dist/es/src/utils/uuid.js
var counter = 0;
var getRandomString = (stringLength = 4) => {
  return Math.random().toString(36).substring(2, stringLength + 2);
};
var generateUniqueId = () => {
  return `${getRandomString(8)}-${getRandomString(4)}-${getRandomString(4)}-${++counter}`;
};

// node_modules/vuestic-ui/dist/es/src/utils/dom.js
var addOrUpdateStyleElement = (id, getStyles) => {
  if (isServer()) {
    return;
  }
  let stylesElement = document.getElementById(id);
  if (stylesElement) {
    stylesElement.innerHTML = getStyles();
  } else {
    stylesElement = document.createElement("style");
    stylesElement.setAttribute("type", "text/css");
    stylesElement.setAttribute("id", id);
    stylesElement.innerHTML = getStyles();
    document.head.append(stylesElement);
  }
};

// node_modules/vuestic-ui/dist/es/src/services/color/plugin/create-color-config-plugin.js
var generateCSSVariable = (key, value) => {
  return `${cssVariableName(key)}: ${value};
`;
};
var createColorConfigPlugin = (app, config) => {
  const { colors: configColors, getTextColor, getColor, currentPresetName, applyPreset } = useColors();
  const renderCSSVariables = (colors = configColors) => {
    if (!colors) {
      return;
    }
    const colorNames = Object.keys(colors);
    const renderedColors = colorNames.map((key) => `${cssVariableName(key)}: ${colors[key]}`).join(";");
    const renderedOnColors = colorNames.map((key) => `${cssVariableName(`on-${key}`)}: ${getColor(getTextColor(colors[key]))}`).join(";");
    return `${renderedColors};${renderedOnColors}`;
  };
  const renderCSSVariablesStyleContent = (colors = configColors) => {
    const colorNames = Object.keys(colors);
    let result = ":root {\n";
    colorNames.forEach((key) => {
      result += generateCSSVariable(key, colors[key]);
    });
    colorNames.forEach((key) => {
      result += generateCSSVariable(`on-${key}`, getColor(getTextColor(colors[key])));
    });
    result += "}\n";
    return result;
  };
  const uniqueId2 = computed(generateUniqueId);
  const updateColors = (newValue) => {
    if (!newValue) {
      return;
    }
    if (isServer()) {
      return;
    }
    const styleContent = renderCSSVariablesStyleContent(newValue);
    addOrUpdateStyleElement(`va-color-variables-${uniqueId2.value}`, () => styleContent);
  };
  watch(configColors, (newValue) => {
    updateColors(newValue);
  }, { immediate: true, deep: true });
  return {
    colors: configColors,
    currentPresetName,
    renderCSSVariables,
    updateColors,
    renderCSSVariablesStyleContent
  };
};

// node_modules/vuestic-ui/dist/es/src/services/color/plugin/index.js
var ColorConfigPlugin = defineVuesticPlugin((config) => ({
  install(app) {
    defineGlobalProperty(app, "$vaColorConfig", createColorConfigPlugin());
  }
}));

// node_modules/vuestic-ui/dist/es/src/composables/useClientOnly.js
var useClientOnly = (cb) => {
  const isMounted = computed(isClient);
  const result = ref(null);
  watch(isMounted, () => {
    if (isMounted.value) {
      result.value = cb();
    }
  }, { immediate: true });
  return result;
};

// node_modules/vuestic-ui/dist/es/src/composables/useWindow.js
var useWindow = () => useClientOnly(() => window);

// node_modules/vuestic-ui/dist/es/src/utils/unwrapEl.js
var unwrapEl = (el) => {
  if (!el) {
    return;
  }
  if (typeof el !== "object") {
    return;
  }
  if (typeof el.$el !== "undefined") {
    return el.$el;
  }
  return el;
};

// node_modules/vuestic-ui/dist/es/src/utils/add-event-listener.js
var addEventListener = (target, ...args) => {
  if (!target || typeof target !== "object") {
    return;
  }
  if ("addEventListener" in target && typeof target.addEventListener === "function") {
    target.addEventListener(...args);
    return;
  }
  if ("parentElement" in target) {
    addEventListener(target.parentElement, ...args);
  }
};
var removeEventListener = (target, ...args) => {
  if (!target || typeof target !== "object") {
    return;
  }
  if ("removeEventListener" in target && typeof target.removeEventListener === "function") {
    target.removeEventListener(...args);
    return;
  }
  if ("parentElement" in target) {
    removeEventListener(target.parentElement, ...args);
  }
};

// node_modules/vuestic-ui/dist/es/src/composables/useEvent.js
var useEvent = (event, listener, target) => {
  const source = target && typeof target !== "boolean" ? target : useWindow();
  const capture = typeof target === "boolean" ? target : false;
  watch(source, (newValue, oldValue) => {
    if (!Array.isArray(event)) {
      addEventListener(unwrapEl(unref(newValue)), event, listener, capture);
      removeEventListener(unwrapEl(unref(oldValue)), event, listener, capture);
    } else {
      event.forEach((e2) => {
        addEventListener(unwrapEl(unref(newValue)), e2, listener, capture);
        removeEventListener(unwrapEl(unref(oldValue)), e2, listener, capture);
      });
    }
  }, { immediate: true });
};

// node_modules/vuestic-ui/dist/es/src/composables/useWindowSize.js
function useWindowSize() {
  const windowSizes = reactive({
    width: void 0,
    height: void 0
  });
  const setCurrentWindowSizes = () => {
    windowSizes.width = window == null ? void 0 : window.innerWidth;
    windowSizes.height = window == null ? void 0 : window.innerHeight;
  };
  const isMounted = computed(isClient);
  watch(isMounted, (newValue) => {
    if (!newValue) {
      return;
    }
    setCurrentWindowSizes();
  }, { immediate: true });
  useEvent("resize", setCurrentWindowSizes, true);
  return { windowSizes };
}

// node_modules/vuestic-ui/dist/es/src/composables/useDocument.js
var useDocument = () => useClientOnly(() => document);

// node_modules/vuestic-ui/dist/es/src/services/breakpoint/plugin/create-service.js
var createBreakpointConfigPlugin = (app) => {
  var _a2;
  const globalConfig = (_a2 = getGlobalProperty(app, "$vaConfig")) == null ? void 0 : _a2.globalConfig;
  if (!globalConfig) {
    warn("createBreakpointConfigPlugin: globalConfig is not defined!");
    return {};
  }
  const breakpointConfig = computed(() => {
    const breakpoint = globalConfig.value.breakpoint;
    if (!breakpoint) {
      warn("createBreakpointConfigPlugin: breakpointConfig is not defined!");
    }
    return breakpoint ?? {};
  });
  if (!breakpointConfig.value.enabled) {
    return {};
  }
  if (!breakpointConfig.value.thresholds || !Object.values(breakpointConfig.value.thresholds).length) {
    warn("createBreakpointConfigPlugin: there are no defined thresholds!");
    return {};
  }
  const { windowSizes } = useWindowSize();
  const isMounted = computed(isClient);
  const currentBreakpoint = computed(() => {
    if (!isMounted.value || !windowSizes.width) {
      return;
    }
    return Object.entries(breakpointConfig.value.thresholds).reduce((acc, [key, value]) => {
      if (windowSizes.width >= value) {
        acc = key;
      }
      return acc;
    }, "xs");
  });
  const screenClasses = computed(() => Object.keys(breakpointConfig.value.thresholds).reduce((acc, threshold) => {
    acc[threshold] = `va-screen-${threshold}`;
    return acc;
  }, {}));
  const generateHelpersMediaCss = () => {
    let result = "";
    Object.values(breakpointConfig.value.thresholds).forEach((thresholdValue, index) => {
      result += `@media screen and (min-width: ${thresholdValue}px) {`;
      result += `:root { --va-media-ratio: ${(index + 1) * 0.2} }`;
      result += "}\n";
    });
    return result;
  };
  const uniqueId2 = computed(generateUniqueId);
  addOrUpdateStyleElement(`va-helpers-media-${uniqueId2.value}`, generateHelpersMediaCss);
  const getDocument = useDocument();
  watch(currentBreakpoint, (newValue) => {
    if (!newValue || !breakpointConfig.value.bodyClass || !getDocument.value) {
      return;
    }
    getDocument.value.body.classList.forEach((className) => {
      if (Object.values(screenClasses.value).includes(className)) {
        getDocument.value.body.classList.remove(className);
      }
    });
    getDocument.value.body.classList.add(screenClasses.value[newValue]);
  }, { immediate: true });
  const breakpointHelpers = computed(() => {
    const isXs = currentBreakpoint.value === "xs";
    const isSm = currentBreakpoint.value === "sm";
    const isMd = currentBreakpoint.value === "md";
    const isLg = currentBreakpoint.value === "lg";
    const isXl = currentBreakpoint.value === "xl";
    return {
      xs: isXs,
      sm: isSm,
      md: isMd,
      lg: isLg,
      xl: isXl,
      smUp: isSm || isMd || isLg || isXl,
      mdUp: isMd || isLg || isXl,
      lgUp: isLg || isXl,
      smDown: isXs || isSm,
      mdDown: isXs || isSm || isMd,
      lgDown: isXs || isSm || isMd || isLg
    };
  });
  return useReactiveComputed(() => ({
    width: windowSizes.width,
    height: windowSizes.height,
    current: currentBreakpoint.value,
    thresholds: breakpointConfig.value.thresholds,
    ...breakpointHelpers.value
  }));
};

// node_modules/vuestic-ui/dist/es/src/services/breakpoint/plugin/index.js
var BreakpointConfigPlugin = defineVuesticPlugin(() => ({
  install(app) {
    const breakpointConfig = createBreakpointConfigPlugin(app);
    app.provide(vaBreakpointSymbol, breakpointConfig);
    defineGlobalProperty(app, "$vaBreakpoint", breakpointConfig);
  }
}));

// node_modules/vuestic-ui/dist/es/src/composables/useLocalConfig.js
var LocalConfigKey = "VaLocalConfig";
var CONFIGS_DEFAULT = computed(() => []);
function useLocalConfig() {
  return inject(LocalConfigKey, CONFIGS_DEFAULT);
}
function provideLocalConfig(config) {
  provide(LocalConfigKey, config);
}
function useLocalConfigProvider(config) {
  const prevChain = useLocalConfig();
  const nextChain = computed(() => [...prevChain.value, config.value]);
  provideLocalConfig(nextChain);
}

// node_modules/vuestic-ui/dist/es/src/services/component-config/utils/use-component-config-props.js
var useComponentConfigProps = (component, originalProps) => {
  const localConfig = useLocalConfig();
  const { globalConfig } = useGlobalConfig();
  const instancePreset = computed(() => originalProps.preset);
  const getPresetProps = (presetName) => {
    var _a2, _b, _c;
    return (_c = (_b = (_a2 = globalConfig.value.components) == null ? void 0 : _a2.presets) == null ? void 0 : _b[component.name]) == null ? void 0 : _c[presetName];
  };
  return computed(() => {
    var _a2, _b;
    const globalConfigProps = {
      ...(_a2 = globalConfig.value.components) == null ? void 0 : _a2.all,
      ...(_b = globalConfig.value.components) == null ? void 0 : _b[component.name]
    };
    const localConfigProps = localConfig.value.reduce(
      (finalConfig, config) => config[component.name] ? { ...finalConfig, ...config[component.name] } : finalConfig,
      {}
    );
    const presetName = instancePreset.value || localConfigProps.preset || globalConfigProps.preset;
    const presetProps = presetName && getPresetProps(presetName);
    return { ...globalConfigProps, ...localConfigProps, ...presetProps };
  });
};

// node_modules/vuestic-ui/dist/es/src/services/config-transport/createProxyComponent.js
var toCamelCase = (str) => str.replace(/-([a-z])/g, (g2) => g2[1].toUpperCase());
var findCamelCased = (obj, key) => {
  const found = Object.keys(obj).find((k2) => toCamelCase(k2) === key);
  return found && obj[found];
};
var createPropsWithCustomConfig = (instance, propsFromConfig) => {
  const instanceProps = instance.props;
  return new Proxy(instanceProps, {
    get: (target, key) => {
      var _a2;
      if (typeof key !== "string") {
        return target[key];
      }
      const incomingProps = instance.vnode.props || {};
      const originalProp = target[key];
      const propFromConfig = (_a2 = propsFromConfig.value) == null ? void 0 : _a2[key];
      const incomingProp = findCamelCased(incomingProps, key);
      if (incomingProp !== void 0) {
        return originalProp;
      }
      if (propFromConfig !== void 0) {
        return propFromConfig;
      }
      return originalProp;
    }
  });
};
var createAttrsWithCustomConfig = (instance, propsFromConfig) => {
  const instanceAttrs = instance.attrs;
  return new Proxy(instanceAttrs, {
    get: (target, key) => {
      var _a2;
      if (typeof key !== "string") {
        return target[key];
      }
      if (key === "class") {
        return normalizeClass([propsFromConfig.value.class, instanceAttrs.class]);
      }
      if (key === "style") {
        return normalizeStyle([propsFromConfig.value.style, instanceAttrs.style]);
      }
      const attrFromConfig = (_a2 = propsFromConfig.value) == null ? void 0 : _a2[key];
      if (attrFromConfig !== void 0) {
        return attrFromConfig;
      }
      return target[key];
    },
    ownKeys(target) {
      return [.../* @__PURE__ */ new Set([...Object.keys(instanceAttrs), ...Object.keys(propsFromConfig.value)])];
    },
    getOwnPropertyDescriptor(target, key) {
      return Reflect.getOwnPropertyDescriptor(propsFromConfig.value, key) ?? Reflect.getOwnPropertyDescriptor(instanceAttrs, key);
    }
  });
};
var createProxyComponent = (component) => {
  const customSetup = (originalProps, ctx) => {
    var _a2;
    const instance = getCurrentInstance();
    const propsFromConfig = useComponentConfigProps(component, originalProps);
    const attrsFromConfig = computed(() => {
      return omit$1(propsFromConfig.value, Object.keys(originalProps));
    });
    const props2 = createPropsWithCustomConfig(instance, propsFromConfig);
    const attrs = createAttrsWithCustomConfig(instance, attrsFromConfig);
    instance.props = props2;
    instance.attrs = attrs;
    return (_a2 = component.setup) == null ? void 0 : _a2.call(component, shallowReadonly(props2), {
      ...ctx,
      attrs
    });
  };
  return new Proxy(component, {
    get(target, key) {
      if (key === "setup") {
        return customSetup;
      }
      return target[key];
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/services/config-transport/withConfigTransport.js
var CLASS_COMPONENT_KEY = "__c";
var patchClassComponent = (component) => {
  component[CLASS_COMPONENT_KEY] = createProxyComponent(component[CLASS_COMPONENT_KEY]);
  return component;
};
var withConfigTransport = (component) => {
  if ("setup" in component) {
    return createProxyComponent(component);
  } else if (CLASS_COMPONENT_KEY in component) {
    return patchClassComponent(component);
  } else {
    component.setup = () => ({
      /* Fake setup function */
    });
    return createProxyComponent(component);
  }
};
var withConfigTransport$1 = withConfigTransport;

// node_modules/vuestic-ui/dist/es/src/composables/useSize.js
var sizesConfig = {
  defaultSize: 48,
  sizes: {
    small: 32,
    medium: 48,
    large: 64
  }
};
var fontSizesConfig = {
  defaultSize: 1,
  sizes: {
    small: 0.75,
    medium: 1,
    large: 1.25
  }
};
var useSizeProps = {
  size: {
    type: [String, Number],
    default: "",
    validator: (size3) => {
      return typeof size3 === "string" || typeof size3 === "number";
    }
  },
  sizesConfig: {
    type: Object,
    default: () => sizesConfig
  },
  fontSizesConfig: {
    type: Object,
    default: () => fontSizesConfig
  }
};
var fontRegex = /(?<fontSize>\d+)(?<extension>px|rem)/i;
var convertToRem = (px) => px / 16 - 0.5;
var useSize = (props2, componentName2 = ((_a2) => (_a2 = getCurrentInstance()) == null ? void 0 : _a2.type.name)()) => {
  const { getGlobalConfig } = useGlobalConfig();
  const sizesConfigGlobal = computed(() => {
    var _a2, _b;
    return componentName2 ? (_b = (_a2 = getGlobalConfig().components) == null ? void 0 : _a2[componentName2]) == null ? void 0 : _b.sizesConfig : void 0;
  });
  const sizeComputed = computed(() => {
    var _a2, _b, _c;
    const { defaultSize, sizes } = props2.sizesConfig;
    const defaultSizeGlobal = (_a2 = sizesConfigGlobal.value) == null ? void 0 : _a2.defaultSize;
    if (!props2.size) {
      return `${defaultSize || defaultSizeGlobal}px`;
    }
    if (typeof props2.size === "string") {
      const sizeFromGlobalConfig = (_c = (_b = sizesConfigGlobal.value) == null ? void 0 : _b.sizes) == null ? void 0 : _c[props2.size];
      const sizeFromProps = sizes[props2.size];
      if (sizeFromProps) {
        return `${sizeFromProps}px`;
      }
      if (sizeFromGlobalConfig) {
        return `${sizeFromGlobalConfig}px`;
      }
      return props2.size;
    }
    return `${props2.size}px`;
  });
  const fontSizeInRem = computed(() => {
    const { defaultSize, sizes } = props2.fontSizesConfig;
    if (!props2.size) {
      return defaultSize;
    }
    if (typeof props2.size === "string") {
      if (props2.size in sizes) {
        return sizes[props2.size];
      }
      const fontSizeParsed = props2.size.match(fontRegex);
      if (!fontSizeParsed || !fontSizeParsed.groups) {
        throw new Error("Size prop should be either valid string or number");
      }
      const { extension, fontSize } = fontSizeParsed.groups;
      return extension === "rem" ? +fontSize : convertToRem(+fontSize);
    }
    return convertToRem(props2.size);
  });
  const fontSizeComputed = computed(() => `${fontSizeInRem.value}rem`);
  return {
    sizeComputed,
    fontSizeComputed,
    fontSizeInRem
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useComponentPreset.js
var useComponentPresetProp = {
  preset: {
    type: String,
    default: void 0
  }
};

// node_modules/vuestic-ui/dist/es/src/components/va-icon/VaIcon.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaIcon.css";
var _sfc_main = defineComponent({
  name: "VaIcon",
  props: {
    ...useSizeProps,
    ...useComponentPresetProp,
    name: { type: String, default: "" },
    tag: { type: String },
    component: { type: Object },
    color: { type: String },
    rotation: { type: [String, Number] },
    spin: { type: [String, Boolean] },
    flip: {
      type: String,
      default: "off",
      validator: (value) => ["off", "horizontal", "vertical", "both"].includes(value)
    }
  },
  setup(props2, { attrs }) {
    const { getColor } = useColors();
    const { sizeComputed } = useSize(props2);
    const { getIcon } = useIcon();
    const iconConfig = computed(() => getIcon(props2.name));
    const computedTag = computed(() => props2.component || props2.tag || iconConfig.value.component || iconConfig.value.tag || "i");
    const computedAttrs = computed(() => ({ ...iconConfig.value.attrs, ...omit$1(attrs, ["class"]) }));
    const getSpinClass = (spin) => {
      if (spin === void 0 || spin === false) {
        return;
      }
      return spin === "counter-clockwise" ? "va-icon--spin-reverse" : "va-icon--spin";
    };
    const computedClass = computed(() => [
      iconConfig.value.class,
      getSpinClass(props2.spin ?? iconConfig.value.spin)
    ]);
    const transformStyle = computed(() => {
      const rotation = props2.rotation ? `rotate(${props2.rotation}deg)` : "";
      const flipY = props2.flip === "vertical" || props2.flip === "both" ? -1 : 1;
      const flipX = props2.flip === "horizontal" || props2.flip === "both" ? -1 : 1;
      const scale = props2.flip === "off" ? "" : `scale(${flipY}, ${flipX})`;
      return `${scale} ${rotation}`.trim();
    });
    const computedStyle = computed(() => ({
      transform: transformStyle.value,
      cursor: attrs.onClick ? "pointer" : null,
      color: props2.color ? getColor(props2.color, void 0, true) : iconConfig.value.color,
      fontSize: sizeComputed.value,
      height: sizeComputed.value,
      lineHeight: sizeComputed.value
    }));
    const tabindexComputed = computed(() => attrs.tabindex ?? -1);
    const ariaHiddenComputed = computed(() => attrs.role !== "button" || tabindexComputed.value < 0);
    return {
      iconConfig,
      computedTag,
      computedAttrs,
      computedClass,
      computedStyle,
      ariaHiddenComputed
    };
  }
});

// node_modules/vuestic-ui/dist/es/plugin-vue_export-helper.js
var _export_sfc = (sfc, props2) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props2) {
    target[key] = val;
  }
  return target;
};

// node_modules/vuestic-ui/dist/es/src/components/va-icon/VaIcon.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaIcon.css";
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.computedTag), mergeProps({
    class: ["va-icon", _ctx.computedClass],
    style: _ctx.computedStyle,
    "aria-hidden": _ctx.ariaHiddenComputed,
    notranslate: ""
  }, _ctx.computedAttrs), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default", {}, () => [
        _ctx.iconConfig.content ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createTextVNode(toDisplayString(_ctx.iconConfig.content), 1)
        ], 64)) : createCommentVNode("", true)
      ])
    ]),
    _: 3
  }, 16, ["class", "style", "aria-hidden"]);
}
var _VaIcon = _export_sfc(_sfc_main, [["render", _sfc_render]]);

// node_modules/vuestic-ui/dist/es/src/composables/useTimer.js
var useTimer = () => {
  let timer;
  const start = (...args) => {
    timer = window.setTimeout(...args);
    return timer;
  };
  const clear = () => timer && window.clearTimeout(timer);
  return {
    start,
    clear
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useTextColor.js
var useTextColor = (componentColor, isTransparent = false) => {
  const { props: props2 } = getCurrentInstance();
  const { getColor, getTextColor } = useColors();
  const textColorComputed = computed(() => {
    if (props2.textColor) {
      return getColor(props2.textColor);
    }
    const bg = componentColor ? unref(componentColor) : props2.color;
    if (!bg) {
      return "currentColor";
    }
    const componentColorHex = getColor(bg);
    if (isColorTransparent(componentColorHex)) {
      return "currentColor";
    }
    return unref(isTransparent) ? componentColorHex : getColor(getTextColor(componentColorHex));
  });
  return { textColorComputed };
};

// node_modules/vuestic-ui/dist/es/src/composables/useTranslation.js
var applyI18nTemplate = (key, values) => {
  if (!values) {
    return key;
  }
  Object.keys(values).forEach((valueKey) => {
    key = key.replace(`{${valueKey}}`, String(values[valueKey]));
  });
  return key;
};
var useTranslation = () => {
  const { globalConfig } = useGlobalConfig();
  const config = computed(() => globalConfig.value.i18n);
  return {
    /** Translate prop. Translate only if key has `$t:` prefix */
    tp: (key, values) => {
      if (!key) {
        return "";
      }
      if (key.startsWith("$t:")) {
        key = config.value[key.slice(3)] || key;
      }
      return applyI18nTemplate(key, values) || key;
    },
    t(key, values) {
      const translated = config.value[key];
      if (!translated) {
        warn(`${key} not found in VuesticUI i18n config`);
        return key;
      }
      return applyI18nTemplate(translated, values) || key;
    }
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-toast/VaToast.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaToast.css";
var VaToastRenderer = defineComponent({
  name: "VaToastRenderer",
  props: {
    render: { type: Function, required: true }
  },
  setup: (props2) => () => props2.render()
});
var _sfc_main2 = defineComponent({
  name: "VaToast",
  components: { VaIcon: _VaIcon, VaToastRenderer },
  emits: ["on-click", "on-close"],
  props: {
    ...useComponentPresetProp,
    title: { type: String, default: "" },
    offsetY: { type: Number, default: 16 },
    offsetX: { type: Number, default: 16 },
    message: { type: [String, Function], default: "" },
    dangerouslyUseHtmlString: { type: Boolean, default: false },
    icon: { type: String, default: "close" },
    customClass: { type: String, default: "" },
    duration: { type: Number, default: 5e3 },
    color: { type: String, default: "" },
    closeable: { type: Boolean, default: true },
    onClose: { type: Function },
    onClick: { type: Function },
    multiLine: { type: Boolean, default: false },
    position: {
      type: String,
      default: "top-right",
      validator: (value) => ["top-right", "top-left", "bottom-right", "bottom-left"].includes(value)
    },
    render: { type: Function },
    ariaCloseLabel: { type: String, default: "$t:close" },
    role: { type: String, default: void 0 },
    inline: { type: Boolean, default: false }
  },
  setup(props2, { emit }) {
    const rootElement = shallowRef();
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor(computed(() => getColor(props2.color)));
    const visible = ref(false);
    const positionX = computed(() => {
      return props2.position.includes("right") ? "right" : "left";
    });
    const positionY = computed(() => {
      return props2.position.includes("top") ? "top" : "bottom";
    });
    const toastClasses = computed(() => [
      props2.customClass,
      props2.multiLine ? "va-toast--multiline" : "",
      props2.inline ? "va-toast--inline" : ""
    ]);
    const toastStyles = computed(() => ({
      [positionY.value]: `${props2.offsetY}px`,
      [positionX.value]: `${props2.offsetX}px`,
      backgroundColor: getColor(props2.color),
      color: textColorComputed.value
    }));
    const computedAriaLive = computed(() => {
      if (props2.role === "status") {
        return "polite";
      } else {
        return "assertive";
      }
    });
    const computedMessage = computed(() => typeof props2.message === "function" ? props2.message() : props2.message);
    const destroyElement = () => {
      var _a2, _b;
      (_a2 = rootElement.value) == null ? void 0 : _a2.removeEventListener("transitionend", destroyElement);
      (_b = rootElement.value) == null ? void 0 : _b.remove();
    };
    const onToastClick = () => {
      if (typeof props2.onClick === "function") {
        props2.onClick();
      } else {
        emit("on-click");
      }
    };
    const onToastClose = () => {
      var _a2;
      visible.value = false;
      (_a2 = rootElement.value) == null ? void 0 : _a2.addEventListener("transitionend", destroyElement);
      if (typeof props2.onClose === "function") {
        props2.onClose();
      } else {
        emit("on-close");
      }
    };
    const timer = useTimer();
    const clearTimer = timer.clear;
    const startTimer = () => {
      if (props2.duration > 0) {
        timer.start(() => visible.value && onToastClose(), props2.duration);
      }
    };
    onMounted(() => {
      visible.value = true;
      startTimer();
    });
    return {
      ...useTranslation(),
      visible,
      toastClasses,
      toastStyles,
      computedAriaLive,
      computedMessage,
      onToastClick,
      onToastClose,
      startTimer,
      clearTimer
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-toast/VaToast.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaToast.css";
var _hoisted_1 = ["role", "aria-live"];
var _hoisted_2 = { class: "va-toast__group" };
var _hoisted_3 = ["textContent"];
var _hoisted_4 = { class: "va-toast__content" };
var _hoisted_5 = ["innerHTML"];
var _hoisted_6 = ["textContent"];
var _hoisted_7 = {
  key: 1,
  class: "va-toast__content"
};
function _sfc_render2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaToastRenderer = resolveComponent("VaToastRenderer");
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createBlock(Transition, { name: "va-toast-fade" }, {
    default: withCtx(() => [
      withDirectives(createBaseVNode("div", {
        ref: "rootElement",
        role: _ctx.$props.role ?? _ctx.$props.closeable ? "alertdialog" : "alert",
        "aria-live": _ctx.computedAriaLive,
        "aria-atomic": "true",
        class: normalizeClass(["va-toast", _ctx.toastClasses]),
        style: normalizeStyle(_ctx.toastStyles),
        onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.clearTimer && _ctx.clearTimer(...args)),
        onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.startTimer && _ctx.startTimer(...args)),
        onClick: _cache[2] || (_cache[2] = (...args) => _ctx.onToastClick && _ctx.onToastClick(...args))
      }, [
        createBaseVNode("div", _hoisted_2, [
          _ctx.$props.title ? (openBlock(), createElementBlock("h2", {
            key: 0,
            class: "va-toast__title",
            textContent: toDisplayString(_ctx.$props.title)
          }, null, 8, _hoisted_3)) : createCommentVNode("", true),
          withDirectives(createBaseVNode("div", _hoisted_4, [
            _ctx.$props.dangerouslyUseHtmlString ? (openBlock(), createElementBlock("div", {
              key: 0,
              innerHTML: _ctx.computedMessage
            }, null, 8, _hoisted_5)) : (openBlock(), createElementBlock("p", {
              key: 1,
              textContent: toDisplayString(_ctx.computedMessage)
            }, null, 8, _hoisted_6))
          ], 512), [
            [vShow, _ctx.$props.message]
          ]),
          _ctx.$props.render ? (openBlock(), createElementBlock("div", _hoisted_7, [
            createVNode(_component_VaToastRenderer, {
              render: _ctx.$props.render
            }, null, 8, ["render"])
          ])) : createCommentVNode("", true),
          _ctx.$props.closeable ? (openBlock(), createBlock(_component_va_icon, {
            key: 2,
            class: "va-toast__close-icon",
            role: "button",
            "aria-label": _ctx.tp(_ctx.$props.ariaCloseLabel),
            tabindex: "0",
            size: "1rem",
            name: _ctx.$props.icon,
            onClick: withModifiers(_ctx.onToastClose, ["stop"]),
            onKeydown: withKeys(withModifiers(_ctx.onToastClose, ["stop"]), ["enter"])
          }, null, 8, ["aria-label", "name", "onClick", "onKeydown"])) : createCommentVNode("", true)
        ])
      ], 46, _hoisted_1), [
        [vShow, _ctx.visible]
      ])
    ]),
    _: 1
  });
}
var _VaToast = _export_sfc(_sfc_main2, [["render", _sfc_render2]]);

// node_modules/vuestic-ui/dist/es/src/components/va-toast/index.js
var VaToast = withConfigTransport$1(_VaToast);

// node_modules/vuestic-ui/dist/es/src/components/va-toast/toast.js
var GAP = 5;
var seed = 1;
getGlobal().vaToastInstances = [];
var getTranslateValue = (item, position) => {
  if (item.el) {
    const direction = position.includes("bottom") ? -1 : 1;
    return (item.el.offsetHeight + GAP) * direction;
  }
  return 0;
};
var getNewTranslateValue = (transformY, redundantHeight, position) => {
  const direction = position.includes("bottom") ? -1 : 1;
  return parseInt(transformY, 10) - (redundantHeight + GAP) * direction;
};
var getNodeProps = (vNode) => {
  var _a2;
  return ((_a2 = vNode.component) == null ? void 0 : _a2.props) || {};
};
var closeNotification = (targetInstance, destroyElementFn) => {
  var _a2;
  if (!targetInstance) {
    return;
  }
  if (!getGlobal().vaToastInstances.length) {
    seed = 1;
    return;
  }
  const targetInstanceIndex = getGlobal().vaToastInstances.findIndex((instance) => instance === targetInstance);
  if (targetInstanceIndex < 0) {
    return;
  }
  const nodeProps = getNodeProps(targetInstance);
  const {
    offsetX: targetOffsetX,
    offsetY: targetOffsetY,
    position: targetPosition
  } = nodeProps;
  const redundantHeight = (_a2 = targetInstance.el) == null ? void 0 : _a2.offsetHeight;
  destroyElementFn();
  getGlobal().vaToastInstances = getGlobal().vaToastInstances.reduce((acc, instance, index) => {
    if (instance === targetInstance) {
      return acc;
    }
    if (instance.component) {
      const { offsetX, offsetY, position } = getNodeProps(instance);
      const isNextInstance = index > targetInstanceIndex && targetOffsetX === offsetX && targetOffsetY === offsetY && targetPosition === position;
      if (isNextInstance && instance.el && redundantHeight) {
        const [_2, transformY] = instance.el.style.transform.match(/[\d-]+(?=px)/g);
        const transformYNew = getNewTranslateValue(transformY, redundantHeight, position);
        instance.el.style.transform = `translate(0, ${transformYNew}px)`;
      }
    }
    return [...acc, instance];
  }, []);
  if (!getGlobal().vaToastInstances.length) {
    seed = 1;
  }
};
var destroy = (el, node) => {
  if (el) {
    render(null, el);
    el.remove();
  }
  el = null;
};
var mount = (component, {
  props: props2,
  children,
  element,
  appContext
} = {}) => {
  let el = element;
  let vNode;
  const onClose = () => {
    closeNotification(vNode, () => destroy(el));
    if (props2 == null ? void 0 : props2.onClose) {
      props2.onClose();
    }
  };
  vNode = createVNode(component, { ...props2, onClose }, children);
  if (appContext) {
    vNode.appContext = appContext;
  }
  if (el) {
    render(vNode, el);
  } else if (typeof document !== "undefined") {
    render(vNode, el = document.createElement("div"));
  }
  return { vNode, el };
};
var closeAllNotifications = (appContext) => {
  if (!getGlobal().vaToastInstances.length) {
    seed = 1;
    return;
  }
  getGlobal().vaToastInstances.forEach((instance) => {
    if (appContext && instance.appContext !== appContext) {
      return;
    }
    getNodeProps(instance).onClose();
  });
};
var closeById = (id) => {
  const targetInstance = getGlobal().vaToastInstances.find((instance) => {
    var _a2;
    return ((_a2 = instance.el) == null ? void 0 : _a2.id) === id;
  });
  if (targetInstance) {
    const nodeProps = getNodeProps(targetInstance);
    nodeProps.onClose();
  }
};
var getToastOptions = (options) => {
  if (typeof options === "string") {
    return {
      message: options
    };
  }
  return options;
};
var createToastInstance = (customProps, appContext) => {
  const { vNode, el } = mount(VaToast, { appContext, props: getToastOptions(customProps) });
  const nodeProps = getNodeProps(vNode);
  if (el && vNode.el && nodeProps) {
    document.body.appendChild(el.childNodes[0]);
    const { offsetX, offsetY, position } = nodeProps;
    vNode.el.style.display = "flex";
    vNode.el.id = "notification_" + seed;
    let transformY = 0;
    getGlobal().vaToastInstances.filter((item) => {
      const {
        offsetX: itemOffsetX,
        offsetY: itemOffsetY,
        position: itemPosition
      } = getNodeProps(item);
      return itemOffsetX === offsetX && itemOffsetY === offsetY && position === itemPosition;
    }).forEach((item) => {
      transformY += getTranslateValue(item, position);
    });
    vNode.el.style.transform = `translate(0, ${transformY}px)`;
    seed += 1;
    getGlobal().vaToastInstances.push(vNode);
    return vNode.el.id;
  }
  return null;
};

// node_modules/vuestic-ui/dist/es/src/components/va-toast/plugin/index.js
var createVaToastPlugin = (app) => ({
  /** Returns toast instance id */
  init(options) {
    return createToastInstance(options, app == null ? void 0 : app._context);
  },
  close(id) {
    closeById(id);
  },
  closeAll(allApps = false) {
    closeAllNotifications(allApps ? void 0 : app == null ? void 0 : app._context);
  }
});
var VaToastPlugin = defineVuesticPlugin(() => ({
  install(app) {
    defineGlobalProperty(app, "$vaToast", createVaToastPlugin(app));
  }
}));

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/plugin/index.js
var vaDropdownPlugin = {
  closeDropdown() {
    let vm = this;
    while (vm = vm.$parent) {
      const name = vm.$options.name;
      if (name === "VaDropdown") {
        vm.hide();
        break;
      }
    }
  }
};
var VaDropdownPlugin = defineVuesticPlugin(() => ({
  install(app) {
    defineGlobalProperty(app, "$closeDropdown", vaDropdownPlugin.closeDropdown);
    defineGlobalProperty(app, "$vaDropdown", vaDropdownPlugin);
  }
}));

// node_modules/vuestic-ui/dist/es/src/components/va-button/hooks/useButtonBackground.js
var useButtonBackground = (colorComputed, isPressed, isHovered) => {
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("`useButtonBackground` hook must be used only inside of setup function!");
  }
  const props2 = instance.props;
  const { getColor, getGradientBackground: getGradientBackground2 } = useColors();
  const backgroundColor = computed(() => {
    if (props2.plain) {
      return "transparent";
    }
    return props2.gradient ? getGradientBackground2(colorComputed.value) : colorComputed.value;
  });
  const hoveredBgState = computed(() => !props2.plain && isHovered.value);
  const pressedBgState = computed(() => !props2.plain && isPressed.value);
  const backgroundColorOpacity = computed(() => {
    if (pressedBgState.value && props2.pressedBehavior === "opacity") {
      return props2.pressedOpacity;
    }
    if (hoveredBgState.value && props2.hoverBehavior === "opacity") {
      return props2.hoverOpacity;
    }
    return props2.backgroundOpacity;
  });
  const hoveredMaskState = computed(() => hoveredBgState.value && props2.hoverBehavior === "mask");
  const pressedMaskState = computed(() => pressedBgState.value && props2.pressedBehavior === "mask");
  const backgroundMaskOpacity = computed(() => {
    if (pressedMaskState.value) {
      return props2.pressedOpacity;
    }
    if (hoveredMaskState.value) {
      return props2.hoverOpacity;
    }
    return 0;
  });
  const backgroundMaskColor = computed(() => {
    if (pressedMaskState.value) {
      return getColor(props2.pressedMaskColor);
    }
    if (hoveredMaskState.value) {
      return getColor(props2.hoverMaskColor);
    }
    return "transparent";
  });
  return {
    backgroundColor,
    backgroundColorOpacity,
    backgroundMaskOpacity,
    backgroundMaskColor
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useRouterLink.js
var useRouterLinkProps = {
  tag: { type: String, default: "span" },
  to: { type: [String, Object], default: void 0 },
  replace: { type: Boolean, default: void 0 },
  append: { type: Boolean, default: void 0 },
  exact: { type: Boolean, default: void 0 },
  activeClass: { type: String, default: void 0 },
  exactActiveClass: { type: String, default: void 0 },
  href: { type: String, default: void 0 },
  target: { type: String, default: void 0 },
  disabled: { type: Boolean, default: false }
};
var useRouterLink = (props2) => {
  var _a2;
  const currentInstance = getCurrentInstance();
  const globalProperties = computed(() => currentInstance == null ? void 0 : currentInstance.appContext.config.globalProperties);
  const vueRouter = computed(() => {
    var _a22;
    return (_a22 = globalProperties.value) == null ? void 0 : _a22.$router;
  });
  const vueRoute = computed(() => {
    var _a22;
    return (_a22 = globalProperties.value) == null ? void 0 : _a22.$route;
  });
  const { getGlobalConfig } = useGlobalConfig();
  const routerComponent = getGlobalConfig().routerComponent;
  const isNuxt = !!((_a2 = globalProperties.value) == null ? void 0 : _a2.$nuxt);
  const isNuxtLink = computed(() => !!(!props2.disabled && props2.to && isNuxt && routerComponent));
  const tagComputed = computed(() => {
    if (props2.disabled) {
      return props2.tag;
    }
    if (props2.href && !props2.to) {
      return "a";
    }
    if (isNuxtLink.value) {
      return routerComponent;
    }
    if (props2.to) {
      return "router-link";
    }
    return props2.tag || "div";
  });
  const isLinkTag = computed(() => isNuxtLink.value || ["a", "router-link"].includes(tagComputed.value));
  const linkAttributesComputed = computed(() => {
    if (!isLinkTag.value) {
      return {};
    }
    return tagComputed.value === "a" ? {
      target: props2.target,
      href: hrefComputed.value
    } : {
      target: props2.target,
      to: props2.to,
      replace: props2.replace,
      append: props2.append,
      activeClass: props2.activeClass,
      exact: props2.exact,
      exactActiveClass: props2.exactActiveClass
    };
  });
  const isActiveRouterLink = computed(() => {
    if (!vueRouter.value || !props2.to) {
      return false;
    }
    const to = vueRouter.value.resolve(props2.to).href;
    const currentHref = vueRouter.value.currentRoute.value.path;
    return to.replace("#", "") === currentHref.replace("#", "");
  });
  const hrefComputed = computed(() => {
    var _a22;
    return props2.href || (props2.to ? (_a22 = vueRouter.value) == null ? void 0 : _a22.resolve(props2.to, vueRoute.value).href : void 0);
  });
  return {
    isLinkTag,
    tagComputed,
    hrefComputed,
    isActiveRouterLink,
    linkAttributesComputed
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-button/hooks/useButtonAttributes.js
var useButtonAttributes = (props2) => {
  const { linkAttributesComputed, isLinkTag } = useRouterLink(props2);
  const typeComputed = computed(() => isLinkTag.value ? void 0 : props2.type);
  const buttonAttributesComputed = computed(() => {
    const disabledAttributes = {
      "aria-disabled": !!props2.disabled,
      disabled: !!props2.disabled
    };
    if (isLinkTag.value) {
      return disabledAttributes;
    }
    return {
      type: typeComputed.value,
      tabindex: props2.loading || props2.disabled ? -1 : 0,
      ...disabledAttributes
    };
  });
  return computed(() => ({ ...linkAttributesComputed.value, ...buttonAttributesComputed.value }));
};

// node_modules/vuestic-ui/dist/es/src/components/va-button/hooks/useButtonTextColor.js
var getOpacity = (opacity) => {
  var _a2, _b, _c;
  if (isServer()) {
    return opacity;
  }
  if (opacity > 0) {
    const userAgent = (_a2 = window == null ? void 0 : window.navigator) == null ? void 0 : _a2.userAgent;
    const isSafari = userAgent && /^((?!chrome|android).)*safari/i.test((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.userAgent);
    const isLatestSafari = userAgent && /(version.)15|16/i.test((_c = window == null ? void 0 : window.navigator) == null ? void 0 : _c.userAgent);
    if (isSafari && !isLatestSafari) {
      return opacity < 1 ? 1 - opacity : opacity;
    }
  }
  return opacity;
};
var useButtonTextColor = (textColorComputed, colorComputed, isPressed, isHovered) => {
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("`useButtonTextColor` hook must be used only inside of setup function!");
  }
  const props2 = instance.props;
  const { getColor, colorToRgba: colorToRgba2, getStateMaskGradientBackground: getStateMaskGradientBackground2 } = useColors();
  const plainColorStyles = computed(() => ({
    background: "transparent",
    color: textColorComputed.value,
    "-webkit-background-clip": "text",
    "background-clip": "text",
    opacity: getPlainTextOpacity.value
  }));
  const getStateColor = (maskColor, stateOpacity, stateBehavior) => {
    const maskStateColor = getColor(maskColor);
    let stateStyles;
    if (stateBehavior === "opacity") {
      stateStyles = { color: colorToRgba2(textColorComputed.value, stateOpacity) };
    } else {
      stateStyles = {
        background: getStateMaskGradientBackground2(colorComputed.value, maskStateColor, stateOpacity),
        color: stateOpacity < 1 ? colorToRgba2(textColorComputed.value, getOpacity(stateOpacity)) : maskStateColor
      };
    }
    return { ...plainColorStyles.value, ...stateStyles };
  };
  const hoverTextColorComputed = computed(() => {
    return getStateColor(props2.hoverMaskColor, props2.hoverOpacity, props2.hoverBehavior);
  });
  const pressedTextColorComputed = computed(() => {
    return getStateColor(props2.pressedMaskColor, props2.pressedOpacity, props2.pressedBehavior);
  });
  const getPlainTextOpacity = computed(() => {
    if (props2.disabled) {
      return void 0;
    }
    if (props2.textOpacity === 1 || isHovered.value && !isPressed.value) {
      return 1;
    }
    return isPressed.value ? 0.9 : props2.textOpacity;
  });
  return computed(() => {
    const defaultColorStyles = {
      color: textColorComputed.value,
      background: "transparent"
    };
    props2.plain && Object.assign(defaultColorStyles, plainColorStyles.value, { background: textColorComputed.value });
    if (!props2.plain) {
      return defaultColorStyles;
    }
    if (isPressed.value) {
      return pressedTextColorComputed.value;
    }
    if (isHovered.value) {
      return hoverTextColorComputed.value;
    }
    return defaultColorStyles;
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-icon/index.js
var VaIcon = withConfigTransport$1(_VaIcon);

// node_modules/vuestic-ui/dist/es/src/components/va-progress-circle/VaProgressCircle.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaProgressCircle.css";
var _sfc_main3 = defineComponent({
  name: "VaProgressCircle",
  props: {
    ...useSizeProps,
    ...useComponentPresetProp,
    modelValue: { type: Number, default: 0 },
    indeterminate: { type: Boolean, default: false },
    thickness: { type: Number, default: 0.06 },
    color: { type: String, default: "primary" },
    ariaLabel: { type: String, default: "$t:progressState" }
  },
  setup(props2) {
    const { getColor } = useColors();
    const { sizeComputed } = useSize(props2);
    const cappedThickness = computed(() => clamp$1(props2.thickness, 0, 1) / 2 * 100);
    const radius = computed(() => 20 - 20 * cappedThickness.value / 100);
    const dasharray = computed(() => 2 * Math.PI * radius.value);
    const dashoffset = computed(() => dasharray.value * (1 - clamp$1(props2.modelValue, 0, 100) / 100));
    const colorComputed = computed(() => getColor(props2.color, void 0, true));
    const { tp } = useTranslation();
    return {
      infoStyle: computed(() => ({ color: colorComputed.value })),
      rootStyle: computed(() => ({
        width: sizeComputed.value,
        height: sizeComputed.value
      })),
      rootClass: computed(() => ({
        "va-progress-circle--indeterminate": props2.indeterminate
      })),
      ariaAttributesComputed: computed(() => ({
        role: "progressbar",
        "aria-label": tp(props2.ariaLabel),
        "aria-valuenow": !props2.indeterminate ? props2.modelValue : void 0
      })),
      colorComputed,
      radius,
      dasharray,
      dashoffset,
      cappedThickness
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-progress-circle/VaProgressCircle.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaProgressCircle.css";
var _hoisted_12 = {
  class: "va-progress-circle__wrapper",
  viewBox: "0 0 40 40"
};
var _hoisted_22 = ["r", "stroke", "stroke-width", "stroke-dasharray", "stroke-dashoffset"];
function _sfc_render3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    class: ["va-progress-circle", _ctx.rootClass],
    style: _ctx.rootStyle
  }, _ctx.ariaAttributesComputed), [
    (openBlock(), createElementBlock("svg", _hoisted_12, [
      createBaseVNode("circle", {
        class: "va-progress-circle__overlay",
        cx: "50%",
        cy: "50%",
        r: _ctx.radius,
        fill: "none",
        stroke: _ctx.colorComputed,
        "stroke-width": _ctx.cappedThickness + "%",
        "stroke-dasharray": _ctx.dasharray,
        "stroke-dashoffset": _ctx.dashoffset
      }, null, 8, _hoisted_22)
    ])),
    _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
      key: 0,
      style: normalizeStyle(_ctx.infoStyle),
      class: "va-progress-circle__info"
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 4)) : createCommentVNode("", true)
  ], 16);
}
var _VaProgressCircle = _export_sfc(_sfc_main3, [["render", _sfc_render3]]);

// node_modules/vuestic-ui/dist/es/src/components/va-progress-circle/index.js
var VaProgressCircle = withConfigTransport$1(_VaProgressCircle);

// node_modules/vuestic-ui/dist/es/src/composables/useHoverStyle.js
var useHoverStyleProps = {
  hoverBehavior: {
    type: String,
    default: "mask",
    validator: (value) => ["opacity", "mask"].includes(value)
  },
  hoverOpacity: { type: Number, default: 0.15 },
  hoverMaskColor: { type: String, default: "textInverted" }
};

// node_modules/vuestic-ui/dist/es/src/composables/usePressedStyle.js
var usePressedStyleProps = {
  pressedBehavior: {
    type: String,
    default: "mask",
    validator: (value) => ["opacity", "mask"].includes(value)
  },
  pressedOpacity: { type: Number, default: 0.13 },
  pressedMaskColor: { type: String, default: "textPrimary" }
};

// node_modules/vuestic-ui/dist/es/src/composables/useLoading.js
var useLoadingProps = {
  loading: { type: Boolean, default: false }
};

// node_modules/vuestic-ui/dist/es/src/utils/focus.js
var isHTMLElement = (el) => {
  return el instanceof HTMLElement;
};
var focusElement = (el) => {
  if (!el || !isHTMLElement(el)) {
    return;
  }
  el.focus();
  el.dispatchEvent(new FocusEvent("focus", { bubbles: true }));
};
var blurElement = (el) => {
  if (!el || !isHTMLElement(el)) {
    return;
  }
  el.blur();
  el.dispatchEvent(new Event("blur", { bubbles: true }));
};
var focusFirstFocusableChild = (el) => {
  if (el.tabIndex !== -1) {
    focusElement(el);
    return;
  }
  const focusable = el.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
  if (focusable) {
    focusElement(focusable);
  }
};

// node_modules/vuestic-ui/dist/es/src/composables/useCaptureEvent.js
var useCaptureEvent = (event, cb, options = {}) => {
  onMounted(() => window.addEventListener(event, cb, { capture: true, ...options }));
  onBeforeUnmount(() => window.removeEventListener(event, cb, { capture: true, ...options }));
};

// node_modules/vuestic-ui/dist/es/src/composables/useActiveElement.js
var useActiveElement = () => {
  const activeEl = shallowRef();
  const updateActiveElement = () => {
    activeEl.value = document.activeElement;
  };
  onMounted(updateActiveElement);
  useCaptureEvent("focus", updateActiveElement);
  useCaptureEvent("blur", updateActiveElement);
  return activeEl;
};

// node_modules/vuestic-ui/dist/es/src/composables/useFocus.js
var useFocusEmits = ["focus", "blur"];
function useFocus(el, emit) {
  const activeElement = useActiveElement();
  const isFocused = computed({
    get: () => {
      if (isNil$1(activeElement.value)) {
        return false;
      }
      if (isNil$1(el == null ? void 0 : el.value)) {
        return false;
      }
      return activeElement.value === (el == null ? void 0 : el.value);
    },
    set: (value) => {
      if (value) {
        focus();
      } else {
        blur();
      }
    }
  });
  const onFocus = (e2) => {
    emit == null ? void 0 : emit("focus", e2);
  };
  const onBlur = (e2) => {
    emit == null ? void 0 : emit("blur", e2);
  };
  const focus = () => {
    if (!(el == null ? void 0 : el.value)) {
      return;
    }
    focusElement(unwrapEl(el == null ? void 0 : el.value));
  };
  const blur = () => {
    if (!(el == null ? void 0 : el.value)) {
      return;
    }
    blurElement(unwrapEl(el == null ? void 0 : el.value));
  };
  useEvent("focus", onFocus, el);
  useEvent("blur", onBlur, el);
  return {
    isFocused,
    onFocus,
    onBlur,
    focus,
    blur
  };
}

// node_modules/vuestic-ui/dist/es/src/composables/useHTMLElement.js
var useHTMLElement = (key) => {
  if (isRef(key)) {
    return computed({
      get() {
        return unwrapEl(key.value);
      },
      set(value) {
        key.value = value;
      }
    });
  }
  if (key) {
    const el2 = useTemplateRef(key);
    return computed({
      get() {
        return unwrapEl(el2.value);
      },
      set(value) {
        el2.value = value;
      }
    });
  }
  const el = shallowRef();
  return computed({
    set(value) {
      el.value = unwrapEl(value);
    },
    get() {
      return el.value;
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/composables/useHover.js
function useHover(el, disabled) {
  const isHovered = ref(false);
  const onMouseEnter = () => {
    isHovered.value = true;
  };
  const onMouseLeave = () => {
    isHovered.value = false;
  };
  disabled && watch(disabled, (v2) => {
    if (v2) {
      isHovered.value = false;
    }
  });
  const target = useHTMLElement(el);
  useEvent("mouseenter", onMouseEnter, target);
  useEvent("mouseleave", onMouseLeave, target);
  return { isHovered, onMouseEnter, onMouseLeave };
}

// node_modules/vuestic-ui/dist/es/src/composables/usePressed.js
function usePressed(el) {
  const isPressed = ref(false);
  const onMouseDown = () => {
    isPressed.value = true;
  };
  const onMouseUp = () => {
    isPressed.value = false;
  };
  const target = useHTMLElement(el);
  useEvent(["mousedown", "touchstart", "dragstart"], onMouseDown, target);
  useEvent([
    "mouseup",
    "mouseleave",
    "touchend",
    "touchcancel",
    "drop",
    "dragend"
  ], onMouseUp, true);
  return { isPressed, onMouseDown, onMouseUp };
}

// node_modules/vuestic-ui/dist/es/src/composables/useSlotPassed.js
var checkSlotChildrenDeep = (v2, initial = true) => {
  var _a2;
  if (!v2 || initial && (!isFunction$4(v2) || !((_a2 = v2()) == null ? void 0 : _a2.length))) {
    return false;
  }
  const slotData = initial ? v2() : v2;
  if (Array.isArray(slotData)) {
    return slotData.some((el) => {
      return Array.isArray(el.children) ? checkSlotChildrenDeep(el.children, false) : el.children || el.props;
    });
  }
  return !!slotData.children;
};
var useSlotPassed = (name = "default") => {
  const { slots } = getCurrentInstance();
  return computed(() => checkSlotChildrenDeep(slots[name]));
};

// node_modules/vuestic-ui/dist/es/src/composables/useBem.js
var useBem = (prefix2, modifiers) => {
  if (isDev && !prefix2) {
    console.warn('You must pass the @param "prefix" to the useBem hook!');
  }
  const modifiersList = computed(() => isFunction$4(modifiers) ? modifiers() : unref(modifiers));
  const computedBemClassesObject = computed(() => {
    return Object.entries(unref(modifiersList)).reduce((classesObj, [modifierName, value]) => {
      if (value) {
        classesObj[`${prefix2}--${kebabCase$1(modifierName)}`] = true;
      }
      return classesObj;
    }, {});
  });
  const computedBemClassesArray = computed(() => Object.keys(computedBemClassesObject.value));
  const computedBemClassesString = computed(() => computedBemClassesArray.value.join(" "));
  return new Proxy({}, {
    ownKeys() {
      return Reflect.ownKeys(computedBemClassesObject.value);
    },
    getOwnPropertyDescriptor(_2, key) {
      return Reflect.getOwnPropertyDescriptor(computedBemClassesObject.value, key);
    },
    get(_2, key, receiver) {
      switch (key) {
        case "asArray":
          return computedBemClassesArray;
        case "asString":
          return computedBemClassesString;
        case "asObject":
          return computedBemClassesObject;
        default:
          return Reflect.get(computedBemClassesObject.value, key, receiver);
      }
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-button/VaButton.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaButton.css";
var _sfc_main4 = defineComponent({
  name: "VaButton",
  components: { VaIcon, VaProgressCircle },
  props: {
    ...useComponentPresetProp,
    ...useSizeProps,
    ...useHoverStyleProps,
    ...usePressedStyleProps,
    ...useLoadingProps,
    ...useRouterLinkProps,
    tag: { type: String, default: "button" },
    type: { type: String, default: "button" },
    block: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    textColor: { type: String, default: "" },
    textOpacity: { type: Number, default: 1 },
    backgroundOpacity: { type: Number, default: 1 },
    borderColor: { type: String, default: "" },
    // only for filled bg state
    gradient: { type: Boolean, default: false },
    plain: { type: Boolean, default: false },
    round: { type: Boolean, default: false },
    size: {
      type: String,
      default: "medium",
      validator: (v2) => ["small", "medium", "large"].includes(v2)
    },
    icon: { type: String, default: "" },
    iconRight: { type: String, default: "" },
    iconColor: { type: String, default: "" }
  },
  setup(props2) {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props2.color));
    const { sizeComputed } = useSize(props2);
    const iconSizeComputed = computed(() => {
      const size3 = /([0-9]*)(px)/.exec(sizeComputed.value);
      return size3 ? `${+size3[1] / 2}${size3[2]}` : sizeComputed.value;
    });
    const { tagComputed } = useRouterLink(props2);
    const attributesComputed = useButtonAttributes(props2);
    const { disabled } = toRefs(props2);
    const button = shallowRef();
    const { focus, blur } = useFocus(button);
    const { isHovered } = useHover(button, disabled);
    const { isPressed } = usePressed(button);
    const iconColorComputed = computed(() => props2.iconColor ? getColor(props2.iconColor) : textColorComputed.value);
    const iconAttributesComputed = computed(() => ({
      color: iconColorComputed.value,
      size: props2.size
    }));
    const wrapperClassComputed = computed(() => ({ "va-button__content--loading": props2.loading }));
    const isSlotContentPassed = useSlotPassed();
    const isOneIcon = computed(() => !!(props2.iconRight && !props2.icon || !props2.iconRight && props2.icon));
    const isOnlyIcon = computed(() => !isSlotContentPassed.value && isOneIcon.value);
    const computedClass = useBem("va-button", () => ({
      ...pick$1(props2, ["disabled", "block", "loading", "round", "plain"]),
      small: props2.size === "small",
      normal: !props2.size || props2.size === "medium",
      large: props2.size === "large",
      opacity: props2.textOpacity < 1,
      bordered: !!props2.borderColor,
      iconOnly: isOnlyIcon.value,
      leftIcon: !isOnlyIcon.value && !!props2.icon && !props2.iconRight,
      rightIcon: !isOnlyIcon.value && !props2.icon && !!props2.iconRight
    }));
    const isTransparentBg = computed(() => props2.plain || props2.backgroundOpacity < 0.5);
    const { textColorComputed } = useTextColor(colorComputed, isTransparentBg);
    const {
      backgroundColor,
      backgroundColorOpacity,
      backgroundMaskOpacity,
      backgroundMaskColor
    } = useButtonBackground(colorComputed, isPressed, isHovered);
    const contentColorComputed = useButtonTextColor(textColorComputed, colorComputed, isPressed, isHovered);
    const computedStyle = computed(() => ({
      borderColor: props2.borderColor ? getColor(props2.borderColor) : "transparent",
      ...contentColorComputed.value
    }));
    return {
      button,
      tagComputed,
      computedClass,
      computedStyle,
      textColorComputed,
      iconSizeComputed,
      attributesComputed,
      wrapperClassComputed,
      iconAttributesComputed,
      backgroundColor,
      backgroundMaskColor,
      backgroundMaskOpacity,
      backgroundColorOpacity,
      focus,
      blur
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-button/VaButton.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaButton.css";
function _sfc_render4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_progress_circle = resolveComponent("va-progress-circle");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), mergeProps({
    ref: "button",
    class: ["va-button", _ctx.computedClass],
    style: [_ctx.computedStyle, `--va-background-color: ${String(_ctx.backgroundColor)};--va-background-color-opacity: ${String(_ctx.backgroundColorOpacity)};--va-background-mask-color: ${String(_ctx.backgroundMaskColor)};--va-background-mask-opacity: ${String(_ctx.backgroundMaskOpacity)}`]
  }, _ctx.attributesComputed), {
    default: withCtx(() => [
      createBaseVNode("span", {
        class: normalizeClass(["va-button__content", _ctx.wrapperClassComputed])
      }, [
        renderSlot(_ctx.$slots, "prepend", normalizeProps(guardReactiveProps({ icon: _ctx.icon, iconAttributes: _ctx.iconAttributesComputed })), () => [
          _ctx.icon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 0,
            class: "va-button__left-icon",
            name: _ctx.icon
          }, _ctx.iconAttributesComputed), null, 16, ["name"])) : createCommentVNode("", true)
        ]),
        renderSlot(_ctx.$slots, "default"),
        renderSlot(_ctx.$slots, "append", normalizeProps(guardReactiveProps({ icon: _ctx.iconRight, iconAttributes: _ctx.iconAttributesComputed })), () => [
          _ctx.iconRight ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 0,
            class: "va-button__right-icon",
            name: _ctx.iconRight
          }, _ctx.iconAttributesComputed), null, 16, ["name"])) : createCommentVNode("", true)
        ])
      ], 2),
      _ctx.loading ? renderSlot(_ctx.$slots, "loading", normalizeProps(mergeProps({ key: 0 }, {
        size: _ctx.iconSizeComputed,
        color: _ctx.textColorComputed
      })), () => [
        createVNode(_component_va_progress_circle, {
          class: "va-button__loader",
          size: _ctx.iconSizeComputed,
          color: _ctx.textColorComputed,
          thickness: 0.15,
          indeterminate: ""
        }, null, 8, ["size", "color"])
      ]) : createCommentVNode("", true)
    ]),
    _: 3
  }, 16, ["class", "style"]);
}
var _VaButton = _export_sfc(_sfc_main4, [["render", _sfc_render4]]);

// node_modules/vuestic-ui/dist/es/src/components/va-button/index.js
var VaButton = withConfigTransport$1(_VaButton);

// node_modules/vuestic-ui/dist/es/src/composables/useCurrentComponentId.js
var useCurrentComponentId = () => {
  const instance = getCurrentInstance();
  if (!instance.appContext.app) {
    return String(instance.uid);
  }
  return `${instance.appContext.app._uid}_${instance.uid}`;
};

// node_modules/vuestic-ui/dist/es/src/components/va-modal/hooks/useBlur.js
var openedModals = [];
var useBlur = (shouldBlur, isModalShown) => {
  const id = useCurrentComponentId();
  const document2 = useDocument();
  const blur = () => {
    var _a2;
    if (openedModals.includes(id)) {
      return;
    }
    openedModals.push(id);
    (_a2 = document2.value) == null ? void 0 : _a2.body.classList.add("va-modal-overlay-background--blurred");
  };
  const removeBlur = () => {
    var _a2;
    const modalIndex = openedModals.indexOf(id);
    if (modalIndex === -1) {
      return;
    }
    openedModals.splice(modalIndex, 1);
    if (openedModals.length === 0) {
      (_a2 = document2.value) == null ? void 0 : _a2.body.classList.remove("va-modal-overlay-background--blurred");
    }
  };
  watchEffect(() => {
    if (!shouldBlur.value) {
      return;
    }
    if (isModalShown.value) {
      blur();
    } else {
      removeBlur();
    }
  });
  onBeforeUnmount(removeBlur);
};

// node_modules/vuestic-ui/dist/es/src/composables/useZIndex.js
var createInstance = () => {
  return generateUniqueId();
};
var zIndexStack = shallowReactive([]);
var useZIndex = () => {
  const instance = createInstance();
  const register = () => {
    if (zIndexStack.includes(instance)) {
      return;
    }
    zIndexStack.push(instance);
  };
  const unregister = () => {
    const index = zIndexStack.findIndex((item) => item === instance);
    if (index !== -1) {
      zIndexStack.splice(index, 1);
    }
  };
  const zIndex = computed(() => {
    const index = zIndexStack.findIndex((item) => item === instance);
    if (index === -1) {
      return -1;
    }
    return index + 1;
  });
  const isTop = computed(() => zIndex.value === zIndexStack.length - 1);
  const isLowest = computed(() => zIndex.value === 0);
  return {
    zIndex,
    isTop,
    isLowest,
    register,
    unregister
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useUserProvidedProp.js
var NOT_PROVIDED = Symbol("NOT_PROVIDED");
var useUserProvidedProp = (propName, props2) => {
  const vm = getCurrentInstance();
  return computed(() => {
    if (!(vm == null ? void 0 : vm.vnode.props)) {
      return NOT_PROVIDED;
    }
    const originalProp = props2[propName];
    return propName in vm.vnode.props ? originalProp : NOT_PROVIDED;
  });
};

// node_modules/vuestic-ui/dist/es/src/composables/useStateful.js
var useStatefulProps = {
  stateful: { type: Boolean, default: false },
  modelValue: { type: void 0 }
};
var createStatefulProps = (statefulDefault = false) => {
  return {
    stateful: { type: Boolean, default: statefulDefault }
  };
};
var useStatefulEmits = ["update:modelValue"];
var useStateful = (props2, emit, key = "modelValue", options = {}) => {
  const { eventName, defaultValue } = options;
  const event = eventName || `update:${key.toString()}`;
  const passedProp = useUserProvidedProp(key, props2);
  const defaultValuePassed = "defaultValue" in options;
  const valueState = ref(
    passedProp.value === NOT_PROVIDED ? defaultValuePassed ? defaultValue : props2[key] : passedProp.value
  );
  let unwatchModelValue;
  const watchModelValue = () => {
    unwatchModelValue = watch(() => props2[key], (modelValue) => {
      valueState.value = modelValue;
    });
  };
  watch(() => props2.stateful, (stateful) => {
    stateful ? watchModelValue() : unwatchModelValue == null ? void 0 : unwatchModelValue();
  }, { immediate: true });
  const valueComputed = computed({
    get: () => {
      if (props2.stateful) {
        return valueState.value;
      }
      return props2[key];
    },
    set: (value) => {
      if (props2.stateful) {
        valueState.value = value;
      }
      emit(event, value);
    }
  });
  return { valueComputed };
};

// node_modules/vuestic-ui/dist/es/src/composables/useTrapFocus.js
var FOCUSABLE_ELEMENTS_SELECTOR = ":where(a, button, input, textarea, select):not([disabled]), *[tabindex]";
var trapInEl = null;
var useTrapFocus = () => {
  const document2 = useDocument();
  const window2 = useWindow();
  let focusableElements = [];
  let firstFocusableElement = null;
  let lastFocusableElement = null;
  let isFocusTrapped = false;
  const focusFirstElement = () => {
    firstFocusableElement == null ? void 0 : firstFocusableElement.focus();
  };
  const focusLastElement = () => {
    lastFocusableElement == null ? void 0 : lastFocusableElement.focus();
  };
  const onKeydown = (evt) => {
    var _a2, _b;
    const isTabPressed = evt.code === "Tab";
    const isShiftPressed = evt.shiftKey;
    if (!isTabPressed) {
      return;
    }
    if (!isFocusTrapped) {
      isFocusTrapped = true;
      evt.preventDefault();
      isShiftPressed ? focusLastElement() : focusFirstElement();
      return;
    }
    if (((_a2 = document2.value) == null ? void 0 : _a2.activeElement) === lastFocusableElement && !isShiftPressed) {
      evt.preventDefault();
      focusFirstElement();
      return;
    }
    if (((_b = document2.value) == null ? void 0 : _b.activeElement) === firstFocusableElement && isShiftPressed) {
      evt.preventDefault();
      focusLastElement();
    }
  };
  const trapFocusIn = (el) => {
    trapInEl = el;
    freeFocus();
    trapFocus();
  };
  const trapFocus = () => {
    var _a2;
    if (!trapInEl) {
      return;
    }
    focusableElements = Array.from(trapInEl.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR));
    firstFocusableElement = focusableElements[0];
    lastFocusableElement = focusableElements[focusableElements.length - 1];
    (_a2 = window2.value) == null ? void 0 : _a2.addEventListener("keydown", onKeydown);
  };
  const freeFocus = () => {
    var _a2;
    focusableElements = [];
    firstFocusableElement = null;
    lastFocusableElement = null;
    isFocusTrapped = false;
    (_a2 = window2.value) == null ? void 0 : _a2.removeEventListener("keydown", onKeydown);
  };
  return {
    trapFocus,
    freeFocus,
    trapFocusIn
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useModalLevel.js
var modalsStack = shallowReactive([]);
var useModalLevel = () => {
  const modalId = uniqueId$1();
  const modalLevel = computed(
    () => modalsStack.findIndex(({ id }) => id === modalId)
  );
  const registerModal = () => {
    if (modalLevel.value !== -1) {
      return;
    }
    modalsStack.push({
      id: modalId
    });
  };
  const unregisterModal = () => {
    if (modalLevel.value === -1) {
      return;
    }
    modalsStack.splice(modalLevel.value, 1);
  };
  const isTopLevelModal = computed(
    () => modalLevel.value !== -1 && modalLevel.value === modalsStack.length - 1
  );
  const isLowestLevelModal = computed(
    () => modalLevel.value === 0
  );
  const isMoreThenOneModalOpen = computed(() => modalsStack.length > 1);
  return {
    modalId,
    modalLevel,
    registerModal,
    unregisterModal,
    isTopLevelModal,
    isLowestLevelModal,
    isMoreThenOneModalOpen
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useTeleported.js
var TELEPORT_FROM_ATTR = "data-va-teleported-from";
var TELEPORT_ATTR = "data-va-teleported";
var findTeleportedFrom = (el) => {
  if (!el) {
    return null;
  }
  const teleportId = el.getAttribute(TELEPORT_ATTR);
  if (teleportId === null) {
    return findTeleportedFrom(el.parentElement);
  }
  return document.querySelector(`[${TELEPORT_FROM_ATTR}="${teleportId}"]`);
};
var useTeleported = () => {
  const componentId = useCurrentComponentId();
  return {
    teleportFromAttrs: {
      [TELEPORT_FROM_ATTR]: componentId
    },
    teleportedAttrs: {
      [TELEPORT_ATTR]: componentId
    },
    findTeleportedFrom
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useClickOutside.js
var checkIfElementChild = (parent2, child) => {
  if (!child) {
    return false;
  }
  if (child.parentElement === parent2) {
    return true;
  }
  return parent2.contains(child);
};
var safeArray = (a2) => Array.isArray(a2) ? a2 : [a2];
var useClickOutside = (elements, cb) => {
  useCaptureEvent("mousedown", (event) => {
    const clickTarget = event.target;
    if (event.target.shadowRoot) {
      return;
    }
    const teleportParent = findTeleportedFrom(clickTarget);
    const isClickInside = safeArray(elements).some((element) => {
      const el = unwrapEl(unref(element));
      if (!el) {
        return false;
      }
      if (!teleportParent) {
        return checkIfElementChild(el, clickTarget);
      }
      return checkIfElementChild(el, clickTarget) || checkIfElementChild(el, teleportParent);
    });
    if (!isClickInside) {
      cb(clickTarget);
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-modal/VaModal.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaModal.css";
var WithTransition = defineComponent({
  name: "ModalElement",
  inheritAttrs: false,
  props: {
    ...useComponentPresetProp,
    isTransition: { type: Boolean, default: true }
  },
  setup: (props2, { slots, attrs }) => () => {
    var _a2;
    return props2.isTransition ? h(Transition, { ...attrs }, slots) : (_a2 = slots.default) == null ? void 0 : _a2.call(slots, attrs);
  }
});
var _sfc_main5 = defineComponent({
  name: "VaModal",
  inheritAttrs: false,
  components: { VaButton, VaIcon, WithTransition },
  emits: [
    ...useStatefulEmits,
    "cancel",
    "ok",
    "before-open",
    "open",
    "before-close",
    "close",
    "click-outside"
  ],
  props: {
    ...useStatefulProps,
    modelValue: { type: Boolean, default: false },
    attachElement: { type: String, default: "body" },
    allowBodyScroll: { type: Boolean, default: false },
    disableAttachment: { type: Boolean, default: false },
    title: { type: String, default: "" },
    message: { type: String, default: "" },
    okText: { type: String, default: "$t:ok" },
    cancelText: { type: String, default: "$t:cancel" },
    hideDefaultActions: { type: Boolean, default: false },
    fullscreen: { type: Boolean, default: false },
    closeButton: { type: Boolean, default: false },
    mobileFullscreen: { type: Boolean, default: true },
    noDismiss: { type: Boolean, default: false },
    noOutsideDismiss: { type: Boolean, default: false },
    noEscDismiss: { type: Boolean, default: false },
    maxWidth: { type: String, default: "" },
    maxHeight: { type: String, default: "" },
    anchorClass: { type: String },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["medium", "small", "large"].includes(value)
    },
    fixedLayout: { type: Boolean, default: false },
    withoutTransitions: { type: Boolean, default: false },
    overlay: { type: Boolean, default: true },
    overlayOpacity: { type: [Number, String], default: 0.6 },
    showNestedOverlay: { type: Boolean, default: false },
    blur: { type: Boolean, default: false },
    zIndex: { type: [Number, String], default: void 0 },
    backgroundColor: { type: String, default: "background-secondary" },
    noPadding: { type: Boolean, default: false },
    beforeClose: { type: Function },
    beforeOk: { type: Function },
    beforeCancel: { type: Function },
    ariaCloseLabel: { type: String, default: "$t:close" }
  },
  setup(props2, { emit }) {
    const rootElement = shallowRef();
    const modalDialog = shallowRef();
    const { trapFocusIn, freeFocus } = useTrapFocus();
    const {
      registerModal,
      unregisterModal,
      isTopLevelModal,
      isLowestLevelModal
    } = useModalLevel();
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor(toRef(props2, "backgroundColor"));
    const { valueComputed } = useStateful(props2, emit);
    const computedClass = computed(() => ({
      "va-modal--fullscreen": props2.fullscreen,
      "va-modal--mobile-fullscreen": props2.mobileFullscreen,
      "va-modal--fixed-layout": props2.fixedLayout,
      "va-modal--no-padding": props2.noPadding,
      [`va-modal--size-${props2.size}`]: props2.size !== "medium"
    }));
    const {
      zIndex,
      register: registerZIndex,
      unregister: unregisterZIndex
    } = useZIndex();
    const zIndexComputed = computed(() => {
      if (props2.zIndex) {
        return Number(props2.zIndex);
      }
      return zIndex.value;
    });
    const computedDialogStyle = computed(() => ({
      maxWidth: props2.maxWidth,
      maxHeight: props2.maxHeight,
      color: textColorComputed.value,
      background: getColor(props2.backgroundColor)
    }));
    const computedOverlayClass = computed(() => ({
      "va-modal__overlay--lowest": isLowestLevelModal.value,
      "va-modal__overlay--top": isTopLevelModal.value
    }));
    const getOverlayOpacity = () => {
      if (props2.showNestedOverlay && !isLowestLevelModal.value) {
        return "var(--va-modal-overlay-nested-opacity)";
      }
      return "var(--va-modal-overlay-opacity)";
    };
    const computedOverlayStyles = computed(() => {
      if (!props2.overlay) {
        return;
      }
      if (isTopLevelModal.value || props2.showNestedOverlay) {
        return {
          "background-color": "var(--va-modal-overlay-color)",
          opacity: getOverlayOpacity(),
          "z-index": zIndexComputed.value && Number(zIndexComputed.value) - 1
        };
      }
      return "";
    });
    const show = () => {
      valueComputed.value = true;
    };
    const hide3 = (cb) => {
      const _hide = () => {
        valueComputed.value = false;
        cb == null ? void 0 : cb();
      };
      props2.beforeClose ? props2.beforeClose(_hide) : _hide();
    };
    const toggle = () => {
      valueComputed.value = !valueComputed.value;
    };
    const cancel = () => {
      const _hide = () => {
        hide3(() => emit("cancel"));
      };
      props2.beforeCancel ? props2.beforeCancel(_hide) : _hide();
    };
    const ok = () => {
      const _hide = () => {
        hide3(() => emit("ok"));
      };
      props2.beforeOk ? props2.beforeOk(_hide) : _hide();
    };
    const trapFocusInModal = () => {
      nextTick(() => {
        if (modalDialog.value) {
          trapFocusIn(modalDialog.value);
        }
      });
    };
    const onBeforeEnterTransition = (el) => emit("before-open", el);
    const onAfterEnterTransition = (el) => emit("open", el);
    const onBeforeLeaveTransition = (el) => emit("before-close", el);
    const onAfterLeaveTransition = (el) => emit("close", el);
    const listenKeyUp = (e2) => {
      const hideModal = () => {
        if (e2.code === "Escape" && !props2.noEscDismiss && !props2.noDismiss && isTopLevelModal.value) {
          cancel();
        }
      };
      setTimeout(hideModal);
    };
    useClickOutside([modalDialog], () => {
      if (!valueComputed.value || props2.noOutsideDismiss || props2.noDismiss || !isTopLevelModal.value) {
        return;
      }
      emit("click-outside");
      cancel();
    });
    const window2 = useWindow();
    watchEffect(() => {
      var _a2, _b;
      if (valueComputed.value) {
        (_a2 = window2.value) == null ? void 0 : _a2.addEventListener("keyup", listenKeyUp);
      } else {
        (_b = window2.value) == null ? void 0 : _b.removeEventListener("keyup", listenKeyUp);
      }
    });
    useBlur(toRef(props2, "blur"), valueComputed);
    const documentRef = useDocument();
    const setBodyOverflow = (overflow) => {
      if (!documentRef.value || props2.allowBodyScroll) {
        return;
      }
      documentRef.value.body.style.overflow = overflow;
    };
    watch(valueComputed, (newValueComputed) => {
      if (newValueComputed) {
        registerModal();
        registerZIndex();
        setBodyOverflow("hidden");
        return;
      }
      if (isLowestLevelModal.value) {
        freeFocus();
        setBodyOverflow("");
      }
      unregisterModal();
      unregisterZIndex();
    });
    watch(isTopLevelModal, (newIsTopLevelModal) => {
      if (newIsTopLevelModal) {
        trapFocusInModal();
      }
    });
    onMounted(() => {
      if (valueComputed.value) {
        registerModal();
        registerZIndex();
      }
    });
    const { tp, t: t2 } = useTranslation();
    const {
      teleportFromAttrs,
      teleportedAttrs,
      findTeleportedFrom: findTeleportedFrom2
    } = useTeleported();
    const slotBind = { show, hide: hide3, toggle, cancel, ok };
    return {
      tp,
      t: t2,
      zIndexComputed,
      isLowestLevelModal,
      isTopLevelModal,
      computedOverlayClass,
      getColor,
      rootElement,
      modalDialog,
      valueComputed,
      computedClass,
      computedDialogStyle,
      computedOverlayStyles,
      slotBind,
      teleportFromAttrs,
      teleportedAttrs,
      findTeleportedFrom: findTeleportedFrom2,
      show,
      hide: hide3,
      toggle,
      cancel,
      ok,
      onBeforeEnterTransition,
      onAfterEnterTransition,
      onBeforeLeaveTransition,
      onAfterLeaveTransition,
      listenKeyUp
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-modal/VaModal.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaModal.css";
var _hoisted_13 = ["aria-labelledby"];
var _hoisted_23 = { class: "va-modal__container" };
var _hoisted_32 = { key: 0 };
var _hoisted_42 = {
  key: 1,
  class: "va-modal__header"
};
var _hoisted_52 = {
  key: 2,
  class: "va-modal__message"
};
var _hoisted_62 = {
  key: 3,
  class: "va-modal__message"
};
var _hoisted_72 = {
  key: 4,
  class: "va-modal__footer"
};
var _hoisted_8 = {
  key: 5,
  class: "va-modal__footer"
};
function _sfc_render5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_button = resolveComponent("va-button");
  const _component_WithTransition = resolveComponent("WithTransition");
  return openBlock(), createElementBlock("div", {
    ref: "rootElement",
    class: normalizeClass(["va-modal-entry", _ctx.$props.anchorClass]),
    role: "dialog",
    "aria-modal": "true",
    "aria-labelledby": _ctx.title,
    style: normalizeStyle(`--va-z-index-computed: ${String(_ctx.zIndexComputed)}`)
  }, [
    _ctx.$slots.anchor ? (openBlock(), createElementBlock("div", mergeProps({
      key: 0,
      class: "va-modal__anchor"
    }, _ctx.teleportFromAttrs), [
      renderSlot(_ctx.$slots, "anchor", normalizeProps(guardReactiveProps(_ctx.slotBind)))
    ], 16)) : createCommentVNode("", true),
    (openBlock(), createBlock(Teleport, {
      to: _ctx.attachElement,
      disabled: _ctx.$props.disableAttachment
    }, [
      createVNode(_component_WithTransition, mergeProps({
        name: "va-modal",
        isTransition: !_ctx.$props.withoutTransitions,
        appear: "",
        duration: 300
      }, { ..._ctx.$attrs, ..._ctx.teleportedAttrs }, {
        onBeforeEnter: _ctx.onBeforeEnterTransition,
        onAfterEnter: _ctx.onAfterEnterTransition,
        onBeforeLeave: _ctx.onBeforeLeaveTransition,
        onAfterLeave: _ctx.onAfterLeaveTransition
      }), {
        default: withCtx(() => [
          _ctx.valueComputed ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(["va-modal", _ctx.computedClass])
          }, [
            _ctx.$props.overlay ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(["va-modal__overlay", _ctx.computedOverlayClass]),
              style: normalizeStyle(_ctx.computedOverlayStyles)
            }, null, 6)) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_23, [
              createBaseVNode("div", {
                ref: "modalDialog",
                class: "va-modal__dialog",
                style: normalizeStyle(_ctx.computedDialogStyle)
              }, [
                _ctx.$props.fullscreen || _ctx.$props.closeButton ? (openBlock(), createBlock(_component_va_icon, {
                  key: 0,
                  name: "va-close",
                  class: normalizeClass(["va-modal__close", { "va-modal__close--fullscreen": _ctx.$props.fullscreen }]),
                  role: "button",
                  "aria-label": _ctx.tp(_ctx.$props.ariaCloseLabel),
                  tabindex: "0",
                  onClick: _ctx.cancel,
                  onKeydown: [
                    withKeys(_ctx.cancel, ["space"]),
                    withKeys(_ctx.cancel, ["enter"])
                  ]
                }, null, 8, ["class", "aria-label", "onClick", "onKeydown"])) : createCommentVNode("", true),
                createBaseVNode("div", {
                  class: "va-modal__inner",
                  style: normalizeStyle({ maxWidth: _ctx.$props.maxWidth, maxHeight: _ctx.$props.maxHeight })
                }, [
                  _ctx.$slots.content ? (openBlock(), createElementBlock("div", _hoisted_32, [
                    renderSlot(_ctx.$slots, "content", normalizeProps(guardReactiveProps(_ctx.slotBind)))
                  ])) : createCommentVNode("", true),
                  !_ctx.$slots.content ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    _ctx.title ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      class: "va-modal__title",
                      style: normalizeStyle({ color: _ctx.getColor("primary") })
                    }, toDisplayString(_ctx.$props.title), 5)) : createCommentVNode("", true),
                    _ctx.$slots.header ? (openBlock(), createElementBlock("div", _hoisted_42, [
                      renderSlot(_ctx.$slots, "header", normalizeProps(guardReactiveProps(_ctx.slotBind)))
                    ])) : createCommentVNode("", true),
                    _ctx.$props.message ? (openBlock(), createElementBlock("div", _hoisted_52, toDisplayString(_ctx.$props.message), 1)) : createCommentVNode("", true),
                    _ctx.$slots.default ? (openBlock(), createElementBlock("div", _hoisted_62, [
                      renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(_ctx.slotBind)))
                    ])) : createCommentVNode("", true),
                    (_ctx.$props.cancelText || _ctx.$props.okText) && !_ctx.$props.hideDefaultActions ? (openBlock(), createElementBlock("div", _hoisted_72, [
                      _ctx.$props.cancelText ? (openBlock(), createBlock(_component_va_button, {
                        key: 0,
                        preset: "secondary",
                        color: "secondary",
                        class: "va-modal__default-cancel-button",
                        onClick: _ctx.cancel
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.tp(_ctx.$props.cancelText)), 1)
                        ]),
                        _: 1
                      }, 8, ["onClick"])) : createCommentVNode("", true),
                      createVNode(_component_va_button, { onClick: _ctx.ok }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.tp(_ctx.$props.okText)), 1)
                        ]),
                        _: 1
                      }, 8, ["onClick"])
                    ])) : createCommentVNode("", true),
                    _ctx.$slots.footer ? (openBlock(), createElementBlock("div", _hoisted_8, [
                      renderSlot(_ctx.$slots, "footer", normalizeProps(guardReactiveProps(_ctx.slotBind)))
                    ])) : createCommentVNode("", true)
                  ], 64)) : createCommentVNode("", true)
                ], 4)
              ], 4)
            ])
          ], 2)) : createCommentVNode("", true)
        ]),
        _: 3
      }, 16, ["isTransition", "onBeforeEnter", "onAfterEnter", "onBeforeLeave", "onAfterLeave"])
    ], 8, ["to", "disabled"]))
  ], 14, _hoisted_13);
}
var _VaModal = _export_sfc(_sfc_main5, [["render", _sfc_render5]]);
var VaModal = withConfigTransport$1(_VaModal);

// node_modules/vuestic-ui/dist/es/src/components/va-modal/modal.js
var getNodeProps2 = (vNode) => {
  var _a2;
  return ((_a2 = vNode.component) == null ? void 0 : _a2.props) || {};
};
var destroy2 = (el, vNode) => {
  if (el) {
    render(null, el);
    el.remove();
  }
  el = null;
};
var mount2 = (component, { props: props2, appContext } = {}) => {
  const el = document == null ? void 0 : document.createElement("div");
  let vNode;
  const onClose = (event) => {
    var _a2;
    (_a2 = props2 == null ? void 0 : props2.onClose) == null ? void 0 : _a2.call(props2, event);
    destroy2(el);
  };
  const onUpdateModelValue = (value) => {
    var _a2;
    (_a2 = props2 == null ? void 0 : props2["onUpdate:modelValue"]) == null ? void 0 : _a2.call(props2, value);
    if ((props2 == null ? void 0 : props2.withoutTransitions) && !value) {
      nextTick(() => {
        destroy2(el);
      });
    }
  };
  vNode = h(component, {
    ...props2,
    stateful: (props2 == null ? void 0 : props2.stateful) ?? true,
    modelValue: true,
    onClose,
    "onUpdate:modelValue": onUpdateModelValue
  });
  if (appContext) {
    vNode.appContext = appContext;
  }
  if (el) {
    render(vNode, el);
  }
  return { vNode, el };
};
var getModalOptions = (options) => typeof options === "string" ? { message: options } : options;
var createModalInstance = (customProps, appContext) => {
  const { vNode, el } = mount2(VaModal, { appContext, props: getModalOptions(customProps) });
  if (el && vNode.el && getNodeProps2(vNode)) {
    document.body.appendChild(el.childNodes[0]);
  }
  return vNode;
};

// node_modules/vuestic-ui/dist/es/src/components/va-modal/plugin/index.js
var createVaModalPlugin = (app) => ({
  init(options) {
    return createModalInstance(options, app == null ? void 0 : app._context);
  },
  confirm(options) {
    if (typeof options === "string") {
      return new Promise((resolve) => {
        createModalInstance({
          message: options,
          onOk() {
            resolve(true);
          },
          onCancel() {
            resolve(false);
          }
        }, app == null ? void 0 : app._context);
      });
    }
    return new Promise((resolve) => {
      createModalInstance({
        ...options,
        onOk() {
          var _a2;
          (_a2 = options == null ? void 0 : options.onOk) == null ? void 0 : _a2.call(options);
          resolve(true);
        },
        onCancel() {
          var _a2;
          (_a2 = options == null ? void 0 : options.onCancel) == null ? void 0 : _a2.call(options);
          resolve(false);
        }
      }, app == null ? void 0 : app._context);
    });
  }
});
var VaModalPlugin = defineVuesticPlugin(() => ({
  install(app) {
    defineGlobalProperty(app, "$vaModal", createVaModalPlugin(app));
  }
}));

// node_modules/vuestic-ui/dist/es/src/services/colors-classes/plugin/index.js
var getColorsClassesHelpers = (helpers, colors) => {
  const colorsEntries = Object.entries(colors);
  return helpers.reduce((acc, helper) => acc.concat(
    colorsEntries.map(([colorName, colorValue]) => ({
      ...helper,
      postfix: helper.postfix ?? colorName,
      value: helper.value ?? colorValue
    }))
  ), []);
};
var getColorsClassesStyles = (helpers) => {
  return helpers.reduce((styles, helper) => {
    const style = [helper.property].flat().map((prop) => `${prop}: ${helper.value};`).join("");
    styles += `.va-${helper.prefix}--${helper.postfix} { ${style} }`;
    return styles;
  }, "");
};
var handleConfigUpdate = (helpers, colors) => {
  const coloredHelpers = getColorsClassesHelpers(helpers, colors);
  addOrUpdateStyleElement(
    "va-color-helpers",
    () => getColorsClassesStyles(coloredHelpers)
  );
};
var createColorHelpersPlugin = () => {
  if (isServer()) {
    return;
  }
  const { globalConfig } = useGlobalConfig();
  watch(() => globalConfig.value.colorsClasses, (newHelpers) => {
    if (newHelpers.length) {
      handleConfigUpdate(newHelpers, globalConfig.value.colors.variables);
    }
  }, { immediate: true, deep: true });
  watch(() => globalConfig.value.colors.variables, (newColors) => {
    if (!newColors) {
      return;
    }
    handleConfigUpdate(globalConfig.value.colorsClasses, newColors);
  }, { immediate: true, deep: true });
  return {
    renderColorHelpers: () => {
      const coloredHelpers = getColorsClassesHelpers(globalConfig.value.colorsClasses, globalConfig.value.colors.variables);
      return getColorsClassesStyles(coloredHelpers);
    }
  };
};
var ColorsClassesPlugin = defineVuesticPlugin(() => ({
  install(app) {
    defineGlobalProperty(app, "$vaColorsClasses", createColorHelpersPlugin());
  }
}));

// node_modules/vuestic-ui/dist/es/src/components/va-accordion/hooks/useAccordion.js
var AccordionServiceKey = Symbol("AccordionService");
var useAccordion = (props2, state) => {
  const items2 = ref([]);
  const onItemMounted = (item) => {
    items2.value.push(item);
  };
  const onItemUnmounted = (item) => {
    items2.value = items2.value.filter((i2) => i2 !== item);
  };
  const getItemValue = (item) => {
    return state.value[items2.value.indexOf(item)] ?? false;
  };
  const setItemValue = (item, value) => {
    const index = items2.value.indexOf(item);
    if (index === -1) {
      return;
    }
    if (!props2.multiple) {
      state.value = state.value.map((el, i2) => {
        if (i2 === index) {
          return value;
        }
        return false;
      });
    } else {
      state.value[index] = value;
    }
  };
  watch(items2, (newItems) => {
    state.value = newItems.map((item) => getItemValue(item));
  }, { deep: true });
  provide(AccordionServiceKey, {
    isInsideAccordion: true,
    onItemMounted,
    onItemUnmounted,
    getItemValue,
    setItemValue,
    props: computed(() => props2)
  });
  return { items: items2 };
};
var useAccordionItem = () => {
  const accordion = inject(AccordionServiceKey, void 0);
  if (!accordion) {
    return { accordionProps: ref({}) };
  }
  const item = {};
  onMounted(() => accordion.onItemMounted(item));
  onBeforeUnmount(() => accordion.onItemUnmounted(item));
  const valueProxy = computed({
    get: () => accordion.getItemValue(item),
    set: (value) => accordion.setItemValue(item, value)
  });
  return {
    valueProxy,
    accordionProps: accordion.props
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-accordion/VaAccordion.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaAccordion.css";
var _sfc_main6 = defineComponent({
  name: "VaAccordion",
  emits: [...useStatefulEmits],
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Array, default: () => [] },
    multiple: { type: Boolean, default: false },
    inset: { type: Boolean, default: false },
    stateful: { type: Boolean, default: true },
    popout: { type: Boolean, default: false }
  },
  setup(props2, { emit }) {
    const { valueComputed } = useStateful(props2, emit, "modelValue");
    const { items: items2 } = useAccordion(props2, valueComputed);
    return { collapses: items2, value: valueComputed };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-accordion/VaAccordion.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaAccordion.css";
var _hoisted_14 = { class: "va-accordion" };
function _sfc_render6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_14, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var _VaAccordion = _export_sfc(_sfc_main6, [["render", _sfc_render6]]);

// node_modules/vuestic-ui/dist/es/src/components/va-accordion/index.js
var VaAccordion = withConfigTransport$1(_VaAccordion);

// node_modules/vuestic-ui/dist/es/src/components/va-affix/VaAffix-utils.js
function getWindowHeight() {
  return document.documentElement.clientHeight || window.innerHeight || document.body.clientHeight;
}
function computeAffixedState({
  coordinates,
  offsetTop,
  offsetBottom,
  target
}) {
  let isTopAffixed = false;
  let isBottomAffixed = false;
  const windowHeight = getWindowHeight();
  if (offsetTop != null && windowHeight) {
    if (target === window) {
      isTopAffixed = coordinates.top <= offsetTop;
    } else {
      const { top } = target.getBoundingClientRect();
      isTopAffixed = coordinates.top - top <= offsetTop;
    }
  }
  if (offsetBottom != null && windowHeight) {
    if (target === window) {
      isBottomAffixed = coordinates.bottom >= windowHeight - offsetBottom;
    } else {
      const { bottom } = target.getBoundingClientRect();
      isBottomAffixed = bottom - coordinates.bottom <= offsetBottom;
    }
  }
  return {
    isTopAffixed,
    isBottomAffixed
  };
}
function checkAffixedStateChange(currentState, nextState) {
  return currentState.isTopAffixed !== nextState.isTopAffixed || currentState.isBottomAffixed !== nextState.isBottomAffixed;
}
function handleThrottledEvent(eventName, context) {
  const { target, element, offsetTop, offsetBottom, setState, getState, initialPosition } = context;
  if (!element) {
    return;
  }
  const isInitialCall = !eventName;
  const coordinates = element.getBoundingClientRect();
  const options = {
    offsetBottom,
    offsetTop,
    target
  };
  const nextState = isInitialCall && initialPosition ? computeAffixedState({ coordinates: initialPosition, ...options }) : computeAffixedState({ coordinates, ...options });
  const prevState = getState();
  if (checkAffixedStateChange(prevState, nextState)) {
    setState({ ...nextState, width: coordinates.width });
  } else if (prevState.width !== coordinates.width) {
    setState({ ...prevState, width: coordinates.width });
  }
}
function useCaptureDefault(eventName) {
  return eventName === "scroll";
}
function useEventsHandlerWithThrottle(events, {
  handler,
  useCapture = useCaptureDefault,
  wait = 50
}) {
  const clearHandlersArray = events.map((eventName) => {
    const _handler = throttle$1((event) => handler(eventName, event), wait);
    window.addEventListener(eventName, _handler, useCapture(eventName));
    return () => window.removeEventListener(eventName, _handler, useCapture(eventName));
  });
  return () => clearHandlersArray.forEach((clear) => clear());
}

// node_modules/vuestic-ui/dist/es/src/components/va-affix/VaAffix.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaAffix.css";
var _sfc_main7 = defineComponent({
  name: "VaAffix",
  emits: ["change"],
  props: {
    ...useComponentPresetProp,
    offsetTop: { type: Number, default: void 0 },
    offsetBottom: { type: Number, default: void 0 },
    target: { type: [Object, Function], default: getWindow }
  },
  setup(props2, { emit }) {
    const element = shallowRef();
    const getTargetElement2 = () => typeof props2.target === "function" ? props2.target() : props2.target;
    const isAffixed = computed(() => state.value.isTopAffixed || state.value.isBottomAffixed);
    const state = ref({
      isTopAffixed: false,
      isBottomAffixed: false
    });
    const getState = () => state.value;
    const setState = (newState) => {
      state.value = newState;
      emit("change", isAffixed);
    };
    const calculateTop = () => {
      const target = getTargetElement2();
      if (!target) {
        return 0;
      }
      if (props2.offsetTop === void 0) {
        return;
      }
      if (!(target instanceof Window)) {
        const { top } = target.getBoundingClientRect();
        return top + props2.offsetTop;
      }
      return props2.offsetTop;
    };
    const calculateBottom = () => {
      const target = getTargetElement2();
      if (!target) {
        return 0;
      }
      if (props2.offsetBottom === void 0) {
        return;
      }
      if (!(target instanceof Window)) {
        const { bottom } = target.getBoundingClientRect();
        const { borderTopWidth, borderBottomWidth } = getComputedStyle(target);
        const { offsetHeight, clientHeight } = target;
        const scrollBarHeight = offsetHeight - clientHeight - parseInt(borderTopWidth) - parseInt(borderBottomWidth);
        return getWindowHeight() - (bottom - props2.offsetBottom) + scrollBarHeight;
      }
      return props2.offsetBottom;
    };
    const convertToPixels = (calculate) => {
      const result = calculate();
      return result === void 0 ? void 0 : `${result}px`;
    };
    const computedClass = computed(() => [{ "va-affix--affixed": isAffixed }]);
    const computedStyle = computed(() => ({
      top: state.value.isTopAffixed ? convertToPixels(calculateTop) : void 0,
      bottom: state.value.isBottomAffixed ? convertToPixels(calculateBottom) : void 0,
      width: `${state.value.width}px`
    }));
    const initialPosition = ref();
    const throttledEventHandler = (eventName, event) => {
      const context = {
        ...props2,
        initialPosition: initialPosition.value,
        element: element.value,
        target: getTargetElement2(),
        setState,
        getState
      };
      if (!eventName || eventName === "resize") {
        handleThrottledEvent(eventName, context);
      } else if (event && event.target) {
        const target = getTargetElement2();
        if (target === event.target || target instanceof Window) {
          handleThrottledEvent(eventName, context);
        } else {
          setState({
            isBottomAffixed: false,
            isTopAffixed: false
          });
        }
      }
    };
    let clearEventListeners = noop$1;
    onMounted(() => {
      var _a2;
      initialPosition.value = (_a2 = element.value) == null ? void 0 : _a2.getBoundingClientRect();
      const events = ["scroll", "resize"];
      clearEventListeners = useEventsHandlerWithThrottle(events, {
        handler: throttledEventHandler
      });
      nextTick(() => {
        throttledEventHandler(null);
      });
    });
    onBeforeUnmount(clearEventListeners);
    return {
      computedClass,
      computedStyle,
      isAffixed,
      element
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-affix/VaAffix.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaAffix.css";
var _hoisted_15 = {
  ref: "element",
  class: "va-affix"
};
function _sfc_render7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_15, [
    createBaseVNode("div", {
      style: normalizeStyle({ visibility: _ctx.isAffixed ? "hidden" : "inherit" })
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 4),
    _ctx.isAffixed ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(_ctx.computedClass),
      style: normalizeStyle(_ctx.computedStyle)
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 6)) : createCommentVNode("", true)
  ], 512);
}
var _VaAffix = _export_sfc(_sfc_main7, [["render", _sfc_render7]]);

// node_modules/vuestic-ui/dist/es/src/components/va-affix/index.js
var VaAffix = withConfigTransport$1(_VaAffix);

// node_modules/vuestic-ui/dist/es/src/composables/useElementTextColor.js
var useElementTextColor = (background) => {
  const { textColorComputed } = useTextColor(background);
  return textColorComputed;
};

// node_modules/vuestic-ui/dist/es/src/composables/useElementBackground.js
var parseRgba = (rgba) => {
  let values;
  if (rgba.startsWith("rgba")) {
    values = rgba.substring(5, rgba.length - 1).split(",");
  } else {
    values = rgba.substring(4, rgba.length - 1).split(",");
  }
  values[0] = Number(values[0]);
  values[1] = Number(values[1]);
  values[2] = Number(values[2]);
  if (values[3] === void 0) {
    values[3] = 1;
  } else {
    values[3] = Number(values[3]);
  }
  return values;
};
var toHex = (color) => {
  return "#" + (color[0] | 1 << 8).toString(16).slice(1) + (color[1] | 1 << 8).toString(16).slice(1) + (color[2] | 1 << 8).toString(16).slice(1) + (color[3] * 255 | 1 << 8).toString(16).slice(1);
};
var getParentsWithBackground = (el) => {
  const parents = [];
  let currentEl = el;
  while (currentEl) {
    if (!(currentEl instanceof HTMLElement) || !currentEl) {
      return parents;
    }
    const { backgroundColor, willChange } = window.getComputedStyle(currentEl);
    const bgWillChange = willChange.includes("background");
    const parsedColor = parseRgba(backgroundColor);
    if (parsedColor[3] === 1 && !bgWillChange) {
      parents.push(currentEl);
      return parents;
    }
    if (parsedColor[3] !== 0 || bgWillChange) {
      parents.push(currentEl);
    }
    currentEl = currentEl.parentElement;
  }
  return parents;
};
var WATCHER_CLASS = "va-background-watcher";
var watchElementBackground = (el, cb) => {
  el.className = WATCHER_CLASS + " " + el.className;
  el.addEventListener("transitionend", (e2) => {
    if (e2.target !== el) {
      return;
    }
    cb();
  });
  return () => {
    el.className = el.className.replace(WATCHER_CLASS, "");
    el.removeEventListener("transitionend", cb);
  };
};
var watchElementsBackground = (els, cb) => {
  const unwatchers = els.map((el) => watchElementBackground(el, cb));
  return () => {
    unwatchers.forEach((unwatch) => unwatch());
  };
};
var applyColors2 = (color1, color2) => {
  const weight = color2[3];
  if (weight === 1) {
    return color2;
  }
  if (weight === 0) {
    return color1;
  }
  const c1 = Math.round(color1[0] * (1 - weight) + color2[0] * weight);
  const c2 = Math.round(color1[1] * (1 - weight) + color2[1] * weight);
  const c3 = Math.round(color1[2] * (1 - weight) + color2[2] * weight);
  return [c1, c2, c3, 1];
};
var getColorFromElements = (els) => {
  let currentColor = [0, 0, 0, 0];
  for (let i2 = els.length - 1; i2 >= 0; i2--) {
    currentColor = applyColors2(currentColor, parseRgba(window.getComputedStyle(els[i2]).backgroundColor));
  }
  return currentColor;
};
var useElementBackground = (el) => {
  const color = ref("#000000");
  let unWatchAll = () => void 0;
  watchEffect(() => {
    unWatchAll();
    if (el.value) {
      const parents = getParentsWithBackground(el.value);
      unWatchAll = watchElementsBackground(parents, () => {
        color.value = toHex(getColorFromElements(parents));
      });
      color.value = toHex(getColorFromElements(parents));
    }
  });
  return color;
};

// node_modules/vuestic-ui/dist/es/src/composables/useCurrentElement.js
var useCurrentElement = (el) => {
  if (el) {
    return el;
  }
  const vm = getCurrentInstance();
  const currentEl = shallowRef();
  onMounted(() => {
    currentEl.value = vm.proxy.$el ?? void 0;
  });
  onUpdated(() => {
    currentEl.value = vm.proxy.$el ?? void 0;
  });
  onBeforeUnmount(() => {
    currentEl.value = vm.proxy.$el ?? void 0;
  });
  return currentEl;
};

// node_modules/vuestic-ui/dist/es/src/components/va-alert/useAlertStyles.js
var useAlertStyles = (props2) => {
  const { getColor } = useColors();
  const isTransparentBackground = computed(() => Boolean(props2.outline || props2.border));
  const { textColorComputed } = useTextColor(toRef(props2, "color"), isTransparentBackground);
  const colorComputed = computed(() => getColor(props2.color));
  const alertStyle = computed(() => {
    let background = colorComputed.value;
    let boxShadow = "none";
    if (props2.outline) {
      background = "transparent";
    }
    if (props2.border) {
      background = "var(--va-background-primary)";
      boxShadow = "var(--va-alert-box-shadow)";
    }
    return {
      border: props2.outline ? `1px solid ${colorComputed.value}` : "",
      padding: props2.dense ? "var(--va-alert-padding-y-dense) var(--va-alert-padding-x)" : "",
      backgroundColor: background,
      boxShadow
    };
  });
  const currentColor = useElementTextColor(useElementBackground(useCurrentElement()));
  const contentStyle = computed(() => {
    return {
      alignItems: props2.center ? "center" : "",
      color: props2.border || props2.outline ? currentColor.value : textColorComputed.value
    };
  });
  const titleStyle = computed(() => {
    return { color: textColorComputed.value };
  });
  const borderStyle = computed(() => ({
    backgroundColor: props2.borderColor ? getColor(props2.borderColor) : colorComputed.value
  }));
  return {
    alertStyle,
    contentStyle,
    titleStyle,
    borderStyle
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-alert/VaAlert.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaAlert.css";
var _sfc_main8 = defineComponent({
  name: "VaAlert",
  components: { VaIcon },
  emits: [...useStatefulEmits],
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Boolean, default: true },
    stateful: { type: Boolean, default: true },
    color: { type: String, default: "primary" },
    textColor: { type: String, default: "" },
    title: { type: String, default: "" },
    description: { type: String, default: "" },
    icon: { type: String, default: "" },
    closeText: { type: String, default: "" },
    closeIcon: { type: String, default: "close" },
    closeable: { type: Boolean, default: false },
    dense: { type: Boolean, default: false },
    outline: { type: Boolean, default: false },
    center: { type: Boolean, default: false },
    borderColor: { type: String, default: "" },
    border: {
      type: String,
      default: "",
      validator: (value) => ["top", "right", "bottom", "left", ""].includes(value)
    }
  },
  setup(props2, { slots, emit }) {
    const {
      contentStyle,
      titleStyle,
      alertStyle,
      borderStyle
    } = useAlertStyles(props2);
    const { valueComputed } = useStateful(props2, emit);
    const hide3 = () => {
      valueComputed.value = false;
    };
    const show = () => {
      valueComputed.value = true;
    };
    const hasIcon = computed(() => props2.icon || slots.icon);
    const hasTitle = computed(() => props2.title || slots.title);
    const borderClass = computed(() => `va-alert__border--${props2.border}`);
    const { tp, t: t2 } = useTranslation();
    return {
      tp,
      t: t2,
      contentStyle,
      titleStyle,
      alertStyle,
      borderStyle,
      valueComputed,
      hasIcon,
      hasTitle,
      borderClass,
      hide: hide3,
      show
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-alert/VaAlert.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaAlert.css";
var _hoisted_16 = {
  key: 1,
  class: "va-alert__close"
};
var _hoisted_24 = ["aria-label"];
function _sfc_render8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createBlock(Transition, { name: "fade" }, {
    default: withCtx(() => [
      _ctx.valueComputed ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "va-alert",
        style: normalizeStyle(_ctx.alertStyle),
        role: "alert"
      }, [
        createBaseVNode("div", {
          style: normalizeStyle(_ctx.borderStyle),
          class: normalizeClass([_ctx.borderClass, "va-alert__border"])
        }, null, 6),
        _ctx.hasIcon ? (openBlock(), createElementBlock("div", {
          key: 0,
          style: normalizeStyle(_ctx.contentStyle),
          class: "va-alert__icon",
          "aria-hidden": "true"
        }, [
          renderSlot(_ctx.$slots, "icon", {}, () => [
            createVNode(_component_va_icon, { name: _ctx.icon }, null, 8, ["name"])
          ])
        ], 4)) : createCommentVNode("", true),
        createBaseVNode("div", {
          style: normalizeStyle(_ctx.contentStyle),
          class: "va-alert__content"
        }, [
          _ctx.hasTitle ? (openBlock(), createElementBlock("div", {
            key: 0,
            style: normalizeStyle(_ctx.titleStyle),
            class: "va-alert__title"
          }, [
            renderSlot(_ctx.$slots, "title", {}, () => [
              createTextVNode(toDisplayString(_ctx.title), 1)
            ])
          ], 4)) : createCommentVNode("", true),
          createBaseVNode("span", null, [
            renderSlot(_ctx.$slots, "default", {}, () => [
              createTextVNode(toDisplayString(_ctx.$props.description), 1)
            ])
          ])
        ], 4),
        _ctx.closeable ? (openBlock(), createElementBlock("div", _hoisted_16, [
          createBaseVNode("div", {
            role: "button",
            class: "va-alert__close--closeable",
            tabindex: "0",
            "aria-label": _ctx.closeText || _ctx.t("closeAlert"),
            style: normalizeStyle(_ctx.contentStyle),
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.hide && _ctx.hide(...args)),
            onKeydown: [
              _cache[1] || (_cache[1] = withKeys((...args) => _ctx.hide && _ctx.hide(...args), ["space"])),
              _cache[2] || (_cache[2] = withKeys((...args) => _ctx.hide && _ctx.hide(...args), ["enter"]))
            ]
          }, [
            renderSlot(_ctx.$slots, "close", {}, () => [
              !_ctx.closeText ? (openBlock(), createBlock(_component_va_icon, {
                key: 0,
                name: _ctx.closeIcon
              }, null, 8, ["name"])) : createCommentVNode("", true),
              createTextVNode(" " + toDisplayString(_ctx.closeText), 1)
            ])
          ], 44, _hoisted_24)
        ])) : createCommentVNode("", true)
      ], 4)) : createCommentVNode("", true)
    ]),
    _: 3
  });
}
var _VaAlert = _export_sfc(_sfc_main8, [["render", _sfc_render8]]);

// node_modules/vuestic-ui/dist/es/src/components/va-alert/index.js
var VaAlert = withConfigTransport$1(_VaAlert);

// node_modules/vuestic-ui/dist/es/src/composables/useFixedBar.js
var useFixedBarProps = {
  hideOnScroll: { type: Boolean, default: false },
  fixed: { type: Boolean, default: false },
  bottom: { type: Boolean, default: false }
};
function useFixedBar(props2, isScrolledDown) {
  const isHiddenComputed = computed(() => isScrolledDown.value ? !!props2.hideOnScroll : false);
  const transformComputed = computed(() => {
    if (!props2.bottom && !isHiddenComputed.value) {
      return;
    }
    if (props2.bottom && isHiddenComputed.value) {
      return "translateY(100%)";
    }
    if (props2.bottom) {
      return props2.fixed ? "translateY(-100%)" : "translateY(0)";
    }
    return "translateY(-100%)";
  });
  const positionComputed = computed(() => {
    if (props2.fixed) {
      return "fixed";
    }
    return isHiddenComputed.value ? "absolute" : void 0;
  });
  const fixedBarStyleComputed = computed(() => {
    const result = {
      top: props2.bottom && (isHiddenComputed.value || props2.fixed) ? "100%" : void 0,
      transform: props2.hideOnScroll || props2.fixed ? transformComputed.value : void 0
    };
    positionComputed.value && Object.assign(result, { position: positionComputed.value });
    return result;
  });
  return { fixedBarStyleComputed };
}

// node_modules/vuestic-ui/dist/es/src/composables/useScroll.js
function getTargetElement(target) {
  if (!target) {
    throw new Error("No target was provided for `useScroll` hook!");
  }
  return typeof target === "string" ? document.querySelector(target) : target;
}
function setupScroll(fixed, target) {
  const scrollRoot = shallowRef();
  let targetElement;
  const isScrolledDown = ref(false);
  const prevScrollPosition = ref(0);
  const onScroll = (e2) => {
    const target2 = e2.target;
    const scrollValue = e2.target instanceof Window ? target2.scrollY : target2.scrollTop;
    isScrolledDown.value = prevScrollPosition.value < scrollValue;
    prevScrollPosition.value = scrollValue;
  };
  onMounted(() => {
    targetElement = fixed ? window : getTargetElement(target || scrollRoot.value);
    targetElement == null ? void 0 : targetElement.addEventListener("scroll", onScroll, fixed);
  });
  onBeforeUnmount(() => {
    targetElement == null ? void 0 : targetElement.removeEventListener("scroll", onScroll);
  });
  return { scrollRoot, isScrolledDown };
}

// node_modules/vuestic-ui/dist/es/src/components/va-app-bar/VaAppBar.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaAppBar.css";
var _sfc_main9 = defineComponent({
  name: "VaAppBar",
  props: {
    ...useFixedBarProps,
    ...useComponentPresetProp,
    gradient: { type: Boolean, default: false },
    target: { type: [Object, String], default: "" },
    shadowOnScroll: { type: Boolean, default: false },
    shadowColor: { type: String, default: "" },
    color: { type: String, default: "primary" }
  },
  setup(props2) {
    const { scrollRoot, isScrolledDown } = setupScroll(props2.fixed, props2.target);
    const { fixedBarStyleComputed } = useFixedBar(props2, isScrolledDown);
    const { getColor, getGradientBackground: getGradientBackground2, getBoxShadowColor: getBoxShadowColor2 } = useColors();
    const colorComputed = computed(() => getColor(props2.color));
    const { textColorComputed } = useTextColor(toRef(props2, "color"));
    const showShadowComputed = computed(() => isScrolledDown.value ? !!props2.shadowOnScroll : false);
    const shadowColorComputed = computed(() => getColor(props2.shadowColor, colorComputed.value));
    const computedShadow = computed(() => {
      const shadow = getBoxShadowColor2(props2.shadowColor ? shadowColorComputed.value : colorComputed.value);
      return showShadowComputed.value ? `var(--va-app-bar-shadow) ${shadow}` : "";
    });
    const computedStyle = computed(() => ({
      ...fixedBarStyleComputed.value,
      background: props2.gradient ? getGradientBackground2(colorComputed.value) : colorComputed.value,
      boxShadow: computedShadow.value,
      color: textColorComputed.value
    }));
    return { scrollRoot, computedStyle };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-app-bar/VaAppBar.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaAppBar.css";
function _sfc_render9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("header", {
    ref: "scrollRoot",
    role: "toolbar",
    class: "va-app-bar",
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 4);
}
var _VaAppBar = _export_sfc(_sfc_main9, [["render", _sfc_render9]]);

// node_modules/vuestic-ui/dist/es/src/components/va-app-bar/index.js
var VaAppBar = withConfigTransport$1(_VaAppBar);

// node_modules/vuestic-ui/dist/es/src/components/va-aspect-ratio/VaAspectRatio.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaAspectRatio.css";
var _sfc_main10 = defineComponent({
  name: "VaAspectRatio",
  props: {
    ...useComponentPresetProp,
    ratio: {
      type: [Number, String],
      default: "auto",
      validator: (v2) => {
        if (typeof v2 === "number") {
          return v2 > 0;
        }
        return v2 === "auto";
      }
    },
    contentHeight: { type: Number, default: 1 },
    contentWidth: { type: Number, default: 1 },
    maxWidth: {
      type: Number,
      default: 0,
      validator: (v2) => v2 >= 0
    }
  },
  setup(props2) {
    const aspectRatio = computed(() => {
      if (props2.ratio === "auto" && props2.contentHeight === 1 && props2.contentWidth === 1) {
        return 0;
      }
      if (!isNaN(+props2.ratio)) {
        return props2.ratio;
      }
      return props2.contentWidth / props2.contentHeight;
    });
    const stylesComputed = computed(() => {
      if (!aspectRatio.value) {
        return;
      }
      return { paddingBottom: `${1 / aspectRatio.value * 100}%` };
    });
    const maxWidthComputed = computed(() => props2.maxWidth ? `${props2.maxWidth}px` : void 0);
    return { stylesComputed, maxWidthComputed };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-aspect-ratio/VaAspectRatio.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaAspectRatio.css";
function _sfc_render10(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "va-aspect-ratio",
    style: normalizeStyle(`--va-max-width-computed: ${String(_ctx.maxWidthComputed)}`)
  }, [
    _ctx.stylesComputed ? (openBlock(), createElementBlock("div", {
      key: 0,
      style: normalizeStyle(_ctx.stylesComputed)
    }, null, 4)) : createCommentVNode("", true),
    renderSlot(_ctx.$slots, "default")
  ], 4);
}
var _VaAspectRatio = _export_sfc(_sfc_main10, [["render", _sfc_render10]]);

// node_modules/vuestic-ui/dist/es/src/components/va-aspect-ratio/index.js
var VaAspectRatio = withConfigTransport$1(_VaAspectRatio);

// node_modules/vuestic-ui/dist/es/src/components/va-fallback/VaFallback.vue_vue_type_script_lang.js
var _sfc_main11 = defineComponent({
  name: "VaFallback",
  props: {
    fallbackSrc: {
      type: String
    },
    fallbackText: {
      type: String
    },
    fallbackIcon: {
      type: String
    },
    fallbackRender: {
      type: Function
    }
  },
  components: { VaIcon },
  emits: ["fallback"],
  setup(props2, { emit }) {
    onMounted(() => {
      emit("fallback");
    });
    if (props2.fallbackIcon) {
      return () => h(VaIcon, {
        name: props2.fallbackIcon
      });
    }
    if (props2.fallbackSrc) {
      return () => h("img", {
        src: props2.fallbackSrc
      });
    }
    if (props2.fallbackRender) {
      return () => {
        var _a2;
        return h((_a2 = props2.fallbackRender) == null ? void 0 : _a2.call(props2));
      };
    }
    return () => h("span", props2.fallbackText);
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-fallback/index.js
var VaFallback = withConfigTransport$1(_sfc_main11);

// node_modules/vuestic-ui/dist/es/src/utils/component-options/resolve-component-props.js
function normalizeProps2(props2) {
  switch (true) {
    case Array.isArray(props2):
      return props2.reduce((acc, prop) => ({ ...acc, [prop]: null }), {});
    case (typeof props2 === "object" && props2 !== null):
      return props2;
    default:
      return {};
  }
}
function mergeProps2(to, from, optionsType = "props") {
  const { mixins, extends: extendsOptions } = from;
  extendsOptions && mergeProps2(to, extendsOptions, optionsType);
  mixins && mixins.forEach((m2) => mergeProps2(to, m2, optionsType));
  const props2 = normalizeProps2(from[optionsType]);
  for (const key in props2) {
    to[key] = props2[key];
  }
}
function getComponentOptions(component) {
  if (component.options) {
    return component.options;
  }
  if (component.__vccOpts || component.__b) {
    return { ...component.__vccOpts, ...component.__b };
  }
  return component;
}
function resolveProps(options, optionsType = "props") {
  const mixins = options.mixins ?? [];
  const extendsOptions = options.extends ?? [];
  const result = {};
  mergeProps2(result, extendsOptions, optionsType);
  for (let i2 = 0; i2 < mixins.length; i2++) {
    mergeProps2(result, mixins[i2], optionsType);
  }
  Object.assign(result, normalizeProps2(options[optionsType]));
  return result;
}
var getComponentProps = (component) => {
  return resolveProps(getComponentOptions(component));
};

// node_modules/vuestic-ui/dist/es/src/utils/component-options/extract-component-options.js
function extractComponentProps(component, ignoreProps) {
  const props2 = getComponentProps(component);
  if (ignoreProps) {
    return Object.keys(props2).reduce((acc, propName) => {
      if (ignoreProps.includes(propName)) {
        return acc;
      }
      if (props2[propName] === void 0) {
        return acc;
      }
      acc[propName] = typeof props2[propName] === "string" ? {} : props2[propName];
      return acc;
    }, {});
  }
  return props2;
}
function extractComponentEmits(component) {
  return [...new Set(component.emits)];
}

// node_modules/vuestic-ui/dist/es/src/utils/component-options/filter-props.js
var filterComponentProps = (childProps) => {
  const { props: props2 } = getCurrentInstance();
  return computed(() => {
    return Object.keys(childProps).reduce((acc, propName) => {
      acc[propName] = props2[propName];
      return acc;
    }, {});
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-avatar/VaAvatar.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaAvatar.css";
var VaFallbackProps = extractComponentProps(VaFallback);
var _sfc_main12 = defineComponent({
  name: "VaAvatar",
  components: { VaIcon, VaProgressCircle, VaFallback },
  props: {
    ...useLoadingProps,
    ...useSizeProps,
    ...useComponentPresetProp,
    ...VaFallbackProps,
    color: { type: String, default: "primary" },
    textColor: { type: String },
    square: { type: Boolean, default: false },
    fontSize: { type: String, default: "" },
    src: { type: String, default: null },
    icon: { type: String, default: "" },
    alt: { type: String, default: "" }
  },
  emits: ["error", "fallback"],
  setup(props2, { emit }) {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props2.color));
    const backgroundColorComputed = computed(() => {
      if (props2.loading || props2.src && !hasLoadError.value) {
        return void 0;
      }
      return colorComputed.value;
    });
    const { sizeComputed, fontSizeComputed } = useSize(props2, "VaAvatar");
    const { textColorComputed } = useTextColor(backgroundColorComputed);
    const computedStyle = computed(() => ({
      fontSize: props2.fontSize || fontSizeComputed.value
    }));
    const classesComputed = useBem("va-avatar", () => ({
      ...pick$1(props2, ["square"])
    }));
    const hasLoadError = ref(false);
    const onLoadError = (event) => {
      hasLoadError.value = true;
      emit("error", event);
    };
    watch(() => props2.src, () => {
      hasLoadError.value = false;
    });
    const avatarOptions = computed(() => ({
      hasError: hasLoadError.value,
      onError: onLoadError
    }));
    return {
      hasLoadError,
      sizeComputed,
      avatarOptions,
      computedStyle,
      colorComputed,
      classesComputed,
      textColorComputed,
      backgroundColorComputed,
      VaFallbackProps: filterComponentProps(VaFallbackProps),
      onLoadError
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-avatar/VaAvatar.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaAvatar.css";
var _hoisted_17 = ["src", "alt"];
function _sfc_render11(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_progress_circle = resolveComponent("va-progress-circle");
  const _component_va_fallback = resolveComponent("va-fallback");
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-avatar", _ctx.classesComputed]),
    style: normalizeStyle([_ctx.computedStyle, `--va-background-color-computed: ${String(_ctx.backgroundColorComputed)};--va-text-color-computed: ${String(_ctx.textColorComputed)};--va-size-computed: ${String(_ctx.sizeComputed)}`])
  }, [
    _ctx.$props.loading ? (openBlock(), createBlock(_component_va_progress_circle, {
      key: 0,
      size: _ctx.sizeComputed,
      color: _ctx.colorComputed,
      indeterminate: ""
    }, null, 8, ["size", "color"])) : renderSlot(_ctx.$slots, "default", normalizeProps(mergeProps({ key: 1 }, _ctx.avatarOptions)), () => [
      _ctx.$props.src && !_ctx.hasLoadError ? (openBlock(), createElementBlock("img", {
        key: 0,
        src: _ctx.$props.src,
        alt: _ctx.$props.alt,
        onError: _cache[0] || (_cache[0] = (...args) => _ctx.onLoadError && _ctx.onLoadError(...args))
      }, null, 40, _hoisted_17)) : _ctx.hasLoadError && _ctx.$props.src ? renderSlot(_ctx.$slots, "fallback", { key: 1 }, () => [
        createVNode(_component_va_fallback, mergeProps(_ctx.VaFallbackProps, {
          onFallback: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("fallback"))
        }), null, 16)
      ]) : _ctx.$props.icon ? (openBlock(), createBlock(_component_va_icon, {
        key: 2,
        name: _ctx.$props.icon
      }, null, 8, ["name"])) : renderSlot(_ctx.$slots, "fallback", { key: 3 }, () => [
        createVNode(_component_va_fallback, mergeProps(_ctx.VaFallbackProps, {
          onFallback: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("fallback"))
        }), null, 16)
      ])
    ])
  ], 6);
}
var _VaAvatar = _export_sfc(_sfc_main12, [["render", _sfc_render11]]);

// node_modules/vuestic-ui/dist/es/src/components/va-avatar/index.js
var VaAvatar = withConfigTransport$1(_VaAvatar);

// node_modules/vuestic-ui/dist/es/src/components/va-avatar-group/VaAvatarGroup.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaAvatarGroup.css";
var VaAvatarProps = extractComponentProps(VaAvatar);
var _sfc_main13 = defineComponent({
  name: "VaAvatarGroup",
  components: {
    VaAvatar
  },
  props: {
    ...useSizeProps,
    ...useComponentPresetProp,
    ...VaAvatarProps,
    max: {
      type: Number,
      default: 0
    },
    vertical: {
      type: Boolean,
      default: false
    },
    options: {
      type: Array,
      default: () => []
    },
    /** If there are more avatars that can be displayed we show rest number. This prop changes color of rest indicator. */
    restColor: {
      type: String,
      default: "secondary"
    }
  },
  setup(props2) {
    const classComputed = useBem("va-avatar-group", () => ({
      ...pick$1(props2, ["vertical"])
    }));
    const maxOptions = computed(() => props2.max && props2.max <= props2.options.length ? props2.options.slice(0, props2.max) : props2.options);
    const visibleItemsCount = computed(() => props2.max ? props2.max + 1 : 1);
    const restOptionsCount = computed(() => {
      const hasOptions = props2.options.length > 0;
      const canAddMoreOptions = maxOptions.value.length < props2.options.length;
      const remainingOptions = props2.options.length - (props2.max || 0);
      return hasOptions && canAddMoreOptions ? remainingOptions : 0;
    });
    const { sizeComputed, fontSizeComputed } = useSize(props2, "VaAvatarGroup");
    const filteredAvatarProps = filterComponentProps(VaAvatarProps);
    const avatarProps = computed(() => ({
      ...filteredAvatarProps.value,
      fontSize: fontSizeComputed.value,
      size: sizeComputed.value
    }));
    return {
      classComputed,
      maxOptions,
      visibleItemsCount,
      restOptionsCount,
      avatarProps
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-avatar-group/VaAvatarGroup.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaAvatarGroup.css";
function _sfc_render12(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_avatar = resolveComponent("va-avatar");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-avatar-group", _ctx.classComputed]),
    role: "group"
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.maxOptions, (option, idx) => {
      return openBlock(), createBlock(_component_va_avatar, mergeProps({ key: idx }, { ..._ctx.avatarProps, ...option }, { role: "listitem" }), null, 16);
    }), 128)),
    _ctx.restOptionsCount > 0 ? renderSlot(_ctx.$slots, "rest", normalizeProps(mergeProps({ key: 0 }, _ctx.avatarProps)), () => [
      createVNode(_component_va_avatar, mergeProps(_ctx.avatarProps, {
        color: _ctx.restColor,
        class: "va-avatar-group__rest",
        role: "listitem"
      }), {
        default: withCtx(() => [
          createTextVNode(" +" + toDisplayString(_ctx.restOptionsCount), 1)
        ]),
        _: 1
      }, 16, ["color"])
    ]) : createCommentVNode("", true)
  ], 2);
}
var _VaAvatarGroup = _export_sfc(_sfc_main13, [["render", _sfc_render12]]);

// node_modules/vuestic-ui/dist/es/src/components/va-avatar-group/index.js
var VaAvatarGroup = withConfigTransport$1(_VaAvatarGroup);

// node_modules/vuestic-ui/dist/es/src/components/va-backtop/VaBacktop.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaBacktop.css";
var _sfc_main14 = defineComponent({
  name: "VaBacktop",
  components: { VaButton },
  props: {
    ...useComponentPresetProp,
    target: {
      type: [Object, String],
      default: void 0
    },
    visibilityHeight: { type: Number, default: 300 },
    speed: { type: Number, default: 50 },
    verticalOffset: { type: String, default: "1rem" },
    horizontalOffset: { type: String, default: "1rem" },
    color: { type: String, default: "" },
    horizontalPosition: {
      type: String,
      default: "right",
      validator: (value) => ["right", "left"].includes(value)
    },
    verticalPosition: {
      type: String,
      default: "bottom",
      validator: (value) => ["bottom", "top"].includes(value)
    },
    ariaLabel: { type: String, default: "$t:backToTop" }
  },
  setup(props2) {
    const targetScrollValue = ref(0);
    const computedStyle = computed(() => ({
      [props2.verticalPosition]: props2.verticalOffset,
      [props2.horizontalPosition]: props2.horizontalOffset
    }));
    let targetElement;
    const getTargetElement2 = () => {
      if (!props2.target) {
        return window;
      }
      if (typeof props2.target === "string") {
        const target = document.querySelector(props2.target);
        if (!target) {
          warn(`Target element [${props2.target}] is not found, falling back to window.`);
          return window;
        }
        return target;
      }
      return props2.target;
    };
    const scrolled = ref(false);
    const interval = ref(0);
    const scrollToTop = () => {
      if (scrolled.value) {
        return;
      }
      scrolled.value = true;
      if (targetElement instanceof Window) {
        window.scrollTo({
          top: 0,
          behavior: "smooth"
        });
        return;
      }
      interval.value = window.setInterval(() => {
        if (targetElement instanceof Element) {
          if (targetElement.scrollTop === 0) {
            clearInterval(interval.value);
            scrolled.value = false;
          } else {
            const next = Math.floor(targetElement.scrollTop - props2.speed);
            targetElement.scrollTo(0, next);
          }
        }
      }, 15);
    };
    const handleScroll = () => {
      targetScrollValue.value = targetElement instanceof Window ? targetElement.scrollY : targetElement.scrollTop;
    };
    const server = isServer();
    const visible = computed(() => {
      if (server) {
        return false;
      }
      return targetScrollValue.value > props2.visibilityHeight;
    });
    if (!server) {
      onMounted(() => {
        targetElement = getTargetElement2();
        targetElement.addEventListener("scroll", handleScroll, true);
      });
      onBeforeUnmount(() => targetElement == null ? void 0 : targetElement.removeEventListener("scroll", handleScroll));
    }
    return {
      computedStyle,
      visible,
      scrollToTop,
      ...useTranslation()
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-backtop/VaBacktop.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaBacktop.css";
var _hoisted_18 = ["aria-label"];
function _sfc_render13(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  return _ctx.visible ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: "va-backtop",
    role: "button",
    "aria-label": _ctx.tp(_ctx.$props.ariaLabel),
    tabindex: "1",
    style: normalizeStyle(_ctx.computedStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.scrollToTop && _ctx.scrollToTop(...args)),
    onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.scrollToTop && _ctx.scrollToTop(...args), ["stop"]), ["enter"]))
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      createVNode(_component_va_button, {
        "aria-hidden": "true",
        icon: "va-arrow-up",
        color: _ctx.color
      }, null, 8, ["color"])
    ])
  ], 44, _hoisted_18)) : createCommentVNode("", true);
}
var _VaBacktop = _export_sfc(_sfc_main14, [["render", _sfc_render13]]);

// node_modules/vuestic-ui/dist/es/src/components/va-backtop/index.js
var VaBacktop = withConfigTransport$1(_VaBacktop);

// node_modules/vuestic-ui/dist/es/src/composables/usePlacementAliases.js
var verticalPlacement = ["top", "bottom"];
var horizontalPlacement = ["left", "right"];
var placementPosition = [...verticalPlacement, ...horizontalPlacement];
var placementAlignment = ["start", "end", "center"];
var placementsPositions = placementPosition.reduce((acc, position) => {
  acc.push(position);
  placementAlignment.forEach((alignment) => acc.push(`${position}-${alignment}`));
  return acc;
}, ["auto"]);
var placementAliasesPositions = verticalPlacement.reduce((acc, yPosition) => {
  horizontalPlacement.forEach((xPosition) => {
    acc.push(`${yPosition}-${xPosition}`);
    acc.push(`${xPosition}-${yPosition}`);
  });
  return acc;
}, []);
var placementsPositionsWithAliases = [...placementsPositions, ...placementAliasesPositions];
var aliasToPlacement = {
  "top-left": "top-start",
  "left-top": "top-start",
  "top-right": "top-end",
  "right-top": "top-end",
  "bottom-left": "bottom-start",
  "left-bottom": "bottom-start",
  "bottom-right": "bottom-end",
  "right-bottom": "bottom-end"
};
var usePlacementAliasesProps = {
  placement: {
    type: String,
    default: "auto",
    validator: (position) => placementsPositionsWithAliases.includes(position)
  }
};
var usePlacementAliases = (props2) => {
  const placementArray = computed(() => {
    const placement = aliasToPlacement[props2.placement] || props2.placement;
    return placement.split("-");
  });
  const position = computed(() => {
    const position2 = placementArray.value[0];
    return position2 === "auto" ? "bottom" : position2;
  });
  const align = computed(() => {
    return placementArray.value[1] || "center";
  });
  return { position, align };
};

// node_modules/vuestic-ui/dist/es/src/composables/useParsableMeasure.js
var useParsableMeasure = () => {
  const isParsableMeasure2 = (value) => {
    if (typeof value === "string") {
      return !isNaN(+value) || value.endsWith("px") || value.endsWith("rem");
    }
    return false;
  };
  const isParsablePositiveMeasure2 = (value) => {
    if (typeof value === "number") {
      return value >= 0;
    }
    return isParsableMeasure2(value) && parseInt(value) >= 0;
  };
  const parseSizeValue3 = (value, pageFontSize = 16) => {
    const valueUnref = unref(value);
    if (typeof valueUnref === "string") {
      const parsedValue = parseInt(valueUnref);
      if (isNaN(parsedValue)) {
        return 0;
      }
      return valueUnref.endsWith("rem") ? parsedValue * unref(pageFontSize) : parsedValue;
    }
    return valueUnref;
  };
  return { isParsableMeasure: isParsableMeasure2, isParsablePositiveMeasure: isParsablePositiveMeasure2, parseSizeValue: parseSizeValue3 };
};

// node_modules/vuestic-ui/dist/es/src/components/va-badge/hooks/useFloatingPositionStyles.js
var { isParsableMeasure, parseSizeValue } = useParsableMeasure();
var useFloatingPositionProps = {
  overlap: { type: Boolean, default: false },
  placement: {
    type: String,
    default: "top-end",
    validator: (position) => placementsPositionsWithAliases.includes(position)
  },
  offset: {
    type: [Number, String, Array],
    default: 0,
    validator: (value) => {
      if (Array.isArray(value)) {
        return value.every(isParsableMeasure);
      }
      if (typeof value === "string") {
        return isParsableMeasure(value);
      }
      return !isNaN(value);
    }
  }
};
var useFloatingPosition = (props2, floating) => {
  if (!floating.value) {
    return {};
  }
  const { position, align } = usePlacementAliases(props2);
  const alignmentShiftComputed = computed(() => {
    const alignOptions = {
      start: props2.overlap ? "-50%" : "-100%",
      center: "-50%",
      end: props2.overlap ? "-50%" : "0%"
    };
    return alignOptions[align.value];
  });
  const offsetMarginComputed = computed(() => {
    if (!props2.offset) {
      return {};
    }
    const mainAxis = ["left", "right"].includes(position.value) ? "top" : "left";
    const crossAxis = mainAxis === "top" ? "left" : "top";
    if (Array.isArray(props2.offset)) {
      const [x2, y2] = props2.offset.map(parseSizeValue);
      return {
        [`margin-${mainAxis}`]: `${x2}px`,
        [`margin-${crossAxis}`]: `${y2}px`
      };
    }
    const offset2 = parseSizeValue(props2.offset);
    return {
      [`margin-${crossAxis}`]: `${offset2}px`
    };
  });
  const alignmentComputed = computed(() => {
    const mainAxis = ["left", "right"].includes(position.value) ? "top" : "left";
    const crossAxis = mainAxis === "top" ? "left" : "top";
    let shiftValue = "0%";
    if (crossAxis === "top" && position.value === "bottom") {
      shiftValue = "100%";
    }
    if (crossAxis === "left" && position.value === "right") {
      shiftValue = "100%";
    }
    const alignmentOptions = {
      start: { [mainAxis]: "0%", [crossAxis]: shiftValue },
      center: { [mainAxis]: "50%", [crossAxis]: shiftValue },
      end: { [mainAxis]: "100%", [crossAxis]: shiftValue }
    };
    return alignmentOptions[align.value];
  });
  const transformComputed = computed(() => {
    const coords = {
      top: {
        x: alignmentShiftComputed.value,
        y: props2.overlap ? "-50%" : "-100%"
      },
      bottom: {
        x: alignmentShiftComputed.value,
        y: props2.overlap ? "-50%" : "0%"
      },
      left: {
        x: props2.overlap ? "-50%" : "-100%",
        y: alignmentShiftComputed.value
      },
      right: {
        x: props2.overlap ? "-50%" : "0%",
        y: alignmentShiftComputed.value
      }
    };
    const { x: x2, y: y2 } = coords[position.value];
    return { transform: `translate(${x2}, ${y2})` };
  });
  return computed(() => ({
    ...alignmentComputed.value,
    ...transformComputed.value,
    ...offsetMarginComputed.value
  }));
};

// node_modules/vuestic-ui/dist/es/src/composables/useDeprecated.js
var OPTIONS_LIST = {
  props: "prop",
  attrs: "prop",
  slots: "slot"
};
var useDeprecated = (deprecatedList, deprecationSource = ["props", "attrs"]) => {
  if (!isDev) {
    return void 0;
  }
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("`useDeprecated` hook must be used only inside of setup function!");
  }
  const instanceName = instance.type.name;
  const deprecatedItems = unref(deprecatedList);
  deprecationSource.every((source) => {
    var _a2;
    const option = OPTIONS_LIST[source];
    const throwWarning = (key) => console.warn(`The '${key}' ${option} (${instanceName} component) is deprecated! Please, check the documentation.`);
    if (source === "props") {
      const propsOptions = ((_a2 = instance.propsOptions) == null ? void 0 : _a2[0]) || {};
      const propsValues = instance.props || {};
      deprecatedItems.forEach((propName) => {
        propsOptions[propName] && propsValues[propName] !== propsOptions[propName].default && throwWarning(propName);
      });
      return true;
    }
    Object.keys({ ...instance[source] }).forEach((key) => {
      if (deprecatedItems.includes(key)) {
        throwWarning(key);
      }
    });
    return true;
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-badge/VaBadge.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaBadge.css";
var _sfc_main15 = defineComponent({
  name: "VaBadge",
  props: {
    ...useComponentPresetProp,
    ...useFloatingPositionProps,
    color: { type: String, default: "danger" },
    textColor: { type: String },
    text: { type: [String, Number], default: "" },
    multiLine: { type: Boolean, default: false },
    visibleEmpty: { type: Boolean, default: false },
    dot: { type: Boolean, default: false },
    // TODO: Remove after 1.8.0
    transparent: { type: Boolean, default: false }
  },
  setup(props2, { slots }) {
    useDeprecated(["transparent"]);
    const isEmpty = computed(() => !(props2.text || props2.visibleEmpty || props2.dot || slots.text));
    const isFloating = computed(() => !!(slots.default || props2.dot));
    const badgeClass = useBem("va-badge", () => ({
      ...pick$1(props2, ["visibleEmpty", "dot", "multiLine"]),
      empty: isEmpty.value,
      floating: isFloating.value
    }));
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props2.color));
    const { textColorComputed } = useTextColor(colorComputed);
    const positionStylesComputed = useFloatingPosition(props2, isFloating);
    const stylesComputed = computed(() => ({
      color: textColorComputed.value,
      borderColor: colorComputed.value,
      backgroundColor: colorComputed.value,
      opacity: props2.transparent ? 0.5 : 1,
      ...unref(positionStylesComputed)
    }));
    const ariaLabelledByComputed = computed(() => props2.text ? String(props2.text) : void 0);
    return {
      badgeClass,
      stylesComputed,
      ariaLabelledByComputed
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-badge/VaBadge.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaBadge.css";
var _hoisted_19 = ["aria-labelledby"];
var _hoisted_25 = { class: "va-badge__text" };
function _sfc_render14(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-badge", _ctx.badgeClass]),
    role: "status",
    "aria-labelledby": _ctx.ariaLabelledByComputed
  }, [
    createBaseVNode("span", {
      class: "va-badge__text-wrapper",
      style: normalizeStyle(_ctx.stylesComputed)
    }, [
      createBaseVNode("span", _hoisted_25, [
        renderSlot(_ctx.$slots, "text", {}, () => [
          createTextVNode(toDisplayString(_ctx.text), 1)
        ])
      ])
    ], 4),
    renderSlot(_ctx.$slots, "default")
  ], 10, _hoisted_19);
}
var _VaBadge = _export_sfc(_sfc_main15, [["render", _sfc_render14]]);

// node_modules/vuestic-ui/dist/es/src/components/va-badge/index.js
var VaBadge = withConfigTransport$1(_VaBadge);

// node_modules/vuestic-ui/dist/es/src/utils/has-own-property.js
var hasOwnProperty2 = (object, key) => {
  return Object.prototype.hasOwnProperty.call(object, key);
};

// node_modules/vuestic-ui/dist/es/src/utils/resolveSlot.js
var resolveSlot = (slot) => {
  return slot && isFunction$4(slot) ? slot() : slot;
};

// node_modules/vuestic-ui/dist/es/src/composables/useAlign.js
var useAlignProps = {
  align: {
    type: String,
    default: "left"
  },
  vertical: {
    type: Boolean,
    default: false
  }
};
var horizontalMap = {
  left: "flex-start",
  center: "center",
  right: "flex-end",
  between: "space-between",
  around: "space-around"
};
var verticalMap = {
  left: "flex-start",
  center: "center",
  right: "flex-end",
  stretch: "stretch"
};
var justify = (align, vertical) => {
  return vertical ? "center" : align ? horizontalMap[align] : "flex-start";
};
var items = (align, vertical) => {
  return vertical ? verticalMap[align] : "center";
};
function useAlign(props2) {
  const alignComputed = computed(() => {
    return {
      display: "flex",
      flexDirection: props2.vertical ? "column" : "row",
      justifyContent: justify(props2.align, props2.vertical),
      alignItems: items(props2.align, props2.vertical)
    };
  });
  return {
    alignComputed
  };
}

// node_modules/vuestic-ui/dist/es/src/components/va-breadcrumbs/VaBreadcrumbs.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaBreadcrumbs.css";
var _sfc_main16 = defineComponent({
  name: "VaBreadcrumbs",
  props: {
    ...useAlignProps,
    ...useComponentPresetProp,
    separator: { type: String, default: "/" },
    color: { type: String, default: null },
    disabledColor: { type: String, default: "secondary" },
    activeColor: { type: String, default: null },
    separatorColor: { type: String, default: null },
    ariaLabel: { type: String, default: "$t:breadcrumbs" }
  },
  setup(props2, { slots }) {
    const { alignComputed } = useAlign(props2);
    const { getColor } = useColors();
    const computedThemesSeparatorColor = computed(() => {
      return props2.separatorColor ? getColor(props2.separatorColor) : null;
    });
    const computedThemesColor = computed(() => props2.color ? getColor(props2.color) : null);
    const computedThemesActiveColor = computed(() => {
      return props2.activeColor ? getColor(props2.activeColor) : null;
    });
    const childNodeFilter = (result, node) => {
      const nodes = node && node.type === Fragment && node.children ? node.children : [node];
      return [
        ...result,
        ...nodes.filter((node2) => {
          var _a2, _b;
          return !!((_b = (_a2 = node2 == null ? void 0 : node2.type) == null ? void 0 : _a2.name) == null ? void 0 : _b.match(/VaBreadcrumbsItem$/));
        })
      ];
    };
    const createSeparatorComponent = () => {
      const separatorNode = resolveSlot(slots.separator) || [props2.separator];
      return h("span", {
        "aria-hidden": true,
        class: ["va-breadcrumbs__separator"],
        style: [{ color: computedThemesSeparatorColor.value }]
      }, separatorNode);
    };
    const isDisabledChild = (child) => {
      const childPropData = child == null ? void 0 : child.props;
      if (!childPropData || !hasOwnProperty2(childPropData, "disabled")) {
        return false;
      }
      if (childPropData.disabled === "") {
        return true;
      }
      return Boolean(childPropData.disabled);
    };
    const isAllChildLinks = ref(true);
    const getChildren = () => {
      const defaultSlotContent = resolveSlot(slots.default);
      if (!defaultSlotContent) {
        return;
      }
      const childNodes = defaultSlotContent.reduce(childNodeFilter, []) || [];
      const childNodesLength = childNodes.length;
      const isLastIndexChildNodes = (index) => index === childNodesLength - 1;
      const isChildLink = (child) => {
        const childPropData = child == null ? void 0 : child.props;
        if (!childPropData || !hasOwnProperty2(childPropData, "to")) {
          return false;
        }
        return !!(childPropData.to && !childPropData.disabled);
      };
      const createChildComponent = (child, index) => h(
        "span",
        {
          class: ["va-breadcrumbs__item", { "va-breadcrumbs__item--disabled": isDisabledChild(child) }],
          "aria-current": isLastIndexChildNodes(index) && isChildLink(child) ? "location" : false,
          style: {
            color: isDisabledChild(child) ? getColor(props2.disabledColor) : isLastIndexChildNodes(index) ? computedThemesActiveColor.value : computedThemesColor.value
          }
        },
        [child]
      );
      const children = [];
      if (childNodesLength) {
        childNodes.forEach((child, index) => {
          if (isAllChildLinks.value && !isChildLink(child)) {
            isAllChildLinks.value = false;
          }
          children.push(createChildComponent(child, index));
          if (!isLastIndexChildNodes(index)) {
            children.push(createSeparatorComponent());
          }
        });
      }
      return children;
    };
    const { tp } = useTranslation();
    return () => h("div", {
      class: "va-breadcrumbs",
      style: alignComputed.value,
      role: isAllChildLinks.value ? "navigation" : void 0,
      "aria-label": isAllChildLinks.value ? tp(props2.ariaLabel) : void 0
    }, getChildren());
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-breadcrumbs/VaBreadcrumbsItem/VaBreadcrumbsItem.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaBreadcrumbsItem.css";
var _sfc_main17 = defineComponent({
  name: "VaBreadcrumbsItem",
  props: {
    ...useRouterLinkProps,
    disabled: { type: Boolean, default: false },
    label: { type: String, default: "" }
  },
  setup: (props2) => {
    const { tagComputed, hrefComputed, isLinkTag } = useRouterLink(props2);
    const classComputed = computed(() => ({
      "va-breadcrumb-item--link": isLinkTag.value
    }));
    return { tagComputed, hrefComputed, classComputed };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-breadcrumbs/VaBreadcrumbsItem/VaBreadcrumbsItem.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaBreadcrumbsItem.css";
function _sfc_render15(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
    class: normalizeClass(["va-breadcrumb-item", _ctx.classComputed]),
    "active-class": _ctx.$props.activeClass,
    href: _ctx.hrefComputed,
    to: _ctx.$props.to,
    target: _ctx.$props.target,
    replace: _ctx.$props.replace,
    append: _ctx.$props.append,
    exact: _ctx.$props.exact,
    "exact-active-class": _ctx.$props.exactActiveClass
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ]),
    _: 3
  }, 8, ["class", "active-class", "href", "to", "target", "replace", "append", "exact", "exact-active-class"]);
}
var _VaBreadcrumbsItem = _export_sfc(_sfc_main17, [["render", _sfc_render15]]);

// node_modules/vuestic-ui/dist/es/src/components/va-breadcrumbs/index.js
var VaBreadcrumbsItem = withConfigTransport$1(_VaBreadcrumbsItem);
var VaBreadcrumbs = withConfigTransport$1(_sfc_main16);

// node_modules/vuestic-ui/dist/es/src/components/va-config/hooks/useGlobalConfigProvider.js
var useGlobalConfigProvider = (next) => {
  const { globalConfig, mergeGlobalConfig, setGlobalConfig, getGlobalConfig } = useGlobalConfig();
  const nextChain = computed(() => {
    var _a2;
    const gcCopy = cloneDeep$1(globalConfig.value);
    const compiledCopy = {
      ...gcCopy,
      colors: makeColorsConfig(gcCopy.colors)
    };
    const config = mergeDeep(compiledCopy, next.value);
    if ((_a2 = next.value.colors) == null ? void 0 : _a2.variables) {
      Object.keys(next.value.colors.variables).forEach((key) => {
        config.colors.variables[key] = next.value.colors.variables[key];
      });
    }
    return config;
  });
  provide(GLOBAL_CONFIG, {
    mergeGlobalConfig,
    setGlobalConfig,
    getGlobalConfig,
    globalConfig: nextChain
  });
  return nextChain;
};

// node_modules/vuestic-ui/dist/es/src/utils/headless.js
var toNode = (v2, attrs) => {
  if (!v2) {
    return null;
  }
  if (!("type" in v2) || v2.type === Text || typeof v2 === "string") {
    return h("div", attrs, v2);
  }
  if (v2.type === Comment) {
    return v2;
  }
  if ("$el" in v2) {
    return toNode(v2.$el, attrs);
  }
  if (v2.type === Suspense) {
    return h(v2.ssContent, attrs);
  }
  if (v2.type === Teleport) {
    if (v2.children === null) {
      return v2;
    }
    const anchor = toNode(v2.children[0], attrs);
    if (anchor) {
      v2.children[0] = h(anchor, attrs);
    }
    return v2;
  }
  if (v2.type === Fragment) {
    if (v2.children === null) {
      return v2;
    }
    if (v2.children.length === 1) {
      return h(Fragment, v2.props, [toNode(v2.children[0], attrs)]);
    }
    return h("div", attrs, v2);
  }
  if (typeof v2.type.render === "function") {
    const component = h(v2);
    if (Array.isArray(component.children) && component.children.length > 1) {
      return h("div", attrs, component.children);
    }
  }
  return h(v2, attrs);
};
var renderSlotNode = (slot, slotBind = {}, nodeAttributes = {}) => {
  const children = slot == null ? void 0 : slot(slotBind);
  if (!children) {
    return null;
  }
  const nonCommentChildren = children.filter((v2) => v2.type !== Comment);
  if (nonCommentChildren.length === 0) {
    return null;
  }
  if (nonCommentChildren.length === 1) {
    return toNode(nonCommentChildren[0], nodeAttributes);
  }
  return h("div", nodeAttributes, children);
};
var renderSlotNodes = (slot, slotBind = {}, nodeAttributes = {}) => {
  const children = slot == null ? void 0 : slot(slotBind);
  if (!children) {
    return null;
  }
  return children.map((v2) => toNode(v2, nodeAttributes));
};

// node_modules/vuestic-ui/dist/es/src/components/va-config/VaConfig.vue_vue_type_script_lang.js
var CssVarsRenderer = defineComponent({
  name: "VaCssVarsRenderer",
  inheritAttrs: false,
  setup(props2, { slots, attrs }) {
    const { colorsToCSSVariable, colors } = useColors();
    const style = computed(() => {
      return colorsToCSSVariable(colors);
    });
    return () => h(Fragment, attrs, renderSlotNodes(slots.default, {}, {
      style: style.value
    }) || void 0);
  }
});
var _sfc_main18 = defineComponent({
  name: "VaConfig",
  components: { CssVarsRenderer },
  props: {
    ...useComponentPresetProp,
    components: { type: Object, default: () => ({}) },
    colors: { type: Object },
    i18n: { type: Object }
  },
  inheritAttrs: false,
  setup(props2) {
    const prevChain = useLocalConfig();
    const nextChain = computed(() => [...prevChain.value, props2.components]);
    provideLocalConfig(nextChain);
    const newConfig = useGlobalConfigProvider(computed(() => {
      const config = {};
      if (props2.colors) {
        config.colors = props2.colors;
      }
      if (props2.i18n) {
        config.i18n = props2.i18n;
      }
      return config;
    }));
    const doRenderCssVars = computed(() => {
      return Boolean(props2.colors);
    });
    return {
      newConfig,
      doRenderCssVars
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-config/VaConfig.js
function _sfc_render16(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CssVarsRenderer = resolveComponent("CssVarsRenderer");
  return _ctx.doRenderCssVars ? (openBlock(), createBlock(_component_CssVarsRenderer, normalizeProps(mergeProps({ key: 0 }, _ctx.$attrs)), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16)) : renderSlot(_ctx.$slots, "default", { key: 1 });
}
var VaConfig = _export_sfc(_sfc_main18, [["render", _sfc_render16]]);

// node_modules/vuestic-ui/dist/es/src/components/va-button-group/VaButtonGroup.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaButtonGroup.css";
var VaButtonProps = omit$1(extractComponentProps(VaButton), ["block", "gradient"]);
var _sfc_main19 = defineComponent({
  name: "VaButtonGroup",
  components: { VaConfig },
  props: {
    ...VaButtonProps,
    ...useComponentPresetProp,
    grow: { type: Boolean, default: false },
    gradient: { type: Boolean, default: false }
  },
  setup: (props2) => {
    const { getColor, getGradientBackground: getGradientBackground2 } = useColors();
    const colorComputed = computed(() => getColor(props2.color));
    const { textColorComputed } = useTextColor(colorComputed);
    const filteredProps = filterComponentProps(VaButtonProps);
    const buttonConfig = computed(() => ({
      VaButton: {
        ...filteredProps.value,
        ...props2.gradient && {
          color: "#00000000",
          textColor: textColorComputed.value
        }
      }
    }));
    const computedClass = useBem("va-button-group", () => ({
      square: !props2.round,
      grow: props2.grow,
      small: props2.size === "small",
      large: props2.size === "large"
    }));
    const backgroundColor = computed(
      () => props2.gradient ? getGradientBackground2(colorComputed.value) : "transparent"
    );
    return { buttonConfig, computedClass, backgroundColor };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-button-group/VaButtonGroup.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaButtonGroup.css";
function _sfc_render17(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_config = resolveComponent("va-config");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-button-group", _ctx.computedClass]),
    style: normalizeStyle(`--va-background-color: ${String(_ctx.backgroundColor)}`)
  }, [
    createVNode(_component_va_config, { components: _ctx.buttonConfig }, {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "default")
      ]),
      _: 3
    }, 8, ["components"])
  ], 6);
}
var _VaButtonGroup = _export_sfc(_sfc_main19, [["render", _sfc_render17]]);

// node_modules/vuestic-ui/dist/es/src/components/va-button-group/index.js
var VaButtonGroup = withConfigTransport$1(_VaButtonGroup);

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/hooks/useDropdownNavigation.js
var isTyping = (e2) => {
  const target = e2.target;
  if (!(target.tagName === "INPUT" || target.tagName === "TEXTAREA")) {
    return false;
  }
  if (target.attributes.getNamedItem("readonly")) {
    return false;
  }
  return true;
};
var openKey = ["ArrowDown", "ArrowUp", "Enter", "Space"];
var useKeyboardNavigation = (anchorRef, isOpened) => {
  useEvent("keydown", (e2) => {
    if (isTyping(e2)) {
      return;
    }
    if (!openKey.includes(e2.key)) {
      return;
    }
    isOpened.value = !isOpened.value;
    e2.preventDefault();
  }, anchorRef);
  useEvent("keydown", (e2) => {
    if (e2.key === "Escape" && isOpened.value) {
      isOpened.value = false;
      e2.preventDefault();
    }
  }, true);
};
var useMouseNavigation = (anchorRef, listeners) => {
  useEvent(["click", "contextmenu", "dblclick"], (e2) => {
    if (isTyping(e2)) {
      return;
    }
    listeners[e2.type](e2);
  }, anchorRef);
  useEvent(["mouseleave", "mouseenter"], (e2) => {
    listeners[e2.type](e2);
  }, anchorRef);
};

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/hooks/useAnchorSelector.js
var useAnchorSelector = (props2) => {
  const anchorRef = ref();
  const document2 = useDocument();
  const isMounted = useIsMounted();
  const computedAnchorRef = computed({
    set(v2) {
      anchorRef.value = unwrapEl(v2);
    },
    get() {
      var _a2, _b, _c;
      isMounted.value;
      if (typeof props2.anchor === "string") {
        return ((_a2 = document2.value) == null ? void 0 : _a2.querySelector(props2.anchor)) ?? anchorRef.value;
      }
      if (typeof props2.anchor === "object") {
        return props2.anchor;
      }
      if (props2.anchorSelector) {
        return ((_b = document2.value) == null ? void 0 : _b.querySelector(props2.anchorSelector)) ?? anchorRef.value;
      } else if (props2.innerAnchorSelector && anchorRef.value) {
        return ((_c = anchorRef.value) == null ? void 0 : _c.querySelector(props2.innerAnchorSelector)) ?? anchorRef.value;
      }
      return anchorRef.value;
    }
  });
  return {
    anchorRef: computedAnchorRef
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/hooks/useCursorAnchor.js
var useCursorAnchor = (anchorRef, noUpdate) => {
  const position = reactive({ x: 0, y: 0 });
  useEvent(["mousemove", "mousedown", "mouseup"], (e2) => {
    var _a2;
    if (noUpdate.value) {
      return;
    }
    const { x: x2, y: y2 } = ((_a2 = anchorRef.value) == null ? void 0 : _a2.getBoundingClientRect()) ?? { x: 0, y: 0 };
    position.x = e2.clientX - x2;
    position.y = e2.clientY - y2;
  }, anchorRef);
  return computed(() => {
    return {
      getBoundingClientRect() {
        var _a2;
        const { x: x2, y: y2 } = ((_a2 = anchorRef.value) == null ? void 0 : _a2.getBoundingClientRect()) ?? { x: 0, y: 0 };
        const resX = position.x + x2;
        const resY = position.y + y2;
        return {
          width: 0,
          height: 0,
          x: resX,
          y: resY,
          top: resY,
          right: resX,
          bottom: resY,
          left: resX
        };
      },
      contextElement: anchorRef.value
    };
  });
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v2) => ({
  x: v2,
  y: v2
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp2(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name,
      fn
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
      continue;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x: x2,
    y: y2
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp2(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp2(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2
        }
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply: apply2 = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const overflowAvailableHeight = height - overflow[heightSide];
      const overflowAvailableWidth = width - overflow[widthSide];
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        const maximumClippingWidth = width - overflow.left - overflow.right;
        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply2({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow2(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow2(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow2(value).Element;
}
function isHTMLElement2(value) {
  return value instanceof HTMLElement || value instanceof getWindow2(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow2(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const webkit = isWebKit();
  const css = getComputedStyle2(element);
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow2(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement2(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow2(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement2(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement2(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x2 = ($2 ? round(rect.width) : rect.width) / width;
  let y2 = ($2 ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow2(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow2(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow2(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow2(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y2 += top;
      currentIFrame = getWindow2(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement2(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow2(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement2(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement2(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const window2 = getWindow2(element);
  if (!isHTMLElement2(element)) {
    return window2;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
var getElementRects = async function(_ref) {
  let {
    reference,
    floating,
    strategy
  } = _ref;
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  return {
    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
    floating: {
      x: 0,
      y: 0,
      ...await getDimensionsFn(floating)
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root2 = getDocumentElement(element);
  function cleanup() {
    clearTimeout(timeoutId);
    io && io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root2.clientWidth - (left + width));
    const insetBottom = floor(root2.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch (e2) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          resizeObserver && resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo && cleanupIo();
    resizeObserver && resizeObserver.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@floating-ui/vue/dist/floating-ui.vue.mjs
function isComponentPublicInstance(target) {
  return target != null && typeof target === "object" && "$el" in target;
}
function unwrapElement2(target) {
  if (isComponentPublicInstance(target)) {
    const element = target.$el;
    return isNode(element) && getNodeName(element) === "#comment" ? null : element;
  }
  return target;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useFloating(reference, floating, options) {
  if (options === void 0) {
    options = {};
  }
  const whileElementsMountedOption = options.whileElementsMounted;
  const openOption = computed(() => {
    var _unref;
    return (_unref = unref(options.open)) != null ? _unref : true;
  });
  const middlewareOption = computed(() => unref(options.middleware));
  const placementOption = computed(() => {
    var _unref2;
    return (_unref2 = unref(options.placement)) != null ? _unref2 : "bottom";
  });
  const strategyOption = computed(() => {
    var _unref3;
    return (_unref3 = unref(options.strategy)) != null ? _unref3 : "absolute";
  });
  const transformOption = computed(() => {
    var _unref4;
    return (_unref4 = unref(options.transform)) != null ? _unref4 : true;
  });
  const referenceElement = computed(() => unwrapElement2(reference.value));
  const floatingElement = computed(() => unwrapElement2(floating.value));
  const x2 = ref(0);
  const y2 = ref(0);
  const strategy = ref(strategyOption.value);
  const placement = ref(placementOption.value);
  const middlewareData = shallowRef({});
  const isPositioned = ref(false);
  const floatingStyles = computed(() => {
    const initialStyles = {
      position: strategy.value,
      left: "0",
      top: "0"
    };
    if (!floatingElement.value) {
      return initialStyles;
    }
    const xVal = roundByDPR(floatingElement.value, x2.value);
    const yVal = roundByDPR(floatingElement.value, y2.value);
    if (transformOption.value) {
      return {
        ...initialStyles,
        transform: "translate(" + xVal + "px, " + yVal + "px)",
        ...getDPR(floatingElement.value) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy.value,
      left: xVal + "px",
      top: yVal + "px"
    };
  });
  let whileElementsMountedCleanup;
  function update() {
    if (referenceElement.value == null || floatingElement.value == null) {
      return;
    }
    computePosition2(referenceElement.value, floatingElement.value, {
      middleware: middlewareOption.value,
      placement: placementOption.value,
      strategy: strategyOption.value
    }).then((position) => {
      x2.value = position.x;
      y2.value = position.y;
      strategy.value = position.strategy;
      placement.value = position.placement;
      middlewareData.value = position.middlewareData;
      isPositioned.value = true;
    });
  }
  function cleanup() {
    if (typeof whileElementsMountedCleanup === "function") {
      whileElementsMountedCleanup();
      whileElementsMountedCleanup = void 0;
    }
  }
  function attach() {
    cleanup();
    if (whileElementsMountedOption === void 0) {
      update();
      return;
    }
    if (referenceElement.value != null && floatingElement.value != null) {
      whileElementsMountedCleanup = whileElementsMountedOption(referenceElement.value, floatingElement.value, update);
      return;
    }
  }
  function reset() {
    if (!openOption.value) {
      isPositioned.value = false;
    }
  }
  watch([middlewareOption, placementOption, strategyOption], update, {
    flush: "sync"
  });
  watch([referenceElement, floatingElement], attach, {
    flush: "sync"
  });
  watch(openOption, reset, {
    flush: "sync"
  });
  if (getCurrentScope()) {
    onScopeDispose(cleanup);
  }
  return {
    x: shallowReadonly(x2),
    y: shallowReadonly(y2),
    strategy: shallowReadonly(strategy),
    placement: shallowReadonly(placement),
    middlewareData: shallowReadonly(middlewareData),
    isPositioned: shallowReadonly(isPositioned),
    floatingStyles,
    update
  };
}

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/hooks/useDropdown.js
var useDropdown = (anchorComputed, floating, target, options) => {
  const placementComputed = computed(() => {
    const { position, align } = usePlacementAliases({ placement: options.value.placement });
    return `${position.value}-${align.value}`;
  });
  const offsetComputed = computed(() => {
    const dropdownOffset = options.value.offset;
    const result = { mainAxis: 0, crossAxis: 0 };
    if (Array.isArray(dropdownOffset)) {
      result.mainAxis = dropdownOffset[0];
      result.crossAxis = dropdownOffset[1];
    }
    if (typeof dropdownOffset === "number") {
      result.mainAxis = dropdownOffset;
    }
    return result;
  });
  const middlewareComputed = computed(() => {
    const { autoPlacement: autoPlacement3, stickToEdges, keepAnchorWidth, verticalScrollOnOverflow } = options.value;
    const result = [
      offset(offsetComputed.value)
    ];
    if (autoPlacement3) {
      result.push(
        // boundary doesn't work with ssr (trying to access document)
        flip2({
          boundary: target.value
        })
      );
    }
    if (stickToEdges) {
      result.push(
        shift2()
      );
    }
    if (keepAnchorWidth || verticalScrollOnOverflow) {
      result.push(size2({
        apply({ elements, availableHeight }) {
          if (keepAnchorWidth) {
            const reference = elements.reference;
            const availableWidth = reference.getBoundingClientRect().width;
            Object.assign(elements.floating.style, {
              // Don't set width here, because some plugin applies width 100% and it breaks layout
              maxWidth: `${availableWidth}px`,
              minWidth: `${availableWidth}px`
            });
          }
          if (verticalScrollOnOverflow) {
            Object.assign(elements.floating.style, {
              maxHeight: `${availableHeight}px`
            });
          }
        }
      }));
    }
    return result;
  });
  const { floatingStyles, isPositioned } = typeof document === "undefined" ? { floatingStyles: {}, isPositioned: ref(false) } : useFloating(anchorComputed, floating, {
    placement: placementComputed,
    whileElementsMounted: autoUpdate,
    middleware: middlewareComputed,
    transform: true
  });
  return {
    // Because floating ui by default set top and left to 0 before position calculated, dropdown jumps to the left top corner
    // If user wants to make focus on el as soon as Dropdown is opened, page will be scrolled on the left top corner
    floatingStyles: computed(() => {
      if (!isPositioned.value) {
        return {
          position: "fixed"
        };
      }
      return floatingStyles.value;
    }),
    isPositioned
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useFocusOutside.js
var checkIfElementChild2 = (parent2, child) => {
  if (!child) {
    return false;
  }
  if (child instanceof Window) {
    return false;
  }
  if (child.parentElement === parent2) {
    return true;
  }
  return parent2.contains(child);
};
var safeArray2 = (a2) => Array.isArray(a2) ? a2 : [a2];
var useFocusOutside = (elements, cb, options = {}) => {
  let previouslyClicked2 = false;
  if (options.onlyKeyboard) {
    useEvent("mousedown", (e2) => {
      previouslyClicked2 = true;
      setTimeout(() => {
        previouslyClicked2 = false;
      }, 200);
    }, true);
  }
  useEvent("focus", (event) => {
    if (options.onlyKeyboard && previouslyClicked2) {
      return;
    }
    const focusTarget = event.target;
    if (event.target.shadowRoot) {
      return;
    }
    const isFocusInside = safeArray2(elements).some((element) => {
      const el = unwrapEl(unref(element));
      return el && checkIfElementChild2(el, focusTarget);
    });
    if (!isFocusInside) {
      cb(focusTarget);
    }
  }, true);
};

// node_modules/vuestic-ui/dist/es/src/composables/useHTMLElementSelector.js
var useHTMLElementSelector = (key) => {
  return computed(() => {
    if (typeof (key == null ? void 0 : key.value) === "string") {
      return document.querySelector(key.value);
    }
    return unwrapEl(key == null ? void 0 : key.value);
  });
};

// node_modules/vuestic-ui/dist/es/src/composables/useDebounce.js
var useDebounceFn = (timeout) => {
  let callback = null;
  const createDebounced = () => {
    return debounce$2(() => {
      callback == null ? void 0 : callback();
      callback = null;
    }, unref(timeout));
  };
  let debounced = createDebounced();
  if (isRef(timeout)) {
    watch(timeout, () => {
      debounced = createDebounced();
    });
  }
  return {
    // todo check if we need to create proxy here
    debounced: (cb) => {
      callback = cb;
      debounced();
    },
    cancel: () => debounced.cancel()
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/VaDropdown.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaDropdown.css";
var _sfc_main20 = defineComponent({
  name: "VaDropdown",
  props: {
    ...usePlacementAliasesProps,
    ...createStatefulProps(true),
    modelValue: { type: Boolean, default: false },
    anchor: { type: [String, Object], default: void 0 },
    anchorSelector: { type: String, default: "" },
    innerAnchorSelector: { type: String, default: "" },
    trigger: {
      type: String,
      default: "click",
      validator: (value) => ["click", "right-click", "hover", "dblclick", "none"].includes(value)
    },
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    closeOnClickOutside: { type: Boolean, default: true },
    closeOnFocusOutside: { type: Boolean, default: true },
    closeOnAnchorClick: { type: Boolean, default: true },
    closeOnContentClick: { type: Boolean, default: true },
    hoverOverTimeout: { type: Number, default: 30 },
    hoverOutTimeout: { type: Number, default: 200 },
    isContentHoverable: { type: Boolean, default: true },
    offset: { type: [Array, Number], default: 0 },
    keepAnchorWidth: { type: Boolean, default: false },
    verticalScrollOnOverflow: { type: Boolean, default: true },
    cursor: { type: [Boolean, Object], default: false },
    autoPlacement: { type: Boolean, default: true },
    stickToEdges: { type: Boolean, default: false },
    /** Viewport where dropdown will be rendered. Autoplacement will be calculated relative to `target` */
    target: { type: [String, Object], default: void 0 },
    /** Element where dropdown content will be rendered. */
    teleport: { type: [String, Object], default: void 0 },
    /** Not reactive */
    keyboardNavigation: { type: Boolean, default: false },
    ariaLabel: { type: String, default: "$t:toggleDropdown" },
    role: { type: String, default: "button" }
  },
  emits: [...useStatefulEmits, "anchor-click", "anchor-right-click", "content-click", "click-outside", "focus-outside", "close", "open", "anchor-dblclick"],
  setup(props2, { emit }) {
    const { valueComputed: statefulVal } = useStateful(props2, emit, "modelValue");
    const valueComputed = computed({
      get: () => statefulVal.value && !props2.disabled && !props2.readonly,
      set(val) {
        statefulVal.value = val;
        if (val) {
          emit("open");
        } else {
          emit("close");
        }
      }
    });
    const isMounted = useIsMounted();
    const { anchorRef } = useAnchorSelector(props2);
    const cursorAnchor = useCursorAnchor(anchorRef, valueComputed);
    const floating = useHTMLElement("floating");
    const body = useHTMLElementSelector(ref("body"));
    const target = useHTMLElementSelector(computed(() => props2.target));
    const teleport = useHTMLElementSelector(computed(() => props2.teleport));
    const anchorClass = useBem("va-dropdown", () => pick$1(props2, ["disabled"]));
    const teleportTarget = computed(() => {
      if (teleport.value) {
        return teleport.value;
      }
      if (target.value) {
        return target.value;
      }
      if (anchorRef.value) {
        const root2 = anchorRef.value.getRootNode();
        if (root2 instanceof ShadowRoot) {
          const el = [...root2.children].find((c2) => c2.tagName !== "STYLE");
          if (el) {
            return el;
          }
        }
      }
      return body.value;
    });
    const teleportDisabled = computed(() => {
      return props2.disabled;
    });
    const showFloating = computed(() => isMounted.value && valueComputed.value);
    const { debounced: debounceHover, cancel: cancelHoverDebounce } = useDebounceFn(toRef(props2, "hoverOverTimeout"));
    const { debounced: debounceUnHover, cancel: cancelUnHoverDebounce } = useDebounceFn(toRef(props2, "hoverOutTimeout"));
    const onClick = (e2) => {
      if (props2.trigger !== "click" && kebabCase$1(props2.trigger) !== "right-click" || props2.disabled) {
        return;
      }
      if (valueComputed.value) {
        emitAndClose("anchor-click", props2.closeOnAnchorClick, e2);
      } else {
        if (props2.trigger !== "click") {
          return;
        }
        valueComputed.value = true;
        emit("anchor-click", e2);
      }
    };
    const onContextmenu = (e2) => {
      if (kebabCase$1(props2.trigger) !== "right-click" || props2.disabled) {
        return;
      }
      e2.preventDefault();
      if (valueComputed.value) {
        emitAndClose("anchor-right-click", props2.closeOnAnchorClick, e2);
        if (props2.cursor) {
          nextTick(() => {
            valueComputed.value = true;
          });
        }
      } else {
        valueComputed.value = true;
        emit("anchor-right-click", e2);
      }
    };
    const onDblclick = (e2) => {
      if (kebabCase$1(props2.trigger) !== "dblclick" || props2.disabled) {
        return;
      }
      e2.preventDefault();
      if (valueComputed.value) {
        emitAndClose("anchor-dblclick", props2.closeOnAnchorClick, e2);
        if (props2.cursor) {
          nextTick(() => {
            valueComputed.value = true;
          });
        }
      } else {
        valueComputed.value = true;
        emit("anchor-dblclick", e2);
      }
    };
    const onMouseenter = () => {
      if (props2.trigger !== "hover" || props2.disabled) {
        return;
      }
      debounceHover(() => {
        valueComputed.value = true;
      });
      cancelUnHoverDebounce();
    };
    const onMouseleave = () => {
      if (props2.trigger !== "hover" || props2.disabled) {
        return;
      }
      if (props2.isContentHoverable) {
        debounceUnHover(() => {
          valueComputed.value = false;
        });
      } else {
        valueComputed.value = false;
      }
      cancelHoverDebounce();
    };
    useMouseNavigation(anchorRef, {
      click: onClick,
      contextmenu: onContextmenu,
      dblclick: onDblclick,
      mouseenter: onMouseenter,
      mouseleave: onMouseleave
    });
    if (props2.keyboardNavigation) {
      useKeyboardNavigation(anchorRef, valueComputed);
    }
    const emitAndClose = (eventName, close, e2) => {
      emit(eventName, e2);
      if (close) {
        valueComputed.value = false;
      }
    };
    const floatingListeners = {
      onMouseover: () => props2.isContentHoverable && onMouseenter(),
      onMouseout: () => onMouseleave(),
      onClick: () => emitAndClose("content-click", props2.closeOnContentClick)
    };
    useClickOutside([anchorRef, floating], () => {
      if (props2.closeOnClickOutside && valueComputed.value) {
        emitAndClose("click-outside", props2.closeOnClickOutside);
      }
    });
    useFocusOutside([floating], () => {
      if (props2.closeOnFocusOutside && valueComputed.value) {
        emitAndClose("focus-outside", props2.closeOnFocusOutside);
      }
    }, { onlyKeyboard: true });
    const anchorComputed = computed(() => {
      if (typeof props2.cursor === "object") {
        return props2.cursor;
      }
      return props2.cursor ? cursorAnchor.value : anchorRef.value;
    });
    const { floatingStyles } = useDropdown(
      anchorComputed,
      floating,
      target,
      computed(() => ({
        placement: props2.placement,
        offset: props2.offset,
        autoPlacement: props2.autoPlacement,
        stickToEdges: props2.stickToEdges,
        keepAnchorWidth: props2.keepAnchorWidth,
        verticalScrollOnOverflow: props2.verticalScrollOnOverflow
      }))
    );
    const hide3 = () => {
      valueComputed.value = false;
    };
    const show = () => {
      valueComputed.value = true;
    };
    const {
      zIndex,
      register: registerZIndex,
      unregister: unregisterZIndex
    } = useZIndex();
    watchEffect(() => {
      if (valueComputed.value && isMounted.value) {
        registerZIndex();
      } else {
        unregisterZIndex();
      }
    });
    return {
      ...useTranslation(),
      ...useTeleported(),
      anchorRef,
      anchorClass,
      floating,
      floatingStyles,
      teleportDisabled,
      showFloating,
      teleportTarget,
      floatingListeners,
      isMounted,
      valueComputed,
      hide: hide3,
      show,
      zIndex
    };
  },
  render() {
    const slotBind = {
      isOpened: this.valueComputed,
      hide: this.hide,
      show: this.show,
      toggle: () => this.valueComputed ? this.hide() : this.show(),
      getAnchorWidth: () => {
        var _a2;
        return ((_a2 = this.anchorRef) == null ? void 0 : _a2.offsetWidth) + "px";
      },
      getAnchorHeight: () => {
        var _a2;
        return ((_a2 = this.anchorRef) == null ? void 0 : _a2.offsetHeight) + "px";
      }
    };
    const floatingSlotNode = this.showFloating && renderSlotNode(this.$slots.default, slotBind, {
      ref: "floating",
      class: "va-dropdown__content-wrapper",
      style: [this.floatingStyles, { zIndex: this.zIndex }],
      ...this.teleportedAttrs,
      ...this.floatingListeners
    });
    const anchorSlotVNode = renderSlotNode(this.$slots.anchor, slotBind, {
      ref: "anchorRef",
      role: this.$props.role,
      class: ["va-dropdown", ...this.anchorClass.asArray.value],
      style: { position: "relative" },
      "aria-label": this.tp(this.$props.ariaLabel),
      "aria-disabled": this.$props.disabled,
      "aria-expanded": this.$props.role && this.$props.role !== "none" ? !!this.showFloating : void 0,
      ...this.teleportFromAttrs,
      ...this.$attrs
    });
    if (typeof this.$props.cursor === "object" && floatingSlotNode) {
      return h(
        Teleport,
        {
          to: this.teleportTarget,
          disabled: this.teleportDisabled
        },
        [floatingSlotNode]
      );
    }
    if (!this.$props.anchorSelector && !anchorSlotVNode) {
      warn("VaDropdown: #anchor slot is missing");
      return;
    }
    if (this.showFloating && !floatingSlotNode) {
      warn("VaDropdown: default slot is missing");
      return;
    }
    return h(Fragment, {}, [
      anchorSlotVNode,
      floatingSlotNode && h(
        Teleport,
        {
          to: this.teleportTarget,
          disabled: this.teleportDisabled
        },
        [floatingSlotNode]
      )
    ]);
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/index.js
var VaDropdown = withConfigTransport$1(_sfc_main20);

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/components/VaDropdownContent/VaDropdownContent.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaDropdownContent.css";
var _sfc_main21 = defineComponent({
  name: "VaDropdownContent",
  props: {
    noPadding: { type: Boolean, default: false },
    background: { type: String, default: "background-secondary" },
    textColor: { type: String }
  },
  setup(props2) {
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor(toRef(props2, "background"));
    const computedStyle = computed(() => ({
      background: getColor(props2.background, void 0, true),
      color: textColorComputed.value,
      padding: props2.noPadding ? 0 : void 0
    }));
    return { computedStyle };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/components/VaDropdownContent/VaDropdownContent.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaDropdownContent.css";
function _sfc_render18(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "va-dropdown__content",
    style: normalizeStyle(_ctx.computedStyle),
    role: "listbox"
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 4);
}
var _VaDropdownContent = _export_sfc(_sfc_main21, [["render", _sfc_render18]]);

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/components/VaDropdownContent/index.js
var VaDropdownContent = withConfigTransport$1(_VaDropdownContent);

// node_modules/vuestic-ui/dist/es/src/composables/useEmitProxy.js
var getEvent = (event) => typeof event === "object" ? event.listen : event;
var getEmit = (event) => typeof event === "object" ? event.emit : event;
var useEmitProxy = (events) => {
  const createEmits3 = () => events.map(getEmit);
  const eventToListenerName = (event) => {
    const eventName = event.charAt(0).toUpperCase() + event.slice(1);
    return `on${eventName}`;
  };
  const createListeners3 = (emit) => {
    return events.reduce((acc, key) => ({
      ...acc,
      [eventToListenerName(getEvent(key))]: (...args) => emit(getEmit(key), ...args)
    }), {});
  };
  const createVOnListeners = (emit) => {
    return events.reduce((acc, key) => ({
      ...acc,
      [getEvent(key)]: (...args) => emit(getEmit(key), ...args)
    }), {});
  };
  return {
    createListeners: createListeners3,
    createVOnListeners,
    createEmits: createEmits3
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-button-dropdown/VaButtonDropdown.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaButtonDropdown.css";
var { createEmits, createVOnListeners: createListeners } = useEmitProxy(["click"]);
var { createEmits: createMainButtonEmits, createVOnListeners: createMainButtonListeners } = useEmitProxy(
  [{ listen: "click", emit: "main-button-click" }]
);
var VaButtonProps2 = omit$1(extractComponentProps(VaButton), ["iconRight", "block"]);
var VaDropdownProps = extractComponentProps(VaDropdown);
var _sfc_main22 = defineComponent({
  name: "VaButtonDropdown",
  components: {
    VaButton,
    VaDropdown,
    VaButtonGroup,
    VaDropdownContent
  },
  emits: ["update:modelValue", ...createEmits(), ...createMainButtonEmits()],
  props: {
    ...useComponentPresetProp,
    ...VaButtonProps2,
    ...VaDropdownProps,
    ...useStatefulProps,
    ...usePlacementAliasesProps,
    modelValue: { type: Boolean, default: false },
    stateful: { type: Boolean, default: true },
    icon: { type: String, default: "va-arrow-down" },
    openedIcon: { type: String, default: "va-arrow-up" },
    hideIcon: { type: Boolean, default: false },
    leftIcon: { type: Boolean, default: false },
    iconColor: { type: String, default: "" },
    disabled: { type: Boolean, default: false },
    disableButton: { type: Boolean, default: false },
    disableDropdown: { type: Boolean, default: false },
    offset: { type: [Number, Array], default: 2 },
    keepAnchorWidth: { type: Boolean, default: false },
    closeOnContentClick: { type: Boolean, default: true },
    split: { type: Boolean },
    splitTo: { type: String, default: "" },
    splitHref: { type: String, default: "" },
    loading: { type: Boolean, default: false },
    label: { type: String },
    ariaLabel: { type: String, default: "$t:toggleDropdown" }
  },
  setup(props2, { emit, slots }) {
    const { valueComputed } = useStateful(props2, emit);
    const computedIcon = computed(() => valueComputed.value ? props2.openedIcon : props2.icon);
    const computedClass = useBem("va-button-dropdown", () => ({
      split: props2.split
    }));
    const computedButtonIcons = computed(() => {
      if (props2.hideIcon) {
        return {};
      }
      const propName = (props2.label || slots.label) && !props2.leftIcon ? "icon-right" : "icon";
      return { [propName]: computedIcon.value };
    });
    const buttonPropsFiltered = computed(() => {
      let ignoredProps = ["to", "href", "loading", "icon"];
      const presetProps = [
        "plain",
        "textOpacity",
        "backgroundOpacity",
        "hoverOpacity",
        "hoverBehavior",
        "hoverOpacity",
        "pressedOpacity",
        "pressedBehavior",
        "pressedOpacity"
      ];
      if (props2.preset) {
        ignoredProps = [...ignoredProps, ...presetProps];
      }
      const filteredProps = omit$1(VaButtonProps2, ignoredProps);
      return Object.keys(filteredProps);
    });
    const buttonPropsComputed = computed(
      () => Object.entries(props2).filter(([key, _2]) => buttonPropsFiltered.value.includes(key)).reduce((acc, [key, value]) => {
        Object.assign(acc, { [key]: value });
        return acc;
      }, {})
    );
    const computedMainButtonProps = computed(() => ({
      to: props2.splitTo,
      href: props2.splitHref,
      loading: props2.loading
    }));
    const hideDropdown = () => {
      valueComputed.value = false;
    };
    return {
      ...useTranslation(),
      vaDropdownProps: filterComponentProps(VaDropdownProps),
      hideDropdown,
      valueComputed,
      computedIcon,
      computedClass,
      computedButtonIcons,
      buttonPropsComputed,
      computedMainButtonProps,
      listeners: createListeners(emit),
      mainButtonListeners: createMainButtonListeners(emit)
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-button-dropdown/VaButtonDropdown.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaButtonDropdown.css";
function _sfc_render19(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  const _component_va_button_group = resolveComponent("va-button-group");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-button-dropdown", _ctx.computedClass])
  }, [
    !_ctx.$props.split ? (openBlock(), createBlock(_component_va_dropdown, mergeProps({ key: 0 }, _ctx.vaDropdownProps, {
      modelValue: _ctx.valueComputed,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.valueComputed = $event),
      disabled: _ctx.$props.disabled || _ctx.$props.disableDropdown
    }), {
      anchor: withCtx(() => [
        createVNode(_component_va_button, mergeProps({
          "aria-label": _ctx.tp(_ctx.$props.ariaLabel)
        }, { ..._ctx.computedButtonIcons, ..._ctx.buttonPropsComputed }, toHandlers(_ctx.listeners), {
          onKeydown: withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["esc"])
        }), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "label", {}, () => [
              createTextVNode(toDisplayString(_ctx.label), 1)
            ])
          ]),
          _: 3
        }, 16, ["aria-label", "onKeydown"])
      ]),
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "content", {}, () => [
          createVNode(_component_va_dropdown_content, null, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          })
        ])
      ]),
      _: 3
    }, 16, ["modelValue", "disabled"])) : (openBlock(), createBlock(_component_va_button_group, normalizeProps(mergeProps({ key: 1 }, _ctx.buttonPropsComputed)), {
      default: withCtx(() => [
        !_ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_button, mergeProps({
          key: 0,
          disabled: _ctx.$props.disabled || _ctx.$props.disableButton
        }, _ctx.computedMainButtonProps, toHandlers(_ctx.mainButtonListeners)), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "label", {}, () => [
              createTextVNode(toDisplayString(_ctx.label), 1)
            ])
          ]),
          _: 3
        }, 16, ["disabled"])) : createCommentVNode("", true),
        createVNode(_component_va_dropdown, mergeProps(_ctx.vaDropdownProps, {
          modelValue: _ctx.valueComputed,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.valueComputed = $event),
          disabled: _ctx.$props.disabled || _ctx.$props.disableDropdown,
          teleport: _ctx.$el
        }), {
          anchor: withCtx(() => [
            createVNode(_component_va_button, mergeProps({
              "aria-label": _ctx.$props.ariaLabel || _ctx.t("toggleDropdown"),
              disabled: _ctx.$props.disabled || _ctx.$props.disableDropdown,
              icon: _ctx.computedIcon,
              "icon-color": _ctx.$props.iconColor
            }, toHandlers(_ctx.listeners), {
              onKeydown: withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["esc"])
            }), null, 16, ["aria-label", "disabled", "icon", "icon-color", "onKeydown"])
          ]),
          default: withCtx(() => [
            createVNode(_component_va_dropdown_content, null, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            })
          ]),
          _: 3
        }, 16, ["modelValue", "disabled", "teleport"]),
        _ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_button, mergeProps({
          key: 1,
          disabled: _ctx.$props.disabled || _ctx.$props.disableButton
        }, _ctx.computedMainButtonProps, toHandlers(_ctx.mainButtonListeners)), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "label", {}, () => [
              createTextVNode(toDisplayString(_ctx.label), 1)
            ])
          ]),
          _: 3
        }, 16, ["disabled"])) : createCommentVNode("", true)
      ]),
      _: 3
    }, 16))
  ], 2);
}
var _VaButtonDropdown = _export_sfc(_sfc_main22, [["render", _sfc_render19]]);

// node_modules/vuestic-ui/dist/es/src/components/va-button-dropdown/index.js
var VaButtonDropdown = withConfigTransport$1(_VaButtonDropdown);

// node_modules/vuestic-ui/dist/es/src/utils/isNilValue.js
var isNilValue = (value) => {
  return [null, void 0, ""].includes(value);
};

// node_modules/vuestic-ui/dist/es/src/utils/value-by-key.js
var getNestedValue = (option, propsArray) => {
  if (propsArray.length === 0) {
    return option;
  }
  const nestedItem = option[propsArray[0]];
  if (!isObject$d(nestedItem)) {
    if (propsArray.length === 1) {
      return nestedItem;
    }
    return void 0;
  }
  return getNestedValue(nestedItem, propsArray.slice(1));
};
var getValueByPath = (option, prop) => {
  if (prop in option) {
    return option[prop];
  }
  prop = prop.replace(/^\./, "");
  return getNestedValue(option, prop.split("."));
};
var getValueByKey = (option, prop) => {
  if (isNilValue(option) || typeof option !== "object" || Array.isArray(option)) {
    return void 0;
  }
  if (!prop) {
    return option;
  }
  if (typeof prop === "string") {
    return getValueByPath(option, prop);
  }
  if (typeof prop === "function") {
    return prop(option);
  }
  return option;
};

// node_modules/vuestic-ui/dist/es/src/composables/useSelectableList.js
var useSelectableListProps = {
  options: { type: Array, default: () => [] },
  textBy: { type: [String, Function], default: "text" },
  valueBy: { type: [String, Function], default: "" },
  trackBy: { type: [String, Function], default: "" },
  disabledBy: { type: [String, Function], default: "disabled" },
  groupBy: { type: [String, Function], default: "group" }
};
function useSelectableList(props2) {
  const getOptionProperty = (option, prop) => {
    if (typeof option !== "object") {
      return option;
    }
    return getValueByKey(option, prop);
  };
  const getTrackBy = (option) => {
    return props2.trackBy ? getOptionProperty(option, props2.trackBy) : getValue2(option);
  };
  const getDisabled = (option) => {
    if (typeof option !== "object") {
      return false;
    }
    return getOptionProperty(option, props2.disabledBy);
  };
  const getText = (option) => {
    const optionText = getOptionProperty(option, props2.textBy);
    if (["number", "boolean"].includes(typeof optionText)) {
      return String(optionText);
    }
    return optionText;
  };
  const getGroupBy = (option) => {
    if (!option || typeof option !== "object") {
      return void 0;
    }
    return getOptionProperty(option, props2.groupBy);
  };
  const getValue2 = (option) => getOptionProperty(option, props2.valueBy);
  return {
    getValue: getValue2,
    getText,
    getDisabled,
    getTrackBy,
    getGroupBy
  };
}

// node_modules/vuestic-ui/dist/es/src/components/va-button-toggle/VaButtonToggle.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaButtonToggle.css";
var VaButtonGroupProps = extractComponentProps(VaButtonGroup);
var _sfc_main23 = defineComponent({
  name: "VaButtonToggle",
  components: {
    VaButtonGroup,
    VaButton
  },
  emits: ["update:modelValue"],
  props: {
    ...VaButtonGroupProps,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    modelValue: { type: [String, Number, Boolean], default: "" },
    options: {
      type: Array,
      required: true
    },
    activeButtonTextColor: { type: String },
    toggleColor: { type: String, default: "" },
    textBy: { type: [String, Function], default: "label" },
    valueBy: { type: [String, Function], default: "value" }
  },
  setup(props2, { emit }) {
    const { getText, getTrackBy } = useSelectableList(props2);
    const { getColor, shiftHSLAColor: shiftHSLAColor2 } = useColors();
    const colorComputed = computed(() => getColor(props2.color));
    const isToggled = (value) => getTrackBy(value) === props2.modelValue;
    const activeButtonColor = computed(() => {
      if (props2.toggleColor) {
        return getColor(props2.toggleColor);
      }
      return shiftHSLAColor2(colorComputed.value, { l: props2.plain ? -16 : -6 });
    });
    const activeButtonBackgroundOpacityComputed = computed(() => {
      if (!props2.preset || props2.preset === "default") {
        return {};
      }
      return { backgroundOpacity: props2.pressedOpacity };
    });
    const activeButtonPropsComputed = computed(() => ({
      color: activeButtonColor.value,
      textColor: props2.activeButtonTextColor,
      ...activeButtonBackgroundOpacityComputed.value
    }));
    const getButtonProps = (option = {}) => {
      const iconsProps = { icon: option.icon, iconRight: option.iconRight };
      if (!isToggled(option)) {
        return iconsProps;
      }
      return {
        ...isToggled(option) && activeButtonPropsComputed.value,
        ...iconsProps
      };
    };
    const buttonGroupPropsComputed = filterComponentProps(VaButtonGroupProps);
    const changeValue = (value) => emit("update:modelValue", getTrackBy(value));
    return {
      buttonGroupPropsComputed,
      getButtonProps,
      changeValue,
      isToggled,
      getText,
      getTrackBy
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-button-toggle/VaButtonToggle.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaButtonToggle.css";
function _sfc_render20(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_button_group = resolveComponent("va-button-group");
  return openBlock(), createBlock(_component_va_button_group, mergeProps({ class: "va-button-toggle" }, _ctx.buttonGroupPropsComputed), {
    default: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, (option) => {
        return openBlock(), createBlock(_component_va_button, mergeProps({
          key: _ctx.getTrackBy(option),
          "aria-pressed": _ctx.isToggled(option)
        }, _ctx.getButtonProps(option), {
          onClick: ($event) => _ctx.changeValue(option)
        }), {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.getText(option)), 1)
          ]),
          _: 2
        }, 1040, ["aria-pressed", "onClick"]);
      }), 128))
    ]),
    _: 1
  }, 16);
}
var _VaButtonToggle = _export_sfc(_sfc_main23, [["render", _sfc_render20]]);

// node_modules/vuestic-ui/dist/es/src/components/va-button-toggle/index.js
var VaButtonToggle = withConfigTransport$1(_VaButtonToggle);

// node_modules/vuestic-ui/dist/es/src/components/va-card/VaCard.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaCard.css";
var _sfc_main24 = defineComponent({
  name: "VaCard",
  props: {
    ...useRouterLinkProps,
    ...useComponentPresetProp,
    tag: { type: String, default: "div" },
    square: { type: Boolean, default: false },
    outlined: { type: Boolean, default: false },
    bordered: { type: Boolean, default: true },
    disabled: { type: Boolean, default: false },
    href: { type: String, default: "" },
    target: { type: String, default: "" },
    stripe: { type: Boolean, default: false },
    stripeColor: { type: String, default: "" },
    gradient: { type: Boolean, default: false },
    textColor: { type: String },
    color: { type: String, default: "background-secondary" }
  },
  setup(props2) {
    const { getColor } = useColors();
    const { isLinkTag, tagComputed, hrefComputed } = useRouterLink(props2);
    const { textColorComputed } = useTextColor(computed(() => getColor(props2.color)));
    const stripeColorComputed = computed(() => getColor(props2.stripeColor));
    const classComputed = useBem("va-card", () => ({
      ...pick$1(props2, ["square", "outlined", "disabled", "stripe"]),
      noBorder: !props2.bordered,
      link: isLinkTag.value
    }));
    const cardStyles = computed(() => {
      const background = props2.gradient && props2.color ? getGradientBackground(getColor(props2.color)) : getColor(props2.color);
      return {
        background,
        color: textColorComputed.value
      };
    });
    return {
      classComputed,
      cardStyles,
      stripeColorComputed,
      tagComputed,
      hrefComputed
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-card/VaCard.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaCard.css";
function _sfc_render21(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
    class: normalizeClass(["va-card", _ctx.classComputed]),
    style: normalizeStyle([_ctx.cardStyles, `--va-stripe-color-computed: ${String(_ctx.stripeColorComputed)}`]),
    href: _ctx.hrefComputed,
    target: _ctx.target,
    to: _ctx.to,
    replace: _ctx.replace,
    exact: _ctx.exact,
    "active-class": _ctx.activeClass,
    "exact-active-class": _ctx.exactActiveClass
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["class", "style", "href", "target", "to", "replace", "exact", "active-class", "exact-active-class"]);
}
var _VaCard = _export_sfc(_sfc_main24, [["render", _sfc_render21]]);

// node_modules/vuestic-ui/dist/es/src/components/va-card/components/va-card-content/VaCardContent.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaCardContent.css";
var _sfc_main25 = defineComponent({
  name: "VaCardContent"
});

// node_modules/vuestic-ui/dist/es/src/components/va-card/components/va-card-content/VaCardContent.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaCardContent.css";
var _hoisted_110 = { class: "va-card__content" };
function _sfc_render22(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_110, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var VaCardContentBase = _export_sfc(_sfc_main25, [["render", _sfc_render22]]);

// node_modules/vuestic-ui/dist/es/src/components/va-card/components/va-card-title/VaCardTitle.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaCardTitle.css";
var _sfc_main26 = defineComponent({
  name: "VaCardTitle",
  props: {
    ...useComponentPresetProp,
    textColor: { type: String }
  },
  setup(props2) {
    const { getColor } = useColors();
    return {
      titleStyles: computed(() => ({
        color: props2.textColor ? getColor(props2.textColor) : ""
      }))
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-card/components/va-card-title/VaCardTitle.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaCardTitle.css";
function _sfc_render23(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "va-card-title va-card__title",
    style: normalizeStyle(_ctx.titleStyles)
  }, [
    renderSlot(_ctx.$slots, "default", {}, void 0, true)
  ], 4);
}
var VaCardTitleBase = _export_sfc(_sfc_main26, [["render", _sfc_render23], ["__scopeId", "data-v-f7d1a550"]]);

// node_modules/vuestic-ui/dist/es/src/components/va-card/components/va-card-actions/VaCardActions.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaCardActions.css";
var _sfc_main27 = defineComponent({
  name: "VaCardActions",
  props: {
    ...useAlignProps,
    ...useComponentPresetProp
  },
  setup(props2) {
    const { alignComputed } = useAlign(props2);
    const classComputed = useBem("va-card__actions", () => ({
      ...pick$1(props2, ["vertical"])
    }));
    return {
      classComputed,
      alignComputed
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-card/components/va-card-actions/VaCardActions.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaCardActions.css";
function _sfc_render24(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-card__actions", _ctx.classComputed]),
    style: normalizeStyle(_ctx.alignComputed)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
var VaCardActionsBase = _export_sfc(_sfc_main27, [["render", _sfc_render24]]);

// node_modules/vuestic-ui/dist/es/src/components/va-card/components/va-card-block/VaCardBlock.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaCardBlock.css";
var _sfc_main28 = defineComponent({
  name: "VaCardBlock",
  props: {
    horizontal: {
      type: Boolean,
      default: false
    }
  },
  setup(props2) {
    const classComputed = computed(() => ({
      "va-card-block--horizontal": props2.horizontal
    }));
    return {
      classComputed
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-card/components/va-card-block/VaCardBlock.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaCardBlock.css";
function _sfc_render25(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-card-block", _ctx.classComputed])
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var VaCardBlockBase = _export_sfc(_sfc_main28, [["render", _sfc_render25]]);

// node_modules/vuestic-ui/dist/es/src/components/va-card/index.js
var VaCardContent = withConfigTransport$1(VaCardContentBase);
var VaCardTitle = withConfigTransport$1(VaCardTitleBase);
var VaCardActions = withConfigTransport$1(VaCardActionsBase);
var VaCardBlock = withConfigTransport$1(VaCardBlockBase);
var VaCard = withConfigTransport$1(_VaCard);

// node_modules/vuestic-ui/dist/es/src/components/va-carousel/hooks/useCarousel.js
var useCarousel = (props2, currentSlide) => {
  const goTo = (index) => {
    currentSlide.value = index;
  };
  const prev = () => {
    if (props2.infinite) {
      if (currentSlide.value <= 0) {
        currentSlide.value = props2.items.length - 1;
        return;
      }
    }
    currentSlide.value -= 1;
  };
  const next = () => {
    if (props2.infinite) {
      if (currentSlide.value >= props2.items.length - 1) {
        currentSlide.value = 0;
        return;
      }
    }
    currentSlide.value += 1;
  };
  const doShowDirectionButtons = computed(() => props2.items.length > 1);
  const doShowPrevButton = computed(() => currentSlide.value > 0 || props2.infinite);
  const doShowNextButton = computed(() => currentSlide.value < props2.items.length - 1 || props2.infinite);
  return {
    doShowPrevButton,
    doShowNextButton,
    doShowDirectionButtons,
    goTo,
    prev,
    next
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-carousel/hooks/useCarouselAnimation.js
var useCarouselAnimation = (props2, currentSlide) => {
  let animationInterval = -1;
  const start = () => {
    if (!props2.autoscroll) {
      return;
    }
    clearInterval(animationInterval);
    animationInterval = setInterval(() => {
      currentSlide.value += 1;
      if (currentSlide.value >= props2.items.length) {
        currentSlide.value = 0;
      }
    }, props2.autoscrollInterval);
  };
  let pauseTimeout;
  const pause = () => {
    if (!props2.autoscroll) {
      return;
    }
    clearInterval(animationInterval);
    pauseTimeout = setTimeout(() => {
      start();
      clearTimeout(pauseTimeout);
    }, props2.autoscrollPauseDuration);
  };
  const stop = () => {
    clearInterval(animationInterval);
    clearTimeout(pauseTimeout);
  };
  onMounted(() => start());
  onBeforeUnmount(() => stop());
  const withPause = (fn) => {
    return (...args) => {
      pause();
      fn(...args);
    };
  };
  const slidesContainerStyle = ref({
    transition: void 0
  });
  const sliderToBeShown = ref(0);
  const computedSlidesStyle = computed(() => {
    if (props2.effect === "fade") {
      return {
        ...slidesContainerStyle.value,
        transition: "none"
      };
    }
    if (props2.vertical) {
      return {
        ...slidesContainerStyle.value,
        transform: `translateY(${sliderToBeShown.value * -100}%)`
      };
    }
    return {
      ...slidesContainerStyle.value,
      transform: `translateX(${sliderToBeShown.value * -100}%)`
    };
  });
  const animator = {
    isAnimating: false,
    speed: 0.3,
    order: [],
    move(from, to) {
      const last2 = props2.items.length - 1;
      const firstAfterLast = props2.items.length;
      if (to === 0 && from === last2) {
        this.order.push({ to: firstAfterLast });
        this.order.push({ to: 0, animate: false });
      } else if (to === last2 && from === 0) {
        this.order.push({ to: firstAfterLast, animate: false });
        this.order.push({ to });
      } else {
        this.order.push({ to });
      }
      if (!this.isAnimating) {
        this.runAnimation();
      }
    },
    runAnimation() {
      this.isAnimating = true;
      const animation = this.order.shift();
      if (!animation) {
        this.isAnimating = false;
        return;
      }
      sliderToBeShown.value = animation == null ? void 0 : animation.to;
      if (animation.animate || animation.animate === void 0) {
        slidesContainerStyle.value.transition = `all ${this.speed}s linear`;
        setTimeout(() => {
          this.runAnimation();
        }, this.speed * 1e3);
      } else {
        slidesContainerStyle.value.transition = "none";
        setTimeout(() => {
          this.runAnimation();
        }, 16);
      }
    }
  };
  watch(currentSlide, (newValue, oldValue) => {
    animator.move(oldValue, newValue);
  });
  const slides = computed(() => {
    if (props2.effect === "fade") {
      return [props2.items[currentSlide.value]];
    }
    if (props2.infinite || props2.autoscroll) {
      return [...props2.items, props2.items[0]];
    }
    return props2.items;
  });
  return {
    start,
    pause,
    stop,
    withPause,
    computedSlidesStyle,
    slides
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-carousel/hooks/useCarouselColors.js
var useCarouselColor = () => {
  const { setHSLAColor: setHSLAColor2, getColor } = useColors();
  return {
    computedColor: computed(() => setHSLAColor2(getColor("background-element"), { a: 0.7 })),
    computedHoverColor: computed(() => setHSLAColor2(getColor("primary"), { a: 0.7 })),
    computedActiveColor: computed(() => getColor("primary"))
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-image/hooks/useNativeImgAttributes.js
var useNativeImgAttributesProps = {
  src: { type: String, required: true },
  alt: { type: String, default: "" },
  title: { type: String, default: "" },
  sizes: { type: String, default: "" },
  srcset: { type: String, default: "" },
  draggable: { type: Boolean, default: true },
  loading: {
    type: String
  },
  crossorigin: {
    type: String
  },
  decoding: {
    type: String
  },
  fetchpriority: {
    type: String,
    default: "auto"
  },
  referrerpolicy: {
    type: String
  }
};
var useNativeImgAttributes = (props2) => {
  return computed(
    () => pick$1(props2, ["src", "alt", "title", "sizes", "srcset", "loading", "referrerpolicy", "fetchpriority", "decoding", "crossorigin", "draggable"])
  );
};

// node_modules/vuestic-ui/dist/es/src/composables/useIntersectionObserver.js
var useIntersectionObserver = (cb, options = ref({}), target = ref([]), enabled = true) => {
  const observer = ref();
  const disconnectObserver = () => {
    var _a2;
    (_a2 = observer.value) == null ? void 0 : _a2.disconnect();
  };
  const observeTarget = (target2) => {
    var _a2;
    const disclosedTarget = unwrapEl(unref(target2));
    disclosedTarget && ((_a2 = observer.value) == null ? void 0 : _a2.observe(disclosedTarget));
  };
  const observeAll = (targets) => {
    targets.forEach(observeTarget);
  };
  const initObserver = () => {
    observer.value = new IntersectionObserver(cb, options.value);
  };
  const isIntersectionDisabled = computed(() => !enabled || !(typeof window !== "undefined" && "IntersectionObserver" in window));
  watch([target, options], ([newTarget]) => {
    if (isIntersectionDisabled.value) {
      return;
    }
    disconnectObserver();
    if (!newTarget) {
      return;
    }
    initObserver();
    Array.isArray(newTarget) ? observeAll(newTarget) : observeTarget(newTarget);
  }, { immediate: true });
  onBeforeUnmount(disconnectObserver);
  return { isIntersectionDisabled };
};

// node_modules/vuestic-ui/dist/es/src/components/va-image/VaImage.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaImage.css";
var VaFallbackProps2 = extractComponentProps(VaFallback);
var _sfc_main29 = defineComponent({
  name: "VaImage",
  components: { VaAspectRatio, VaFallback },
  emits: ["loaded", "error", "fallback"],
  props: {
    ...useComponentPresetProp,
    ...useNativeImgAttributesProps,
    ...VaFallbackProps2,
    ratio: {
      type: [Number, String],
      default: "auto",
      validator: (v2) => {
        if (typeof v2 === "number") {
          return v2 > 0;
        }
        return v2 === "auto";
      }
    },
    fit: {
      type: String,
      default: "cover"
    },
    maxWidth: {
      type: Number,
      default: 0,
      validator: (v2) => v2 >= 0
    },
    lazy: { type: Boolean, default: false },
    placeholderSrc: { type: String, default: "" }
  },
  setup(props2, { emit, slots }) {
    const root2 = ref();
    const image = ref();
    const renderedImage = ref();
    const currentImage = computed(() => renderedImage.value || props2.src);
    const imgWidth = ref(1);
    const imgHeight = ref(1);
    const isLoading = ref(false);
    const isError = ref(false);
    const handleLoad = () => {
      var _a2;
      isLoading.value = true;
      if (!isReadyForLoad.value) {
        return;
      }
      isLoading.value = false;
      renderedImage.value = (_a2 = image.value) == null ? void 0 : _a2.currentSrc;
      getImgSizes();
      emit("loaded", currentImage.value);
    };
    const handleError = (err) => {
      isError.value = true;
      isLoading.value = false;
      emit("error", err || currentImage.value);
    };
    const isIntersecting = ref(false);
    const handleIntersection = (entries, observer) => {
      entries.forEach((entry) => {
        if (!entry.isIntersecting) {
          return;
        }
        isIntersecting.value = true;
        init();
        observer.disconnect();
      });
    };
    const { isIntersectionDisabled } = useIntersectionObserver(handleIntersection, void 0, root2, props2.lazy);
    const isReadyForLoad = computed(() => isIntersectionDisabled.value || isIntersecting.value);
    const isMounted = useIsMounted();
    const isReadyForRender = computed(() => !props2.lazy || props2.lazy && isMounted.value && isReadyForLoad.value);
    const init = () => {
      if (!props2.src || isLoading.value && isIntersectionDisabled.value || !isReadyForLoad.value) {
        return;
      }
      isLoading.value = true;
      isError.value = false;
      nextTick(() => {
        var _a2;
        if (!((_a2 = image.value) == null ? void 0 : _a2.complete)) {
          return;
        }
        if (!image.value.naturalWidth) {
          handleError();
          return;
        }
        handleLoad();
      });
    };
    let timer;
    const getImgSizes = () => {
      clearTimeout(timer);
      if (isLoading.value) {
        timer = window.setTimeout(getImgSizes, 100);
      }
      const { naturalHeight, naturalWidth } = image.value || {};
      if (naturalHeight && naturalWidth) {
        imgWidth.value = naturalHeight;
        imgHeight.value = naturalWidth;
      }
    };
    onBeforeMount(init);
    onBeforeUnmount(() => clearTimeout(timer));
    watch(() => props2.src, init);
    const isPlaceholderPassed = computed(() => {
      var _a2;
      return ((_a2 = slots == null ? void 0 : slots.placeholder) == null ? void 0 : _a2.call(slots)) || props2.placeholderSrc;
    });
    const isLoaderShown = computed(() => {
      var _a2;
      return isLoading.value && !((_a2 = slots == null ? void 0 : slots.loader) == null ? void 0 : _a2.call(slots));
    });
    const isErrorShown = computed(() => {
      var _a2;
      return isError.value && (!((_a2 = slots == null ? void 0 : slots.error) == null ? void 0 : _a2.call(slots)) && !isAnyFallbackPassed.value);
    });
    const isPlaceholderShown = computed(() => (isLoaderShown.value || isErrorShown.value) && isPlaceholderPassed.value);
    const isSuccessfullyLoaded = computed(() => !(isLoading.value || isError.value));
    const imgAttributesComputed = useNativeImgAttributes(props2);
    const aspectRationAttributesComputed = computed(() => ({
      ...pick$1(props2, ["ratio", "maxWidth"]),
      contentWidth: imgWidth.value,
      contentHeight: imgHeight.value
    }));
    const fallbackProps = filterComponentProps(VaFallbackProps2);
    const checkObjectNonEmptyValues = (obj) => !!Object.values(obj || {}).filter((prop) => prop).length;
    const hasFallbackGlobalConfig = computed(() => {
      var _a2, _b, _c, _d;
      return checkObjectNonEmptyValues((_d = (_c = (_b = (_a2 = useGlobalConfig()) == null ? void 0 : _a2.globalConfig) == null ? void 0 : _b.value) == null ? void 0 : _c.components) == null ? void 0 : _d.VaFallback);
    });
    const isAnyFallbackPassed = computed(() => checkObjectNonEmptyValues(fallbackProps.value) || hasFallbackGlobalConfig.value);
    const fitComputed = computed(() => props2.fit);
    return {
      fitComputed,
      root: root2,
      image,
      isLoading,
      handleLoad,
      isError,
      handleError,
      isReadyForRender,
      isPlaceholderShown,
      isSuccessfullyLoaded,
      imgAttributesComputed,
      aspectRationAttributesComputed,
      isAnyFallbackPassed,
      fallbackProps
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-image/VaImage.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaImage.css";
var _hoisted_111 = ["aria-busy"];
var _hoisted_26 = {
  key: 0,
  class: "va-image__overlay"
};
var _hoisted_33 = {
  key: 1,
  class: "va-image__error"
};
var _hoisted_43 = {
  key: 2,
  class: "va-image__loader"
};
var _hoisted_53 = {
  key: 3,
  class: "va-image__placeholder"
};
var _hoisted_63 = ["src"];
function _sfc_render26(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_fallback = resolveComponent("va-fallback");
  const _component_va_aspect_ratio = resolveComponent("va-aspect-ratio");
  return openBlock(), createBlock(_component_va_aspect_ratio, mergeProps({
    ref: "root",
    class: "va-image"
  }, _ctx.aspectRationAttributesComputed, {
    style: `--va-fit-computed: ${String(_ctx.fitComputed)}`
  }), {
    default: withCtx(() => [
      withDirectives(createBaseVNode("picture", {
        class: "va-image__content",
        "aria-busy": _ctx.isLoading
      }, [
        _ctx.$slots.sources ? renderSlot(_ctx.$slots, "sources", { key: 0 }) : createCommentVNode("", true),
        _ctx.isReadyForRender ? (openBlock(), createElementBlock("img", mergeProps({
          key: 1,
          ref: "image"
        }, _ctx.imgAttributesComputed, {
          onError: _cache[0] || (_cache[0] = (...args) => _ctx.handleError && _ctx.handleError(...args)),
          onLoad: _cache[1] || (_cache[1] = (...args) => _ctx.handleLoad && _ctx.handleLoad(...args))
        }), null, 16)) : createCommentVNode("", true)
      ], 8, _hoisted_111), [
        [vShow, _ctx.isSuccessfullyLoaded]
      ]),
      _ctx.$slots.default && _ctx.isSuccessfullyLoaded ? (openBlock(), createElementBlock("div", _hoisted_26, [
        renderSlot(_ctx.$slots, "default")
      ])) : createCommentVNode("", true),
      _ctx.isError && (_ctx.$slots.error || _ctx.isAnyFallbackPassed) ? (openBlock(), createElementBlock("div", _hoisted_33, [
        renderSlot(_ctx.$slots, "error", {}, () => [
          createVNode(_component_va_fallback, mergeProps(_ctx.fallbackProps, {
            onFallback: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("fallback"))
          }), null, 16)
        ])
      ])) : createCommentVNode("", true),
      _ctx.isLoading && _ctx.$slots.loader ? (openBlock(), createElementBlock("div", _hoisted_43, [
        renderSlot(_ctx.$slots, "loader")
      ])) : createCommentVNode("", true),
      _ctx.isPlaceholderShown ? (openBlock(), createElementBlock("div", _hoisted_53, [
        renderSlot(_ctx.$slots, "placeholder", {}, () => [
          _ctx.$props.placeholderSrc ? (openBlock(), createElementBlock("img", {
            key: 0,
            src: _ctx.$props.placeholderSrc,
            alt: ""
          }, null, 8, _hoisted_63)) : createCommentVNode("", true)
        ])
      ])) : createCommentVNode("", true)
    ]),
    _: 3
  }, 16, ["style"]);
}
var _VaImage = _export_sfc(_sfc_main29, [["render", _sfc_render26]]);

// node_modules/vuestic-ui/dist/es/src/components/va-image/index.js
var VaImage = withConfigTransport$1(_VaImage);

// node_modules/vuestic-ui/dist/es/src/components/va-hover/VaHover.vue_vue_type_script_lang.js
var _sfc_main30 = defineComponent({
  name: "VaHover",
  props: {
    ...createStatefulProps(true),
    ...useComponentPresetProp,
    disabled: { type: Boolean, default: false },
    modelValue: { type: Boolean, default: false }
  },
  emits: [...useStatefulEmits],
  setup(props2, { emit }) {
    const { valueComputed } = useStateful(props2, emit);
    const onMouseEnter = () => {
      if (!props2.disabled) {
        valueComputed.value = true;
      }
    };
    const onMouseLeave = () => {
      if (!props2.disabled) {
        valueComputed.value = false;
      }
    };
    return { onMouseEnter, onMouseLeave, valueComputed };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-hover/VaHover.js
function _sfc_render27(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "va-hover",
    onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
    onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args))
  }, [
    renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ hover: _ctx.valueComputed })))
  ], 32);
}
var _VaHover = _export_sfc(_sfc_main30, [["render", _sfc_render27]]);

// node_modules/vuestic-ui/dist/es/src/components/va-hover/index.js
var VaHover = withConfigTransport$1(_VaHover);

// node_modules/vuestic-ui/dist/es/src/composables/useSwipe.js
var mouseEvents = ["mousedown", "mousemove"];
var touchEvents = ["touchstart", "touchmove"];
var commonAllowedDirections = {
  vertical: ["", "all", "vertical"],
  horizontal: ["", "all", "horizontal"]
};
var verticalSpecificAllowedDirections = [...commonAllowedDirections.vertical, "up", "down"];
var horizontalSpecificAllowedDirections = [...commonAllowedDirections.horizontal, "left", "right"];
var useSwipeProps = {
  swipable: { type: Boolean, default: false },
  swipeDistance: { type: Number, default: 75 },
  swipeDirection: { type: String, default: "all" }
};
var useSwipe = (props2, container, cb) => {
  const swipeStarted = ref(false);
  const swipePath = reactive({
    start: { x: 0, y: 0 },
    end: { x: 0, y: 0 }
  });
  const swipeDuration = reactive({
    start: 0,
    end: 0
  });
  const setState = (e2, type) => {
    let event;
    if (mouseEvents.includes(e2.type)) {
      event = e2;
    }
    if (touchEvents.includes(e2.type)) {
      const touchEvent = e2;
      event = touchEvent.changedTouches[touchEvent.changedTouches.length - 1];
    }
    if (!event) {
      return;
    }
    swipePath[type].x = event.pageX;
    swipePath[type].y = event.pageY;
    swipeDuration[type] = (/* @__PURE__ */ new Date()).getTime();
  };
  const onSwipeStart = (e2) => {
    if (!props2.swipable || swipeStarted.value) {
      return;
    }
    swipeStarted.value = true;
    setState(e2, "start");
  };
  const onSwipeMove = (e2) => {
    if (!swipeStarted.value) {
      return;
    }
    setState(e2, "end");
  };
  const resetSwipe = () => {
    ["start", "end"].forEach((type) => {
      swipePath[type].x = 0;
      swipePath[type].y = 0;
      swipeDuration[type] = 0;
    });
    swipeStarted.value = false;
  };
  const isSwipeAllowed = reactive({
    vertical: false,
    horizontal: false
  });
  watchEffect(() => {
    isSwipeAllowed.horizontal = horizontalSpecificAllowedDirections.includes(props2.swipeDirection);
    isSwipeAllowed.vertical = verticalSpecificAllowedDirections.includes(props2.swipeDirection);
  });
  const calcDistance = (axis) => {
    return isSwipeAllowed[axis === "x" ? "horizontal" : "vertical"] && swipePath.start[axis] && swipePath.end[axis] ? Math.trunc(swipePath.start[axis] - swipePath.end[axis]) : 0;
  };
  const getAcceptableValue = (direction, result) => {
    return result === props2.swipeDirection || commonAllowedDirections[direction].includes(props2.swipeDirection) ? result : "";
  };
  const swipeState = reactive({ direction: "", duration: 0 });
  watch(swipePath, () => {
    const xDistance = calcDistance("x");
    const yDistance = calcDistance("y");
    if ((xDistance || yDistance) && [xDistance, yDistance].some((el) => Math.abs(el) >= props2.swipeDistance)) {
      if (Math.abs(xDistance) >= Math.abs(yDistance) && isSwipeAllowed.horizontal) {
        const result = xDistance > 0 ? "left" : "right";
        swipeState.direction = getAcceptableValue("horizontal", result);
      } else if (Math.abs(xDistance) < Math.abs(yDistance) && isSwipeAllowed.vertical) {
        const result = yDistance > 0 ? "down" : "up";
        swipeState.direction = getAcceptableValue("vertical", result);
      }
      swipeState.duration = swipeDuration.end - swipeDuration.start;
      resetSwipe();
    }
  }, { deep: true });
  watch(swipeState, () => cb(swipeState), { deep: true });
  if (props2.swipable) {
    useEvent(["touchstart", "mousedown"], onSwipeStart, container);
    useEvent(["touchmove", "mousemove"], onSwipeMove, container);
    useEvent(["touchcancel", "mouseup", "touchend", "mouseleave"], resetSwipe, container);
  }
  return { swipeState };
};

// node_modules/vuestic-ui/dist/es/src/components/va-carousel/VaCarousel.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaCarousel.css";
var VaImageProps = extractComponentProps(VaImage, ["src", "alt"]);
var _sfc_main31 = defineComponent({
  name: "VaCarousel",
  components: { VaImage, VaButton, VaHover },
  props: {
    ...useSwipeProps,
    ...useStatefulProps,
    ...useComponentPresetProp,
    ...VaImageProps,
    stateful: { type: Boolean, default: true },
    modelValue: { type: Number, default: 0 },
    items: { type: Array, required: true },
    // Animations
    autoscroll: { type: Boolean, default: false },
    autoscrollInterval: { type: Number, default: 5e3 },
    autoscrollPauseDuration: { type: Number, default: 2e3 },
    infinite: { type: Boolean, default: true },
    fadeKeyframe: { type: String, default: "va-carousel-fade-appear 1s" },
    // Visual
    arrows: { type: Boolean, default: true },
    indicators: { type: Boolean, default: true },
    indicatorTrigger: {
      type: String,
      default: "click",
      validator: (value) => ["click", "hover", "none"].includes(value)
    },
    vertical: { type: Boolean, default: false },
    height: { type: String, default: "300px" },
    effect: {
      type: String,
      default: "transition",
      validator: (value) => ["fade", "transition"].includes(value)
    },
    color: { type: String, default: "primary" },
    ratio: { type: Number },
    ariaLabel: { type: String, default: "$t:carousel" },
    ariaPreviousLabel: { type: String, default: "$t:goPreviousSlide" },
    ariaNextLabel: { type: String, default: "$t:goNextSlide" },
    ariaGoToSlideLabel: { type: String, default: "$t:goSlide" },
    ariaSlideOfLabel: { type: String, default: "$t:slideOf" }
  },
  emits: [...useStatefulEmits],
  setup(props2, { emit }) {
    const { valueComputed: currentSlide } = useStateful(props2, emit, "modelValue");
    const {
      goTo,
      next,
      prev,
      doShowNextButton,
      doShowPrevButton,
      doShowDirectionButtons
    } = useCarousel(props2, currentSlide);
    const { withPause, computedSlidesStyle, slides } = useCarouselAnimation(props2, currentSlide);
    const isObjectSlides = computed(() => {
      return props2.items.length && props2.items.every((el) => !!el && typeof el === "object" && !!(el == null ? void 0 : el.src));
    });
    const isCurrentSlide = (index) => index === currentSlide.value;
    const slideStyleComputed = computed(() => ({
      animation: props2.effect === "fade" ? "fadeKeyframe" : void 0
    }));
    const slidesContainer = shallowRef();
    const onSwipe = (state) => {
      switch (state.direction) {
        case "right":
        case "up":
          doShowPrevButton.value && prev();
          break;
        case "left":
        case "down":
          doShowNextButton.value && next();
      }
    };
    useSwipe(props2, slidesContainer, onSwipe);
    const getIndicatorEvents = (index) => {
      if (props2.indicatorTrigger === "hover") {
        return { onmouseover: () => goTo(index) };
      }
      if (props2.indicatorTrigger === "click") {
        return { onclick: () => goTo(index) };
      }
      return {};
    };
    const { tp, t: t2 } = useTranslation();
    const {
      computedActiveColor,
      computedColor,
      computedHoverColor
    } = useCarouselColor();
    const vaImageProps = filterComponentProps(VaImageProps);
    const goToWithPause = withPause(goTo);
    const prevWithPause = withPause(prev);
    const nextWithPause = withPause(next);
    return {
      vaImageProps,
      doShowNextButton,
      doShowPrevButton,
      doShowDirectionButtons,
      getIndicatorEvents,
      computedSlidesStyle,
      slideStyleComputed,
      goToWithPause,
      prevWithPause,
      nextWithPause,
      slides,
      isObjectSlides,
      isCurrentSlide,
      computedActiveColor,
      computedColor,
      computedHoverColor,
      tp,
      t: t2,
      slidesContainer
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-carousel/VaCarousel.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaCarousel.css";
var _hoisted_112 = ["aria-label"];
var _hoisted_27 = {
  key: 1,
  class: "va-carousel__indicators"
};
var _hoisted_34 = { class: "va-carousel__content" };
var _hoisted_44 = ["aria-hidden", "aria-current", "aria-label"];
function _sfc_render28(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_hover = resolveComponent("va-hover");
  const _component_va_image = resolveComponent("va-image");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-carousel", {
      "va-carousel--vertical": _ctx.$props.vertical,
      [`va-carousel--${_ctx.$props.effect}`]: true
    }]),
    style: normalizeStyle({ height: _ctx.ratio ? "auto" : _ctx.height }),
    role: "region",
    "aria-label": _ctx.tp(_ctx.$props.ariaLabel)
  }, [
    _ctx.$props.arrows && _ctx.doShowDirectionButtons ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
      _ctx.doShowPrevButton ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "va-carousel__arrow va-carousel__arrow--left",
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.prevWithPause && _ctx.prevWithPause(...args)),
        onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.prevWithPause && _ctx.prevWithPause(...args), ["stop"]), ["enter"]))
      }, [
        renderSlot(_ctx.$slots, "prev-arrow", {}, () => [
          createVNode(_component_va_hover, { stateful: "" }, {
            default: withCtx(({ hover }) => [
              createVNode(_component_va_button, {
                color: hover ? _ctx.computedHoverColor : _ctx.computedColor,
                icon: _ctx.vertical ? "va-arrow-up" : "va-arrow-left",
                "aria-label": _ctx.tp(_ctx.$props.ariaPreviousLabel)
              }, null, 8, ["color", "icon", "aria-label"])
            ]),
            _: 1
          })
        ])
      ], 32)) : createCommentVNode("", true),
      _ctx.doShowNextButton ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: "va-carousel__arrow va-carousel__arrow--right",
        onClick: _cache[2] || (_cache[2] = (...args) => _ctx.nextWithPause && _ctx.nextWithPause(...args)),
        onKeydown: _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => _ctx.nextWithPause && _ctx.nextWithPause(...args), ["stop"]), ["enter"]))
      }, [
        renderSlot(_ctx.$slots, "next-arrow", {}, () => [
          createVNode(_component_va_hover, { stateful: "" }, {
            default: withCtx(({ hover }) => [
              createVNode(_component_va_button, {
                color: hover ? _ctx.computedHoverColor : _ctx.computedColor,
                icon: _ctx.vertical ? "va-arrow-down" : "va-arrow-right",
                "aria-label": _ctx.tp(_ctx.$props.ariaNextLabel)
              }, null, 8, ["color", "icon", "aria-label"])
            ]),
            _: 1
          })
        ])
      ], 32)) : createCommentVNode("", true)
    ], 64)) : createCommentVNode("", true),
    _ctx.$props.indicators ? (openBlock(), createElementBlock("div", _hoisted_27, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.items, (item, index) => {
        return openBlock(), createElementBlock("div", mergeProps({
          class: ["va-carousel__indicator", { "va-carousel__indicator--active": index === _ctx.modelValue }],
          key: index
        }, _ctx.getIndicatorEvents(index)), [
          renderSlot(_ctx.$slots, "indicator", normalizeProps(guardReactiveProps({ item, index, goTo: _ctx.goToWithPause, isActive: _ctx.isCurrentSlide(index) })), () => [
            createVNode(_component_va_hover, { stateful: "" }, {
              default: withCtx(({ hover }) => [
                createVNode(_component_va_button, {
                  "aria-label": _ctx.tp(_ctx.$props.ariaGoToSlideLabel, { index: index + 1 }),
                  round: "",
                  color: _ctx.isCurrentSlide(index) ? _ctx.computedActiveColor : hover ? _ctx.computedHoverColor : _ctx.computedColor
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(index + 1), 1)
                  ]),
                  _: 2
                }, 1032, ["aria-label", "color"])
              ]),
              _: 2
            }, 1024)
          ])
        ], 16);
      }), 128))
    ])) : createCommentVNode("", true),
    createBaseVNode("div", _hoisted_34, [
      createBaseVNode("div", {
        ref: "slidesContainer",
        class: "va-carousel__slides",
        style: normalizeStyle(_ctx.computedSlidesStyle),
        role: "list"
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.slides, (item, index) => {
          return openBlock(), createElementBlock("div", {
            key: item,
            role: "listitem",
            class: "va-carousel__slide",
            style: normalizeStyle(_ctx.slideStyleComputed),
            "aria-hidden": !_ctx.isCurrentSlide(index),
            "aria-current": _ctx.isCurrentSlide(index),
            "aria-label": _ctx.tp(_ctx.$props.ariaSlideOfLabel, { index: index + 1, length: _ctx.slides.length })
          }, [
            renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ item, index, goTo: _ctx.goToWithPause, isActive: _ctx.isCurrentSlide(index) })), () => [
              createVNode(_component_va_image, mergeProps(_ctx.vaImageProps, {
                src: _ctx.isObjectSlides ? item.src : item,
                alt: _ctx.isObjectSlides ? item.alt : "",
                draggable: false
              }), null, 16, ["src", "alt"])
            ])
          ], 12, _hoisted_44);
        }), 128))
      ], 4)
    ])
  ], 14, _hoisted_112);
}
var _VaCarousel = _export_sfc(_sfc_main31, [["render", _sfc_render28]]);

// node_modules/vuestic-ui/dist/es/src/components/va-carousel/index.js
var VaCarousel = withConfigTransport$1(_VaCarousel);

// node_modules/vuestic-ui/dist/es/src/composables/useComponentUuid.js
var useComponentUuid = () => {
  const vm = getCurrentInstance();
  if (!vm.appContext.app) {
    return vm.uid;
  }
  return vm.uid + vm.appContext.app._uid;
};

// node_modules/vuestic-ui/dist/es/src/components/va-message-list/hooks/useMessageListAria.js
var useMessageListAria = (props2) => {
  const id = useComponentUuid();
  const messageListId = `message-list-${id}`;
  const messageListAttributes = computed(() => ({
    id: messageListId,
    role: "alert"
  }));
  const doHaveMessages = computed(() => {
    if (typeof props2.modelValue === "string" && props2.modelValue.length > 0) {
      return true;
    }
    if (Array.isArray(props2.modelValue) && props2.modelValue.length > 0) {
      return true;
    }
    return false;
  });
  const childAttributes = computed(() => ({
    "aria-describedby": doHaveMessages.value ? messageListId : void 0,
    "aria-invalid": props2.hasError
  }));
  return {
    messageListAttributes,
    childAttributes
  };
};

// node_modules/vuestic-ui/dist/es/src/utils/with-attributes.js
var WithAttributes = defineComponent({
  name: "SlotWithAttributes",
  props: {
    attrs: { type: Object }
  },
  render() {
    var _a2;
    return renderSlotNode(this.$slots.default, null, this.$props.attrs || ((_a2 = this.$parent) == null ? void 0 : _a2.$attrs));
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-message-list/VaMessageList.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaMessageList.css";
var _sfc_main32 = defineComponent({
  name: "VaMessageList",
  components: { VaIcon, WithAttributes },
  props: {
    modelValue: {
      type: [String, Array],
      default: ""
    },
    limit: { type: Number, default: 1 },
    color: { type: String },
    hasError: { type: Boolean, default: false }
  },
  inheritAttrs: false,
  setup(props2, { slots }) {
    const { getColor } = useColors();
    const { childAttributes, messageListAttributes } = useMessageListAria(props2);
    return {
      messageListAttributes,
      childAttributes: computed(() => childAttributes.value),
      messages: computed(() => {
        if (!props2.modelValue) {
          return [];
        }
        if (!Array.isArray(props2.modelValue)) {
          return [props2.modelValue];
        }
        return props2.modelValue.slice(0, props2.limit);
      }),
      computedStyle: computed(() => props2.color ? { color: getColor(props2.color) } : {})
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-message-list/VaMessageList.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaMessageList.css";
var _hoisted_113 = { class: "va-message-list__list" };
function _sfc_render29(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_WithAttributes = resolveComponent("WithAttributes");
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock(Fragment, null, [
    createVNode(_component_WithAttributes, null, {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ ariaAttributes: _ctx.childAttributes, messages: _ctx.messages })))
      ]),
      _: 3
    }),
    renderSlot(_ctx.$slots, "messages", normalizeProps(guardReactiveProps({ ariaAttributes: _ctx.messageListAttributes, messages: _ctx.messages })), () => [
      _ctx.messages.length > 0 ? (openBlock(), createElementBlock("div", mergeProps({
        key: 0,
        class: "va-message-list",
        style: _ctx.computedStyle
      }, _ctx.messageListAttributes), [
        createBaseVNode("ul", _hoisted_113, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.messages, (message, index) => {
            return openBlock(), createElementBlock("li", {
              key: index,
              class: "va-message-list__message"
            }, [
              renderSlot(_ctx.$slots, "message", normalizeProps(guardReactiveProps({ messages: _ctx.messages, message })), () => [
                _ctx.hasError ? (openBlock(), createBlock(_component_va_icon, {
                  key: 0,
                  class: "va-message-list__icon",
                  name: "va-warning",
                  size: 16
                })) : createCommentVNode("", true),
                createTextVNode(toDisplayString(message), 1)
              ])
            ]);
          }), 128))
        ])
      ], 16)) : createCommentVNode("", true)
    ])
  ], 64);
}
var _VaMessageList = _export_sfc(_sfc_main32, [["render", _sfc_render29]]);
var VaMessageList = withConfigTransport$1(_VaMessageList);

// node_modules/vuestic-ui/dist/es/src/utils/with-slot-inheritance/with-slot-inheritance.js
var WithSlotInheritance = (component) => {
  return defineComponent({
    name: "ProxySlots",
    props: {
      inheritSlots: { type: Array, required: true }
    },
    render() {
      var _a2;
      const parentSlots = ((_a2 = this.$parent) == null ? void 0 : _a2.$slots) || {};
      const slotsToProxy = this.$props.inheritSlots || Object.keys(parentSlots);
      const slots = slotsToProxy.reduce(
        (slots2, name) => {
          if (parentSlots[name]) {
            slots2[name] = parentSlots[name];
          }
          return slots2;
        },
        {}
      );
      return h(component, this.$attrs, {
        ...slots,
        ...this.$slots
      });
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/composables/useSyncProp.js
function useSyncProp(propName, props2, emit, defaultValue) {
  if (defaultValue === void 0) {
    return [
      computed({
        set(value) {
          emit(`update:${propName}`, value);
        },
        get() {
          return props2[propName];
        }
      })
    ];
  }
  const currentValue = props2[propName];
  const statefulValue = ref(currentValue === void 0 ? defaultValue : currentValue);
  watch(() => props2[propName], (newVal) => {
    if (newVal === void 0) {
      return;
    }
    statefulValue.value = newVal;
  });
  return [
    computed({
      set(value) {
        statefulValue.value = value;
        emit(`update:${propName}`, value);
      },
      get() {
        return props2[propName] === void 0 ? statefulValue.value : props2[propName];
      }
    })
  ];
}

// node_modules/vuestic-ui/dist/es/src/utils/watch-setter.js
var isComputedRef = (value) => {
  return typeof value === "object" && "_setter" in value;
};
var watchSetter = (ref2, cb) => {
  if (!isComputedRef(ref2)) {
    return;
  }
  const originalSetter = ref2._setter;
  ref2._setter = (newValue) => {
    cb(newValue);
    originalSetter(newValue);
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useForm/consts.js
var FormServiceKey = Symbol("FormService");

// node_modules/vuestic-ui/dist/es/src/composables/useForm/useFormChild.js
var useFormChild = (context) => {
  const formContext = inject(FormServiceKey, null);
  if (!formContext) {
    return {
      isFormDirty: ref(false),
      isFormImmediate: ref(false),
      doShowError: ref(true),
      doShowErrorMessages: ref(true),
      doShowLoading: ref(true)
    };
  }
  const uid = useComponentUuid();
  onMounted(() => {
    formContext.registerField(uid, context);
  });
  onBeforeUnmount(() => {
    formContext.unregisterField(uid);
  });
  return {
    isFormDirty: formContext.isFormDirty,
    isFormImmediate: formContext.immediate,
    doShowError: formContext.doShowError,
    doShowErrorMessages: formContext.doShowErrorMessages,
    doShowLoading: formContext.doShowLoading
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useValidation.js
var normalizeValidationRules = (rules = [], callArguments = null) => {
  if (isString$1(rules)) {
    rules = [rules];
  }
  return rules.map((rule) => isFunction$4(rule) ? rule(callArguments) : rule);
};
var useValidationProps = {
  name: { type: String, default: void 0 },
  modelValue: { required: false },
  dirty: { type: Boolean, default: false },
  error: { type: Boolean, default: void 0 },
  errorMessages: { type: [Array, String], default: void 0 },
  errorCount: { type: [String, Number], default: 1 },
  rules: { type: Array, default: () => [] },
  success: { type: Boolean, default: false },
  messages: { type: [Array, String], default: () => [] },
  immediateValidation: { type: Boolean, default: false }
};
var useValidationEmits = ["update:error", "update:errorMessages", "update:dirty"];
var isPromise = (value) => {
  return typeof value === "object" && typeof value.then === "function";
};
var useDirtyValue = (value, props2, emit) => {
  const isDirty = ref(false);
  watchSetter(value, () => {
    isDirty.value = true;
    emit("update:dirty", true);
  });
  watch(() => props2.dirty, (newValue) => {
    if (isDirty.value === newValue) {
      return;
    }
    isDirty.value = newValue;
  });
  return { isDirty };
};
var useValidation = (props2, emit, options) => {
  const { reset, focus } = options;
  const { isFocused, onFocus, onBlur } = useFocus();
  const [computedError] = useSyncProp("error", props2, emit, false);
  const [computedErrorMessages] = useSyncProp("errorMessages", props2, emit, []);
  const isLoading = ref(false);
  const validationAriaAttributes = computed(() => ({
    "aria-invalid": computedError.value,
    "aria-errormessage": typeof computedErrorMessages.value === "string" ? computedErrorMessages.value : computedErrorMessages.value.join(", ")
  }));
  const resetValidation = () => {
    computedError.value = false;
    computedErrorMessages.value = [];
    isDirty.value = false;
  };
  const processResults = (results) => {
    let error = false;
    let errorMessages = [];
    results.forEach((result) => {
      if (isString$1(result)) {
        errorMessages = [...errorMessages, result];
        error = true;
      } else if (result === false) {
        error = true;
      }
    });
    computedErrorMessages.value = errorMessages;
    computedError.value = error;
    return !error;
  };
  const validateAsync = async () => {
    if (!props2.rules || !props2.rules.length) {
      return true;
    }
    const results = normalizeValidationRules(flatten$2(props2.rules), options.value.value);
    const asyncPromiseResults = results.filter((result) => isPromise(result));
    const syncRules = results.filter((result) => !isPromise(result));
    if (!asyncPromiseResults.length) {
      return processResults(syncRules);
    }
    isLoading.value = true;
    return Promise.all(asyncPromiseResults).then((asyncResults) => {
      isLoading.value = false;
      return processResults([...syncRules, ...asyncResults]);
    });
  };
  const validate = () => {
    if (!props2.rules || !props2.rules.length) {
      return true;
    }
    const rules = flatten$2(props2.rules);
    const results = normalizeValidationRules(rules, options.value.value);
    const asyncPromiseResults = results.filter((result) => isPromise(result));
    const syncRules = results.filter((result) => !isPromise(result));
    const isSyncedError = syncRules.some((result) => isString$1(result) ? result : result === false);
    if (asyncPromiseResults.length && !isSyncedError) {
      isLoading.value = true;
      Promise.all(asyncPromiseResults).then((asyncResults) => {
        processResults([...syncRules, ...asyncResults]);
        isLoading.value = false;
      });
      return isSyncedError;
    }
    return processResults(syncRules);
  };
  watch(isFocused, (newVal) => !newVal && validate());
  const immediateValidation = computed(() => props2.immediateValidation || isFormImmediate.value);
  let canValidate = true;
  const withoutValidation = (cb) => {
    if (immediateValidation.value) {
      return cb();
    }
    canValidate = false;
    cb();
    nextTick(() => {
      canValidate = true;
    });
  };
  watch(options.value, () => {
    if (!canValidate) {
      return;
    }
    return validate();
  }, { immediate: true });
  const { isDirty } = useDirtyValue(options.value, props2, emit);
  const {
    doShowErrorMessages,
    // Renamed to forceHideError because it's not clear what it does
    doShowError,
    doShowLoading,
    isFormImmediate,
    isFormDirty
  } = useFormChild({
    isDirty,
    isValid: computed(() => !computedError.value),
    isLoading,
    errorMessages: computedErrorMessages,
    validate,
    validateAsync,
    resetValidation,
    focus,
    reset: () => {
      reset();
      resetValidation();
      isDirty.value = false;
    },
    value: computed(() => options.value || props2.modelValue),
    name: toRef(props2, "name")
  });
  return {
    isDirty,
    computedError: computed(() => {
      if (!isFormDirty.value) {
        if (!immediateValidation.value && !isDirty.value) {
          return false;
        }
      }
      return doShowError.value ? computedError.value : false;
    }),
    computedErrorMessages: computed(() => doShowErrorMessages.value ? computedErrorMessages.value : []),
    isLoading: computed(() => doShowLoading.value ? isLoading.value : false),
    listeners: { onFocus, onBlur },
    validate,
    resetValidation,
    withoutValidation,
    validationAriaAttributes
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-message-list/VaMessageListWrapper.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaMessageListWrapper.css";
var _sfc_main33 = defineComponent({
  name: "VaMessageListWrapper",
  components: { VaMessageList: WithSlotInheritance(VaMessageList) },
  props: {
    ...useValidationProps
  },
  setup(props2) {
    return {
      messagesColor: computed(() => {
        if (props2.error) {
          return "danger";
        }
        if (props2.success) {
          return "success";
        }
        return "";
      }),
      hasError: toRef(props2, "error"),
      messagesComputed: computed(() => props2.error ? props2.errorMessages : props2.messages),
      errorLimit: computed(() => props2.error ? Number(props2.errorCount) : 99)
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-message-list/VaMessageListWrapper.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaMessageListWrapper.css";
var _hoisted_114 = { class: "va-message-list-wrapper" };
function _sfc_render30(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_message_list = resolveComponent("va-message-list");
  return openBlock(), createElementBlock("div", _hoisted_114, [
    createVNode(_component_va_message_list, {
      color: _ctx.messagesColor,
      limit: _ctx.errorLimit,
      "has-error": _ctx.hasError,
      "model-value": _ctx.messagesComputed,
      "inherit-slots": ["message"]
    }, {
      default: withCtx((bind) => [
        renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(bind)))
      ]),
      _: 3
    }, 8, ["color", "limit", "has-error", "model-value"])
  ]);
}
var VaMessageListWrapper = _export_sfc(_sfc_main33, [["render", _sfc_render30]]);

// node_modules/vuestic-ui/dist/es/src/composables/useSelectable.js
var useSelectableProps = {
  ...useStatefulProps,
  ...useLoadingProps,
  ...useValidationProps,
  arrayValue: { type: [String, Boolean, Object, Number], default: void 0 },
  label: { type: String, default: "" },
  leftLabel: { type: Boolean, default: false },
  trueValue: { type: null, default: true },
  falseValue: { type: null, default: false },
  indeterminate: { type: Boolean, default: false },
  indeterminateValue: { type: null, default: null },
  disabled: { type: Boolean, default: false },
  readonly: { type: Boolean, default: false }
};
var useSelectableEmits = [...useValidationEmits, "update:modelValue", "focus", "blur"];
var checkDuplicates = (props2) => {
  const values = [props2.falseValue, props2.trueValue];
  if (props2.indeterminate) {
    values.push(props2.indeterminateValue);
  }
  const hasDuplicates = new Set(values).size !== values.length;
  if (hasDuplicates) {
    throw new Error("falseValue, trueValue, indeterminateValue props should have strictly different values, which is not the case.");
  }
};
var useSelectable = (props2, emit, { input, label, container }) => {
  checkDuplicates(props2);
  const reset = () => withoutValidation(() => {
    emit("update:modelValue", false);
    resetValidation();
  });
  const focus = () => {
    var _a2;
    (_a2 = unwrapEl(input.value)) == null ? void 0 : _a2.focus();
  };
  const { valueComputed } = useStateful(props2, emit);
  const {
    computedError,
    computedErrorMessages,
    validate,
    validationAriaAttributes,
    withoutValidation,
    resetValidation
  } = useValidation(props2, emit, { reset, focus, value: valueComputed });
  const { isFocused } = useFocus();
  const isElementRelated = (element) => {
    return !!element && [unwrapEl(label.value), unwrapEl(container.value)].includes(element);
  };
  const onBlur = (event) => {
    if (input.value === event.target && !isElementRelated(event.relatedTarget)) {
      isFocused.value = false;
      validate();
      emit("blur", event);
    }
  };
  const onFocus = (event) => {
    isFocused.value = true;
    emit("focus", event);
  };
  const isIndeterminate = computed(() => props2.indeterminate && valueComputed.value === props2.indeterminateValue);
  const modelIsArray = computed(() => props2.arrayValue !== void 0 && props2.arrayValue !== null);
  const isChecked = computed(() => {
    var _a2;
    if (modelIsArray.value) {
      return (_a2 = props2.modelValue) == null ? void 0 : _a2.includes(props2.arrayValue);
    }
    return valueComputed.value === props2.trueValue;
  });
  const toggleSelection = () => {
    if (props2.readonly || props2.disabled || props2.loading) {
      return;
    }
    if (modelIsArray.value) {
      if (!props2.modelValue) {
        emit("update:modelValue", [props2.arrayValue]);
      } else if (!Array.isArray(props2.modelValue)) {
        emit("update:modelValue", props2.modelValue === props2.arrayValue ? [] : [props2.modelValue, props2.arrayValue]);
      } else if (props2.modelValue.includes(props2.arrayValue)) {
        emit("update:modelValue", props2.modelValue.filter((option) => option !== props2.arrayValue));
      } else {
        emit("update:modelValue", props2.modelValue.concat(props2.arrayValue));
      }
      return;
    }
    if (props2.indeterminate) {
      if (isIndeterminate.value) {
        valueComputed.value = props2.trueValue;
      } else if (isChecked.value) {
        valueComputed.value = props2.falseValue;
      } else {
        valueComputed.value = props2.indeterminateValue;
      }
      return;
    }
    if (isChecked.value) {
      valueComputed.value = props2.falseValue;
    } else {
      valueComputed.value = props2.trueValue;
    }
  };
  return {
    isChecked,
    isIndeterminate,
    onBlur,
    onFocus,
    toggleSelection,
    reset,
    focus,
    computedError,
    computedErrorMessages,
    validationAriaAttributes
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useKeyboardOnlyFocus.js
var _a;
function useKeyboardOnlyFocus() {
  const hasKeyboardFocus = ref(false);
  let previouslyClicked2 = false;
  const keyboardFocusListeners = {
    mousedown: () => {
      previouslyClicked2 = true;
    },
    focus: () => {
      if (!previouslyClicked2) {
        hasKeyboardFocus.value = true;
      }
      previouslyClicked2 = false;
    },
    blur: () => {
      hasKeyboardFocus.value = false;
      previouslyClicked2 = false;
    }
  };
  return {
    hasKeyboardFocus,
    keyboardFocusListeners
  };
}
var previouslyClicked = false;
(_a = getWindow()) == null ? void 0 : _a.addEventListener("mousedown", () => {
  previouslyClicked = true;
  setTimeout(() => {
    previouslyClicked = false;
  }, 300);
});
function useKeyboardOnlyFocusGlobal() {
  const hasKeyboardFocus = ref(false);
  const keyboardFocusListeners = {
    focus: () => {
      if (!previouslyClicked) {
        hasKeyboardFocus.value = true;
      }
    },
    blur: () => {
      hasKeyboardFocus.value = false;
    }
  };
  return {
    hasKeyboardFocus,
    keyboardFocusListeners
  };
}

// node_modules/vuestic-ui/dist/es/src/components/va-checkbox/VaCheckbox.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaCheckbox.css";
var VaCheckboxValueType = [Boolean, Array, String, Object];
var _sfc_main34 = defineComponent({
  name: "VaCheckbox",
  components: { VaMessageListWrapper, VaIcon },
  emits: useSelectableEmits,
  props: {
    ...useSelectableProps,
    ...useComponentPresetProp,
    modelValue: { type: VaCheckboxValueType, default: false },
    color: { type: String, default: "primary" },
    checkedIcon: { type: String, default: "va-check" },
    indeterminate: { type: Boolean, default: false },
    indeterminateValue: { type: VaCheckboxValueType, default: null },
    indeterminateIcon: { type: String, default: "remove" },
    id: { type: String, default: "" },
    name: { type: String, default: "" },
    ariaLabel: { type: String, default: void 0 },
    vertical: { type: Boolean, default: false }
  },
  setup(props2, { emit }) {
    const elements = {
      container: shallowRef(),
      input: shallowRef(),
      label: shallowRef()
    };
    const {
      isChecked,
      computedError,
      isIndeterminate,
      computedErrorMessages,
      validationAriaAttributes,
      toggleSelection,
      onBlur,
      onFocus
    } = useSelectable(props2, emit, elements);
    const { getColor } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const { textColorComputed } = useTextColor(computed(() => getColor(props2.color)));
    const isActive = computed(() => isChecked.value || isIndeterminate.value);
    const computedClass = computed(() => ({
      "va-checkbox--selected": isChecked.value,
      "va-checkbox--readonly": props2.readonly,
      "va-checkbox--disabled": props2.disabled,
      "va-checkbox--indeterminate": props2.indeterminate,
      "va-checkbox--error": computedError.value,
      "va-checkbox--left-label": props2.leftLabel,
      "va-checkbox--on-keyboard-focus": hasKeyboardFocus.value
    }));
    const getPaddingStyle = () => {
      switch (true) {
        case !props2.label:
          return "";
        case props2.vertical:
          return "var(--va-checkbox-vertical-padding)";
        case Boolean(props2.arrayValue):
          return "var(--va-checkbox-horizontal-padding)";
        case props2.leftLabel:
          return "var(--va-checkbox-right-padding)";
        default:
          return "var(--va-checkbox-left-padding)";
      }
    };
    const labelStyle = computed(() => {
      return {
        color: computedError.value ? getColor("danger") : props2.success ? getColor("success") : "",
        padding: getPaddingStyle()
      };
    });
    const inputStyle = computed(() => {
      const style = {
        background: isActive.value ? getColor(props2.color) : "",
        borderColor: isActive.value ? getColor(props2.color) : ""
      };
      if (computedError.value) {
        style.borderColor = getColor("danger");
      }
      if (props2.success) {
        style.borderColor = getColor("success");
      }
      return style;
    });
    const computedIconName = computed(
      () => props2.indeterminate && isIndeterminate.value ? props2.indeterminateIcon : props2.checkedIcon
    );
    const uniqueId2 = computed(generateUniqueId);
    const computedId = computed(() => props2.id || uniqueId2.value);
    const computedName = computed(() => props2.name || uniqueId2.value);
    const inputAttributesComputed = computed(() => ({
      name: computedName.value,
      disabled: props2.disabled,
      readonly: props2.readonly,
      tabindex: props2.disabled ? -1 : 0,
      "aria-label": props2.ariaLabel,
      "aria-disabled": props2.disabled,
      "aria-readOnly": props2.readonly,
      "aria-checked": isActive.value,
      ...validationAriaAttributes.value
    }));
    const displayVal = computed(() => props2.vertical ? "--va-checkbox-display-flex" : "var(--va-checkbox-display)");
    return {
      displayVal,
      isActive,
      computedClass,
      labelStyle,
      inputStyle,
      computedIconName,
      textColorComputed,
      computedError,
      computedErrorMessages,
      keyboardFocusListeners,
      toggleSelection,
      onBlur,
      onFocus,
      inputAttributesComputed,
      computedId,
      computedName
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-checkbox/VaCheckbox.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaCheckbox.css";
var _hoisted_115 = ["id", "indeterminate", "value", "checked"];
var _hoisted_28 = ["for"];
function _sfc_render31(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_VaMessageListWrapper = resolveComponent("VaMessageListWrapper");
  return openBlock(), createBlock(_component_VaMessageListWrapper, {
    class: normalizeClass(["va-checkbox", _ctx.computedClass]),
    disabled: _ctx.disabled,
    success: _ctx.success,
    messages: _ctx.messages,
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages,
    "error-count": _ctx.errorCount,
    style: normalizeStyle(`--va-display-val: ${String(_ctx.displayVal)}`)
  }, {
    default: withCtx(() => [
      createBaseVNode("div", {
        ref: "container",
        class: "va-checkbox__input-container",
        onClick: _cache[6] || (_cache[6] = (...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args)),
        onBlur: _cache[7] || (_cache[7] = (...args) => _ctx.onBlur && _ctx.onBlur(...args))
      }, [
        createBaseVNode("div", {
          class: "va-checkbox__square",
          style: normalizeStyle(_ctx.inputStyle),
          onSelectstart: _cache[4] || (_cache[4] = withModifiers(() => {
          }, ["prevent"]))
        }, [
          createBaseVNode("input", mergeProps({
            ref: "input",
            type: "checkbox",
            class: "va-checkbox__input",
            id: _ctx.computedId,
            indeterminate: _ctx.indeterminate,
            value: _ctx.label,
            checked: _ctx.isActive
          }, _ctx.inputAttributesComputed, toHandlers(_ctx.keyboardFocusListeners, true), {
            onFocus: _cache[0] || (_cache[0] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
            onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
            onClick: _cache[2] || (_cache[2] = withModifiers(() => {
            }, ["stop", "prevent"])),
            onKeypress: _cache[3] || (_cache[3] = withModifiers((...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args), ["prevent"]))
          }), null, 16, _hoisted_115),
          withDirectives(createVNode(_component_va_icon, {
            class: "va-checkbox__icon",
            name: _ctx.computedIconName,
            color: _ctx.textColorComputed
          }, null, 8, ["name", "color"]), [
            [vShow, _ctx.isActive]
          ])
        ], 36),
        _ctx.label || _ctx.$slots.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          ref: "label",
          class: "va-checkbox__label",
          for: _ctx.computedId,
          style: normalizeStyle(_ctx.labelStyle),
          onBlur: _cache[5] || (_cache[5] = (...args) => _ctx.onBlur && _ctx.onBlur(...args))
        }, [
          renderSlot(_ctx.$slots, "label", {}, () => [
            createTextVNode(toDisplayString(_ctx.label), 1)
          ])
        ], 44, _hoisted_28)) : createCommentVNode("", true)
      ], 544)
    ]),
    _: 3
  }, 8, ["class", "disabled", "success", "messages", "error", "error-messages", "error-count", "style"]);
}
var _VaCheckbox = _export_sfc(_sfc_main34, [["render", _sfc_render31]]);

// node_modules/vuestic-ui/dist/es/src/components/va-checkbox/index.js
var VaCheckbox = withConfigTransport$1(_VaCheckbox);

// node_modules/vuestic-ui/dist/es/src/components/va-chip/VaChip.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaChip.css";
var _sfc_main35 = defineComponent({
  name: "VaChip",
  components: { VaIcon },
  emits: [...useStatefulEmits, "focus"],
  props: {
    ...useRouterLinkProps,
    ...useColorProps,
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Boolean, default: true },
    closeable: { type: Boolean, default: false },
    outline: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    square: { type: Boolean, default: false },
    shadow: { type: Boolean, default: false },
    flat: { type: Boolean, default: false },
    icon: { type: String, default: "" },
    tag: { type: String, default: "span" },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["small", "medium", "large"].includes(value)
    },
    ariaCloseLabel: { type: String, default: "$t:close" }
  },
  setup(props2, { emit }) {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props2.color));
    const borderColor = computed(() => props2.outline ? colorComputed.value : "");
    const isTransparentBackground = computed(() => Boolean(props2.outline || props2.flat));
    const { textColorComputed } = useTextColor(colorComputed, isTransparentBackground);
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const shadowStyle = computed(() => {
      if (!props2.shadow || props2.flat || props2.outline || props2.disabled || hasKeyboardFocus.value) {
        return;
      }
      return `0 0.125rem 0.19rem 0 ${getBoxShadowColor(colorComputed.value)}`;
    });
    const { valueComputed } = useStateful(props2, emit);
    const { tagComputed, hrefComputed } = useRouterLink(props2);
    const { isHovered, onMouseEnter, onMouseLeave } = useHover();
    return {
      ...useTranslation(),
      keyboardFocusListeners,
      valueComputed,
      hrefComputed,
      tagComputed,
      onMouseEnter,
      onMouseLeave,
      isHovered,
      close: () => {
        if (!props2.disabled) {
          valueComputed.value = false;
        }
      },
      iconSize: computed(() => props2.size),
      tabIndexComputed: computed(() => props2.disabled ? -1 : 0),
      computedClass: useBem("va-chip", () => ({
        ...pick$1(props2, ["disabled", "readonly", "square"]),
        small: props2.size === "small",
        large: props2.size === "large"
      })),
      computedStyle: computed(() => {
        const result = {
          color: textColorComputed.value,
          borderColor: borderColor.value,
          background: "",
          boxShadow: shadowStyle.value
        };
        if (props2.outline || props2.flat) {
          if (hasKeyboardFocus.value) {
            result.background = getFocusColor(colorComputed.value);
          } else if (!props2.readonly && isHovered.value) {
            result.background = getHoverColor(colorComputed.value);
          }
        } else {
          result.background = colorComputed.value;
        }
        return result;
      })
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-chip/VaChip.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaChip.css";
var _hoisted_116 = { class: "va-chip__content" };
function _sfc_render32(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return _ctx.valueComputed ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
    key: 0,
    class: normalizeClass(["va-chip", _ctx.computedClass]),
    href: _ctx.hrefComputed,
    target: _ctx.target,
    to: _ctx.to,
    replace: _ctx.replace,
    exact: _ctx.exact,
    "active-class": _ctx.activeClass,
    "exact-active-class": _ctx.exactActiveClass,
    style: normalizeStyle(_ctx.computedStyle)
  }, {
    default: withCtx(() => [
      createBaseVNode("span", mergeProps({
        class: "va-chip__inner",
        onFocus: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("focus")),
        onMouseenter: _cache[1] || (_cache[1] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
        onMouseleave: _cache[2] || (_cache[2] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args))
      }, toHandlers(_ctx.keyboardFocusListeners, true)), [
        _ctx.icon ? (openBlock(), createBlock(_component_va_icon, {
          key: 0,
          class: "va-chip__icon",
          name: _ctx.icon,
          size: _ctx.iconSize
        }, null, 8, ["name", "size"])) : createCommentVNode("", true),
        createBaseVNode("span", _hoisted_116, [
          renderSlot(_ctx.$slots, "default")
        ]),
        _ctx.closeable ? (openBlock(), createBlock(_component_va_icon, {
          key: 1,
          role: "button",
          name: "va-close",
          class: "va-chip__close-icon",
          "aria-label": _ctx.tp(_ctx.$props.ariaCloseLabel),
          tabindex: _ctx.tabIndexComputed,
          size: _ctx.iconSize,
          onClick: withModifiers(_ctx.close, ["stop"]),
          onKeydown: [
            withKeys(withModifiers(_ctx.close, ["stop"]), ["enter"]),
            withKeys(withModifiers(_ctx.close, ["stop"]), ["space"])
          ]
        }, null, 8, ["aria-label", "tabindex", "size", "onClick", "onKeydown"])) : createCommentVNode("", true)
      ], 16)
    ]),
    _: 3
  }, 8, ["href", "target", "to", "replace", "exact", "active-class", "exact-active-class", "class", "style"])) : createCommentVNode("", true);
}
var _VaChip = _export_sfc(_sfc_main35, [["render", _sfc_render32]]);

// node_modules/vuestic-ui/dist/es/src/components/va-chip/index.js
var VaChip = withConfigTransport$1(_VaChip);

// node_modules/vuestic-ui/dist/es/src/composables/useResizeObserver.js
var useResizeObserver = (elementsList, cb) => {
  const resizeObserver = ref();
  const observeAll = (elementsList2) => {
    elementsList2.forEach((element) => {
      var _a2;
      const unrefedElement = unref(element);
      unrefedElement && ((_a2 = resizeObserver.value) == null ? void 0 : _a2.observe(unrefedElement));
    });
  };
  watch(elementsList, (newValue) => {
    var _a2;
    (_a2 = resizeObserver.value) == null ? void 0 : _a2.disconnect();
    observeAll(newValue);
  });
  onMounted(() => {
    resizeObserver.value = new ResizeObserver(cb);
    observeAll(elementsList);
  });
  onBeforeUnmount(() => {
    var _a2;
    return (_a2 = resizeObserver.value) == null ? void 0 : _a2.disconnect();
  });
  return resizeObserver;
};

// node_modules/vuestic-ui/dist/es/src/components/va-collapse/VaCollapse.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaCollapse.css";
var _sfc_main36 = defineComponent({
  name: "VaCollapse",
  components: {
    VaIcon
  },
  props: {
    ...useComponentPresetProp,
    ...useStatefulProps,
    modelValue: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    header: { type: String, default: "" },
    icon: { type: String, default: "" },
    color: { type: String, default: void 0 },
    bodyColor: { type: String, default: void 0 },
    textColor: { type: String, default: "" },
    bodyTextColor: { type: String, default: "" },
    iconColor: { type: String, default: "secondary" },
    colorAll: { type: Boolean, default: false },
    stateful: { type: Boolean, default: true }
  },
  emits: ["update:modelValue", ...useSelectableEmits],
  setup(props2, { emit }) {
    const body = shallowRef();
    const { valueComputed } = useStateful(props2, emit, "modelValue");
    const { getColor, getTextColor, setHSLAColor: setHSLAColor2 } = useColors();
    const { accordionProps, valueProxy: computedModelValue = valueComputed } = useAccordionItem();
    const bodyHeight = ref();
    useResizeObserver([body], () => {
      var _a2;
      bodyHeight.value = ((_a2 = body.value) == null ? void 0 : _a2.clientHeight) ?? 0;
    });
    const height = computed(() => computedModelValue.value ? bodyHeight.value : 0);
    const getTransition = () => {
      const duration = height.value / 1e3 * 0.2;
      return `${duration > 0.2 ? duration : 0.2}s`;
    };
    const contentBackground = computed(() => {
      if (props2.bodyColor) {
        return getColor(props2.bodyColor);
      }
      return props2.color && props2.colorAll ? setHSLAColor2(getColor(props2.color), { a: 0.07 }) : void 0;
    });
    const headerBackground = computed(() => {
      return props2.color ? getColor(props2.color) : void 0;
    });
    const uniqueId2 = computed(generateUniqueId);
    const headerIdComputed = computed(() => `header-${uniqueId2.value}`);
    const panelIdComputed = computed(() => `panel-${uniqueId2.value}`);
    const tabIndexComputed = computed(() => props2.disabled ? -1 : 0);
    const headerAttributes = computed(() => ({
      id: headerIdComputed.value,
      tabindex: tabIndexComputed.value,
      "aria-controls": panelIdComputed.value,
      "aria-expanded": computedModelValue.value,
      "aria-disabled": props2.disabled,
      role: "button"
    }));
    const isHeightChanging = ref(false);
    watch(height, (newValue, oldValue) => {
      if (oldValue === void 0) {
        return;
      }
      isHeightChanging.value = true;
    });
    const onTransitionEnd = (e2) => {
      if (e2.propertyName === "height" && e2.target === e2.currentTarget) {
        isHeightChanging.value = false;
      }
    };
    const computedClasses = useBem("va-collapse", () => ({
      ...pick$1(props2, ["disabled"]),
      expanded: computedModelValue.value,
      active: computedModelValue.value,
      popout: !!(accordionProps.value.popout && computedModelValue.value),
      inset: !!(accordionProps.value.inset && computedModelValue.value),
      "height-changing": isHeightChanging.value,
      "colored-body": Boolean(contentBackground.value),
      "colored-header": Boolean(headerBackground.value)
    }));
    const toggle = () => {
      if (props2.disabled) {
        return;
      }
      computedModelValue.value = !computedModelValue.value;
    };
    const { textColorComputed } = useTextColor(headerBackground);
    const headerStyle = computed(() => ({
      color: textColorComputed.value,
      backgroundColor: headerBackground.value
    }));
    const contentStyle = computed(() => {
      return {
        visibility: bodyHeight.value > 0 ? "visible" : "hidden",
        height: `${height.value}px`,
        transitionDuration: getTransition(),
        background: computedModelValue.value ? contentBackground.value : "",
        color: props2.bodyTextColor ? getColor(props2.bodyTextColor) : contentBackground.value ? getColor(getTextColor(contentBackground.value)) : "currentColor"
      };
    });
    return {
      onTransitionEnd,
      body,
      height,
      toggle,
      computedModelValue,
      headerIdComputed,
      headerAttributes,
      panelIdComputed,
      tabIndexComputed,
      computedClasses,
      headerStyle,
      contentStyle
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-collapse/VaCollapse.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaCollapse.css";
var _hoisted_117 = { class: "va-collapse__header__text" };
var _hoisted_29 = ["id", "aria-labelledby"];
var _hoisted_35 = { class: "va-collapse__content" };
function _sfc_render33(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-collapse", _ctx.computedClasses])
  }, [
    createBaseVNode("div", {
      class: "va-collapse__header-wrapper",
      role: "heading",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.toggle && _ctx.toggle(...args)),
      onKeydown: [
        _cache[1] || (_cache[1] = withKeys((...args) => _ctx.toggle && _ctx.toggle(...args), ["enter"])),
        _cache[2] || (_cache[2] = withKeys((...args) => _ctx.toggle && _ctx.toggle(...args), ["space"]))
      ]
    }, [
      renderSlot(_ctx.$slots, "header", normalizeProps(guardReactiveProps({
        value: _ctx.computedModelValue,
        bind: _ctx.headerAttributes,
        attributes: _ctx.headerAttributes,
        attrs: _ctx.headerAttributes,
        iconAttrs: {
          class: [
            "va-collapse__expand-icon",
            _ctx.computedModelValue ? "a-collapse__expand-icon--expanded" : "a-collapse__expand-icon--collapsed"
          ]
        },
        text: _ctx.header
      })), () => [
        createBaseVNode("div", mergeProps(_ctx.headerAttributes, {
          class: "va-collapse__header",
          style: _ctx.headerStyle
        }), [
          _ctx.icon ? (openBlock(), createBlock(_component_va_icon, {
            key: 0,
            class: "va-collapse__header__icon",
            name: _ctx.icon
          }, null, 8, ["name"])) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "header-content", normalizeProps(guardReactiveProps({ header: _ctx.header })), () => [
            createBaseVNode("div", _hoisted_117, toDisplayString(_ctx.header), 1)
          ]),
          renderSlot(_ctx.$slots, "expand-icon", {}, () => [
            createVNode(_component_va_icon, {
              class: normalizeClass(["va-collapse__expand-icon", _ctx.computedModelValue ? "va-collapse__expand-icon--expanded" : "va-collapse__expand-icon--collapsed"]),
              name: "va-arrow-down"
            }, null, 8, ["class"])
          ])
        ], 16)
      ])
    ], 32),
    createBaseVNode("div", {
      class: normalizeClass(["va-collapse__body-wrapper", {
        "va-collapse__body-wrapper--bordered": !_ctx.$slots.body && !_ctx.$slots.header
      }]),
      style: normalizeStyle(_ctx.contentStyle),
      onTransitionend: _cache[3] || (_cache[3] = (...args) => _ctx.onTransitionEnd && _ctx.onTransitionEnd(...args))
    }, [
      createBaseVNode("div", {
        class: "va-collapse__body",
        ref: "body",
        role: "region",
        id: _ctx.panelIdComputed,
        "aria-labelledby": _ctx.headerIdComputed
      }, [
        renderSlot(_ctx.$slots, "body", {}, () => [
          createBaseVNode("div", _hoisted_35, [
            renderSlot(_ctx.$slots, "default", {}, () => [
              renderSlot(_ctx.$slots, "content")
            ])
          ])
        ])
      ], 8, _hoisted_29)
    ], 38)
  ], 2);
}
var _VaCollapse = _export_sfc(_sfc_main36, [["render", _sfc_render33]]);

// node_modules/vuestic-ui/dist/es/src/components/va-collapse/index.js
var VaCollapse = withConfigTransport$1(_VaCollapse);

// node_modules/vuestic-ui/dist/es/src/components/va-color-indicator/VaColorIndicator.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaColorIndicator.css";
var _sfc_main37 = defineComponent({
  name: "VaColorIndicator",
  emits: [...useStatefulEmits],
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Boolean, default: null },
    color: { type: String, default: "" },
    square: { type: Boolean, default: false },
    size: { type: String, default: "1rem" }
  },
  setup(props2, { emit }) {
    const { valueComputed } = useStateful(props2, emit);
    const { getColor } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const colorComputed = computed(() => getColor(props2.color));
    const borderRadiusComputed = computed(() => props2.square ? "0px" : "50%");
    const computedStyle = computed(() => ({
      backgroundColor: colorComputed.value,
      height: props2.size,
      width: props2.size
    }));
    const computedClass = computed(() => ({
      "va-color-indicator--selected": valueComputed.value,
      "va-color-indicator--on-keyboard-focus": hasKeyboardFocus.value
    }));
    const toggleModelValue = () => {
      valueComputed.value = !valueComputed.value;
    };
    return {
      valueComputed,
      computedStyle,
      computedClass,
      borderRadiusComputed,
      keyboardFocusListeners,
      toggleModelValue
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-color-indicator/VaColorIndicator.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaColorIndicator.css";
function _sfc_render34(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    class: ["va-color-indicator", _ctx.computedClass],
    style: [_ctx.computedStyle, `--va-border-radius-computed: ${String(_ctx.borderRadiusComputed)}`],
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.toggleModelValue && _ctx.toggleModelValue(...args)),
    onKeydown: [
      _cache[1] || (_cache[1] = withKeys((...args) => _ctx.toggleModelValue && _ctx.toggleModelValue(...args), ["enter"])),
      _cache[2] || (_cache[2] = withKeys((...args) => _ctx.toggleModelValue && _ctx.toggleModelValue(...args), ["space"]))
    ]
  }, toHandlers(_ctx.keyboardFocusListeners, true)), [
    createBaseVNode("div", {
      class: "va-color-indicator__core",
      style: normalizeStyle(_ctx.computedStyle)
    }, null, 4)
  ], 16);
}
var _VaColorIndicatort = _export_sfc(_sfc_main37, [["render", _sfc_render34]]);

// node_modules/vuestic-ui/dist/es/src/components/va-color-indicator/index.js
var VaColorIndicator = withConfigTransport$1(_VaColorIndicatort);

// node_modules/cleave.js/dist/cleave-esm.js
var commonjsGlobal2 = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var NumeralFormatter = function(numeralDecimalMark, numeralIntegerScale, numeralDecimalScale, numeralThousandsGroupStyle, numeralPositiveOnly, stripLeadingZeroes, prefix2, signBeforePrefix, tailPrefix, delimiter) {
  var owner = this;
  owner.numeralDecimalMark = numeralDecimalMark || ".";
  owner.numeralIntegerScale = numeralIntegerScale > 0 ? numeralIntegerScale : 0;
  owner.numeralDecimalScale = numeralDecimalScale >= 0 ? numeralDecimalScale : 2;
  owner.numeralThousandsGroupStyle = numeralThousandsGroupStyle || NumeralFormatter.groupStyle.thousand;
  owner.numeralPositiveOnly = !!numeralPositiveOnly;
  owner.stripLeadingZeroes = stripLeadingZeroes !== false;
  owner.prefix = prefix2 || prefix2 === "" ? prefix2 : "";
  owner.signBeforePrefix = !!signBeforePrefix;
  owner.tailPrefix = !!tailPrefix;
  owner.delimiter = delimiter || delimiter === "" ? delimiter : ",";
  owner.delimiterRE = delimiter ? new RegExp("\\" + delimiter, "g") : "";
};
NumeralFormatter.groupStyle = {
  thousand: "thousand",
  lakh: "lakh",
  wan: "wan",
  none: "none"
};
NumeralFormatter.prototype = {
  getRawValue: function(value) {
    return value.replace(this.delimiterRE, "").replace(this.numeralDecimalMark, ".");
  },
  format: function(value) {
    var owner = this, parts, partSign, partSignAndPrefix, partInteger, partDecimal = "";
    value = value.replace(/[A-Za-z]/g, "").replace(owner.numeralDecimalMark, "M").replace(/[^\dM-]/g, "").replace(/^\-/, "N").replace(/\-/g, "").replace("N", owner.numeralPositiveOnly ? "" : "-").replace("M", owner.numeralDecimalMark);
    if (owner.stripLeadingZeroes) {
      value = value.replace(/^(-)?0+(?=\d)/, "$1");
    }
    partSign = value.slice(0, 1) === "-" ? "-" : "";
    if (typeof owner.prefix != "undefined") {
      if (owner.signBeforePrefix) {
        partSignAndPrefix = partSign + owner.prefix;
      } else {
        partSignAndPrefix = owner.prefix + partSign;
      }
    } else {
      partSignAndPrefix = partSign;
    }
    partInteger = value;
    if (value.indexOf(owner.numeralDecimalMark) >= 0) {
      parts = value.split(owner.numeralDecimalMark);
      partInteger = parts[0];
      partDecimal = owner.numeralDecimalMark + parts[1].slice(0, owner.numeralDecimalScale);
    }
    if (partSign === "-") {
      partInteger = partInteger.slice(1);
    }
    if (owner.numeralIntegerScale > 0) {
      partInteger = partInteger.slice(0, owner.numeralIntegerScale);
    }
    switch (owner.numeralThousandsGroupStyle) {
      case NumeralFormatter.groupStyle.lakh:
        partInteger = partInteger.replace(/(\d)(?=(\d\d)+\d$)/g, "$1" + owner.delimiter);
        break;
      case NumeralFormatter.groupStyle.wan:
        partInteger = partInteger.replace(/(\d)(?=(\d{4})+$)/g, "$1" + owner.delimiter);
        break;
      case NumeralFormatter.groupStyle.thousand:
        partInteger = partInteger.replace(/(\d)(?=(\d{3})+$)/g, "$1" + owner.delimiter);
        break;
    }
    if (owner.tailPrefix) {
      return partSign + partInteger.toString() + (owner.numeralDecimalScale > 0 ? partDecimal.toString() : "") + owner.prefix;
    }
    return partSignAndPrefix + partInteger.toString() + (owner.numeralDecimalScale > 0 ? partDecimal.toString() : "");
  }
};
var NumeralFormatter_1 = NumeralFormatter;
var DateFormatter = function(datePattern, dateMin, dateMax) {
  var owner = this;
  owner.date = [];
  owner.blocks = [];
  owner.datePattern = datePattern;
  owner.dateMin = dateMin.split("-").reverse().map(function(x2) {
    return parseInt(x2, 10);
  });
  if (owner.dateMin.length === 2)
    owner.dateMin.unshift(0);
  owner.dateMax = dateMax.split("-").reverse().map(function(x2) {
    return parseInt(x2, 10);
  });
  if (owner.dateMax.length === 2)
    owner.dateMax.unshift(0);
  owner.initBlocks();
};
DateFormatter.prototype = {
  initBlocks: function() {
    var owner = this;
    owner.datePattern.forEach(function(value) {
      if (value === "Y") {
        owner.blocks.push(4);
      } else {
        owner.blocks.push(2);
      }
    });
  },
  getISOFormatDate: function() {
    var owner = this, date = owner.date;
    return date[2] ? date[2] + "-" + owner.addLeadingZero(date[1]) + "-" + owner.addLeadingZero(date[0]) : "";
  },
  getBlocks: function() {
    return this.blocks;
  },
  getValidatedDate: function(value) {
    var owner = this, result = "";
    value = value.replace(/[^\d]/g, "");
    owner.blocks.forEach(function(length, index) {
      if (value.length > 0) {
        var sub = value.slice(0, length), sub0 = sub.slice(0, 1), rest = value.slice(length);
        switch (owner.datePattern[index]) {
          case "d":
            if (sub === "00") {
              sub = "01";
            } else if (parseInt(sub0, 10) > 3) {
              sub = "0" + sub0;
            } else if (parseInt(sub, 10) > 31) {
              sub = "31";
            }
            break;
          case "m":
            if (sub === "00") {
              sub = "01";
            } else if (parseInt(sub0, 10) > 1) {
              sub = "0" + sub0;
            } else if (parseInt(sub, 10) > 12) {
              sub = "12";
            }
            break;
        }
        result += sub;
        value = rest;
      }
    });
    return this.getFixedDateString(result);
  },
  getFixedDateString: function(value) {
    var owner = this, datePattern = owner.datePattern, date = [], dayIndex = 0, monthIndex = 0, yearIndex = 0, dayStartIndex = 0, monthStartIndex = 0, yearStartIndex = 0, day, month, year, fullYearDone = false;
    if (value.length === 4 && datePattern[0].toLowerCase() !== "y" && datePattern[1].toLowerCase() !== "y") {
      dayStartIndex = datePattern[0] === "d" ? 0 : 2;
      monthStartIndex = 2 - dayStartIndex;
      day = parseInt(value.slice(dayStartIndex, dayStartIndex + 2), 10);
      month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
      date = this.getFixedDate(day, month, 0);
    }
    if (value.length === 8) {
      datePattern.forEach(function(type, index) {
        switch (type) {
          case "d":
            dayIndex = index;
            break;
          case "m":
            monthIndex = index;
            break;
          default:
            yearIndex = index;
            break;
        }
      });
      yearStartIndex = yearIndex * 2;
      dayStartIndex = dayIndex <= yearIndex ? dayIndex * 2 : dayIndex * 2 + 2;
      monthStartIndex = monthIndex <= yearIndex ? monthIndex * 2 : monthIndex * 2 + 2;
      day = parseInt(value.slice(dayStartIndex, dayStartIndex + 2), 10);
      month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
      year = parseInt(value.slice(yearStartIndex, yearStartIndex + 4), 10);
      fullYearDone = value.slice(yearStartIndex, yearStartIndex + 4).length === 4;
      date = this.getFixedDate(day, month, year);
    }
    if (value.length === 4 && (datePattern[0] === "y" || datePattern[1] === "y")) {
      monthStartIndex = datePattern[0] === "m" ? 0 : 2;
      yearStartIndex = 2 - monthStartIndex;
      month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
      year = parseInt(value.slice(yearStartIndex, yearStartIndex + 2), 10);
      fullYearDone = value.slice(yearStartIndex, yearStartIndex + 2).length === 2;
      date = [0, month, year];
    }
    if (value.length === 6 && (datePattern[0] === "Y" || datePattern[1] === "Y")) {
      monthStartIndex = datePattern[0] === "m" ? 0 : 4;
      yearStartIndex = 2 - 0.5 * monthStartIndex;
      month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
      year = parseInt(value.slice(yearStartIndex, yearStartIndex + 4), 10);
      fullYearDone = value.slice(yearStartIndex, yearStartIndex + 4).length === 4;
      date = [0, month, year];
    }
    date = owner.getRangeFixedDate(date);
    owner.date = date;
    var result = date.length === 0 ? value : datePattern.reduce(function(previous, current) {
      switch (current) {
        case "d":
          return previous + (date[0] === 0 ? "" : owner.addLeadingZero(date[0]));
        case "m":
          return previous + (date[1] === 0 ? "" : owner.addLeadingZero(date[1]));
        case "y":
          return previous + (fullYearDone ? owner.addLeadingZeroForYear(date[2], false) : "");
        case "Y":
          return previous + (fullYearDone ? owner.addLeadingZeroForYear(date[2], true) : "");
      }
    }, "");
    return result;
  },
  getRangeFixedDate: function(date) {
    var owner = this, datePattern = owner.datePattern, dateMin = owner.dateMin || [], dateMax = owner.dateMax || [];
    if (!date.length || dateMin.length < 3 && dateMax.length < 3)
      return date;
    if (datePattern.find(function(x2) {
      return x2.toLowerCase() === "y";
    }) && date[2] === 0)
      return date;
    if (dateMax.length && (dateMax[2] < date[2] || dateMax[2] === date[2] && (dateMax[1] < date[1] || dateMax[1] === date[1] && dateMax[0] < date[0])))
      return dateMax;
    if (dateMin.length && (dateMin[2] > date[2] || dateMin[2] === date[2] && (dateMin[1] > date[1] || dateMin[1] === date[1] && dateMin[0] > date[0])))
      return dateMin;
    return date;
  },
  getFixedDate: function(day, month, year) {
    day = Math.min(day, 31);
    month = Math.min(month, 12);
    year = parseInt(year || 0, 10);
    if (month < 7 && month % 2 === 0 || month > 8 && month % 2 === 1) {
      day = Math.min(day, month === 2 ? this.isLeapYear(year) ? 29 : 28 : 30);
    }
    return [day, month, year];
  },
  isLeapYear: function(year) {
    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
  },
  addLeadingZero: function(number) {
    return (number < 10 ? "0" : "") + number;
  },
  addLeadingZeroForYear: function(number, fullYearMode) {
    if (fullYearMode) {
      return (number < 10 ? "000" : number < 100 ? "00" : number < 1e3 ? "0" : "") + number;
    }
    return (number < 10 ? "0" : "") + number;
  }
};
var DateFormatter_1 = DateFormatter;
var TimeFormatter = function(timePattern, timeFormat) {
  var owner = this;
  owner.time = [];
  owner.blocks = [];
  owner.timePattern = timePattern;
  owner.timeFormat = timeFormat;
  owner.initBlocks();
};
TimeFormatter.prototype = {
  initBlocks: function() {
    var owner = this;
    owner.timePattern.forEach(function() {
      owner.blocks.push(2);
    });
  },
  getISOFormatTime: function() {
    var owner = this, time = owner.time;
    return time[2] ? owner.addLeadingZero(time[0]) + ":" + owner.addLeadingZero(time[1]) + ":" + owner.addLeadingZero(time[2]) : "";
  },
  getBlocks: function() {
    return this.blocks;
  },
  getTimeFormatOptions: function() {
    var owner = this;
    if (String(owner.timeFormat) === "12") {
      return {
        maxHourFirstDigit: 1,
        maxHours: 12,
        maxMinutesFirstDigit: 5,
        maxMinutes: 60
      };
    }
    return {
      maxHourFirstDigit: 2,
      maxHours: 23,
      maxMinutesFirstDigit: 5,
      maxMinutes: 60
    };
  },
  getValidatedTime: function(value) {
    var owner = this, result = "";
    value = value.replace(/[^\d]/g, "");
    var timeFormatOptions = owner.getTimeFormatOptions();
    owner.blocks.forEach(function(length, index) {
      if (value.length > 0) {
        var sub = value.slice(0, length), sub0 = sub.slice(0, 1), rest = value.slice(length);
        switch (owner.timePattern[index]) {
          case "h":
            if (parseInt(sub0, 10) > timeFormatOptions.maxHourFirstDigit) {
              sub = "0" + sub0;
            } else if (parseInt(sub, 10) > timeFormatOptions.maxHours) {
              sub = timeFormatOptions.maxHours + "";
            }
            break;
          case "m":
          case "s":
            if (parseInt(sub0, 10) > timeFormatOptions.maxMinutesFirstDigit) {
              sub = "0" + sub0;
            } else if (parseInt(sub, 10) > timeFormatOptions.maxMinutes) {
              sub = timeFormatOptions.maxMinutes + "";
            }
            break;
        }
        result += sub;
        value = rest;
      }
    });
    return this.getFixedTimeString(result);
  },
  getFixedTimeString: function(value) {
    var owner = this, timePattern = owner.timePattern, time = [], secondIndex = 0, minuteIndex = 0, hourIndex = 0, secondStartIndex = 0, minuteStartIndex = 0, hourStartIndex = 0, second, minute, hour;
    if (value.length === 6) {
      timePattern.forEach(function(type, index) {
        switch (type) {
          case "s":
            secondIndex = index * 2;
            break;
          case "m":
            minuteIndex = index * 2;
            break;
          case "h":
            hourIndex = index * 2;
            break;
        }
      });
      hourStartIndex = hourIndex;
      minuteStartIndex = minuteIndex;
      secondStartIndex = secondIndex;
      second = parseInt(value.slice(secondStartIndex, secondStartIndex + 2), 10);
      minute = parseInt(value.slice(minuteStartIndex, minuteStartIndex + 2), 10);
      hour = parseInt(value.slice(hourStartIndex, hourStartIndex + 2), 10);
      time = this.getFixedTime(hour, minute, second);
    }
    if (value.length === 4 && owner.timePattern.indexOf("s") < 0) {
      timePattern.forEach(function(type, index) {
        switch (type) {
          case "m":
            minuteIndex = index * 2;
            break;
          case "h":
            hourIndex = index * 2;
            break;
        }
      });
      hourStartIndex = hourIndex;
      minuteStartIndex = minuteIndex;
      second = 0;
      minute = parseInt(value.slice(minuteStartIndex, minuteStartIndex + 2), 10);
      hour = parseInt(value.slice(hourStartIndex, hourStartIndex + 2), 10);
      time = this.getFixedTime(hour, minute, second);
    }
    owner.time = time;
    return time.length === 0 ? value : timePattern.reduce(function(previous, current) {
      switch (current) {
        case "s":
          return previous + owner.addLeadingZero(time[2]);
        case "m":
          return previous + owner.addLeadingZero(time[1]);
        case "h":
          return previous + owner.addLeadingZero(time[0]);
      }
    }, "");
  },
  getFixedTime: function(hour, minute, second) {
    second = Math.min(parseInt(second || 0, 10), 60);
    minute = Math.min(minute, 60);
    hour = Math.min(hour, 60);
    return [hour, minute, second];
  },
  addLeadingZero: function(number) {
    return (number < 10 ? "0" : "") + number;
  }
};
var TimeFormatter_1 = TimeFormatter;
var PhoneFormatter = function(formatter, delimiter) {
  var owner = this;
  owner.delimiter = delimiter || delimiter === "" ? delimiter : " ";
  owner.delimiterRE = delimiter ? new RegExp("\\" + delimiter, "g") : "";
  owner.formatter = formatter;
};
PhoneFormatter.prototype = {
  setFormatter: function(formatter) {
    this.formatter = formatter;
  },
  format: function(phoneNumber) {
    var owner = this;
    owner.formatter.clear();
    phoneNumber = phoneNumber.replace(/[^\d+]/g, "");
    phoneNumber = phoneNumber.replace(/^\+/, "B").replace(/\+/g, "").replace("B", "+");
    phoneNumber = phoneNumber.replace(owner.delimiterRE, "");
    var result = "", current, validated = false;
    for (var i2 = 0, iMax = phoneNumber.length; i2 < iMax; i2++) {
      current = owner.formatter.inputDigit(phoneNumber.charAt(i2));
      if (/[\s()-]/g.test(current)) {
        result = current;
        validated = true;
      } else {
        if (!validated) {
          result = current;
        }
      }
    }
    result = result.replace(/[()]/g, "");
    result = result.replace(/[\s-]/g, owner.delimiter);
    return result;
  }
};
var PhoneFormatter_1 = PhoneFormatter;
var CreditCardDetector = {
  blocks: {
    uatp: [4, 5, 6],
    amex: [4, 6, 5],
    diners: [4, 6, 4],
    discover: [4, 4, 4, 4],
    mastercard: [4, 4, 4, 4],
    dankort: [4, 4, 4, 4],
    instapayment: [4, 4, 4, 4],
    jcb15: [4, 6, 5],
    jcb: [4, 4, 4, 4],
    maestro: [4, 4, 4, 4],
    visa: [4, 4, 4, 4],
    mir: [4, 4, 4, 4],
    unionPay: [4, 4, 4, 4],
    general: [4, 4, 4, 4]
  },
  re: {
    // starts with 1; 15 digits, not starts with 1800 (jcb card)
    uatp: /^(?!1800)1\d{0,14}/,
    // starts with 34/37; 15 digits
    amex: /^3[47]\d{0,13}/,
    // starts with 6011/65/644-649; 16 digits
    discover: /^(?:6011|65\d{0,2}|64[4-9]\d?)\d{0,12}/,
    // starts with 300-305/309 or 36/38/39; 14 digits
    diners: /^3(?:0([0-5]|9)|[689]\d?)\d{0,11}/,
    // starts with 51-55/2221–2720; 16 digits
    mastercard: /^(5[1-5]\d{0,2}|22[2-9]\d{0,1}|2[3-7]\d{0,2})\d{0,12}/,
    // starts with 5019/4175/4571; 16 digits
    dankort: /^(5019|4175|4571)\d{0,12}/,
    // starts with 637-639; 16 digits
    instapayment: /^63[7-9]\d{0,13}/,
    // starts with 2131/1800; 15 digits
    jcb15: /^(?:2131|1800)\d{0,11}/,
    // starts with 2131/1800/35; 16 digits
    jcb: /^(?:35\d{0,2})\d{0,12}/,
    // starts with 50/56-58/6304/67; 16 digits
    maestro: /^(?:5[0678]\d{0,2}|6304|67\d{0,2})\d{0,12}/,
    // starts with 22; 16 digits
    mir: /^220[0-4]\d{0,12}/,
    // starts with 4; 16 digits
    visa: /^4\d{0,15}/,
    // starts with 62/81; 16 digits
    unionPay: /^(62|81)\d{0,14}/
  },
  getStrictBlocks: function(block) {
    var total = block.reduce(function(prev, current) {
      return prev + current;
    }, 0);
    return block.concat(19 - total);
  },
  getInfo: function(value, strictMode) {
    var blocks = CreditCardDetector.blocks, re = CreditCardDetector.re;
    strictMode = !!strictMode;
    for (var key in re) {
      if (re[key].test(value)) {
        var matchedBlocks = blocks[key];
        return {
          type: key,
          blocks: strictMode ? this.getStrictBlocks(matchedBlocks) : matchedBlocks
        };
      }
    }
    return {
      type: "unknown",
      blocks: strictMode ? this.getStrictBlocks(blocks.general) : blocks.general
    };
  }
};
var CreditCardDetector_1 = CreditCardDetector;
var Util = {
  noop: function() {
  },
  strip: function(value, re) {
    return value.replace(re, "");
  },
  getPostDelimiter: function(value, delimiter, delimiters) {
    if (delimiters.length === 0) {
      return value.slice(-delimiter.length) === delimiter ? delimiter : "";
    }
    var matchedDelimiter = "";
    delimiters.forEach(function(current) {
      if (value.slice(-current.length) === current) {
        matchedDelimiter = current;
      }
    });
    return matchedDelimiter;
  },
  getDelimiterREByDelimiter: function(delimiter) {
    return new RegExp(delimiter.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1"), "g");
  },
  getNextCursorPosition: function(prevPos, oldValue, newValue, delimiter, delimiters) {
    if (oldValue.length === prevPos) {
      return newValue.length;
    }
    return prevPos + this.getPositionOffset(prevPos, oldValue, newValue, delimiter, delimiters);
  },
  getPositionOffset: function(prevPos, oldValue, newValue, delimiter, delimiters) {
    var oldRawValue, newRawValue, lengthOffset;
    oldRawValue = this.stripDelimiters(oldValue.slice(0, prevPos), delimiter, delimiters);
    newRawValue = this.stripDelimiters(newValue.slice(0, prevPos), delimiter, delimiters);
    lengthOffset = oldRawValue.length - newRawValue.length;
    return lengthOffset !== 0 ? lengthOffset / Math.abs(lengthOffset) : 0;
  },
  stripDelimiters: function(value, delimiter, delimiters) {
    var owner = this;
    if (delimiters.length === 0) {
      var delimiterRE = delimiter ? owner.getDelimiterREByDelimiter(delimiter) : "";
      return value.replace(delimiterRE, "");
    }
    delimiters.forEach(function(current) {
      current.split("").forEach(function(letter) {
        value = value.replace(owner.getDelimiterREByDelimiter(letter), "");
      });
    });
    return value;
  },
  headStr: function(str, length) {
    return str.slice(0, length);
  },
  getMaxLength: function(blocks) {
    return blocks.reduce(function(previous, current) {
      return previous + current;
    }, 0);
  },
  // strip prefix
  // Before type  |   After type    |     Return value
  // PEFIX-...    |   PEFIX-...     |     ''
  // PREFIX-123   |   PEFIX-123     |     123
  // PREFIX-123   |   PREFIX-23     |     23
  // PREFIX-123   |   PREFIX-1234   |     1234
  getPrefixStrippedValue: function(value, prefix2, prefixLength, prevResult, delimiter, delimiters, noImmediatePrefix, tailPrefix, signBeforePrefix) {
    if (prefixLength === 0) {
      return value;
    }
    if (value === prefix2 && value !== "") {
      return "";
    }
    if (signBeforePrefix && value.slice(0, 1) == "-") {
      var prev = prevResult.slice(0, 1) == "-" ? prevResult.slice(1) : prevResult;
      return "-" + this.getPrefixStrippedValue(value.slice(1), prefix2, prefixLength, prev, delimiter, delimiters, noImmediatePrefix, tailPrefix, signBeforePrefix);
    }
    if (prevResult.slice(0, prefixLength) !== prefix2 && !tailPrefix) {
      if (noImmediatePrefix && !prevResult && value)
        return value;
      return "";
    } else if (prevResult.slice(-prefixLength) !== prefix2 && tailPrefix) {
      if (noImmediatePrefix && !prevResult && value)
        return value;
      return "";
    }
    var prevValue = this.stripDelimiters(prevResult, delimiter, delimiters);
    if (value.slice(0, prefixLength) !== prefix2 && !tailPrefix) {
      return prevValue.slice(prefixLength);
    } else if (value.slice(-prefixLength) !== prefix2 && tailPrefix) {
      return prevValue.slice(0, -prefixLength - 1);
    }
    return tailPrefix ? value.slice(0, -prefixLength) : value.slice(prefixLength);
  },
  getFirstDiffIndex: function(prev, current) {
    var index = 0;
    while (prev.charAt(index) === current.charAt(index)) {
      if (prev.charAt(index++) === "") {
        return -1;
      }
    }
    return index;
  },
  getFormattedValue: function(value, blocks, blocksLength, delimiter, delimiters, delimiterLazyShow) {
    var result = "", multipleDelimiters = delimiters.length > 0, currentDelimiter = "";
    if (blocksLength === 0) {
      return value;
    }
    blocks.forEach(function(length, index) {
      if (value.length > 0) {
        var sub = value.slice(0, length), rest = value.slice(length);
        if (multipleDelimiters) {
          currentDelimiter = delimiters[delimiterLazyShow ? index - 1 : index] || currentDelimiter;
        } else {
          currentDelimiter = delimiter;
        }
        if (delimiterLazyShow) {
          if (index > 0) {
            result += currentDelimiter;
          }
          result += sub;
        } else {
          result += sub;
          if (sub.length === length && index < blocksLength - 1) {
            result += currentDelimiter;
          }
        }
        value = rest;
      }
    });
    return result;
  },
  // move cursor to the end
  // the first time user focuses on an input with prefix
  fixPrefixCursor: function(el, prefix2, delimiter, delimiters) {
    if (!el) {
      return;
    }
    var val = el.value, appendix = delimiter || (delimiters[0] || " ");
    if (!el.setSelectionRange || !prefix2 || prefix2.length + appendix.length <= val.length) {
      return;
    }
    var len = val.length * 2;
    setTimeout(function() {
      el.setSelectionRange(len, len);
    }, 1);
  },
  // Check if input field is fully selected
  checkFullSelection: function(value) {
    try {
      var selection = window.getSelection() || document.getSelection() || {};
      return selection.toString().length === value.length;
    } catch (ex) {
    }
    return false;
  },
  setSelection: function(element, position, doc) {
    if (element !== this.getActiveElement(doc)) {
      return;
    }
    if (element && element.value.length <= position) {
      return;
    }
    if (element.createTextRange) {
      var range = element.createTextRange();
      range.move("character", position);
      range.select();
    } else {
      try {
        element.setSelectionRange(position, position);
      } catch (e2) {
        console.warn("The input element type does not support selection");
      }
    }
  },
  getActiveElement: function(parent2) {
    var activeElement = parent2.activeElement;
    if (activeElement && activeElement.shadowRoot) {
      return this.getActiveElement(activeElement.shadowRoot);
    }
    return activeElement;
  },
  isAndroid: function() {
    return navigator && /android/i.test(navigator.userAgent);
  },
  // On Android chrome, the keyup and keydown events
  // always return key code 229 as a composition that
  // buffers the user’s keystrokes
  // see https://github.com/nosir/cleave.js/issues/147
  isAndroidBackspaceKeydown: function(lastInputValue, currentInputValue) {
    if (!this.isAndroid() || !lastInputValue || !currentInputValue) {
      return false;
    }
    return currentInputValue === lastInputValue.slice(0, -1);
  }
};
var Util_1 = Util;
var DefaultProperties = {
  // Maybe change to object-assign
  // for now just keep it as simple
  assign: function(target, opts) {
    target = target || {};
    opts = opts || {};
    target.creditCard = !!opts.creditCard;
    target.creditCardStrictMode = !!opts.creditCardStrictMode;
    target.creditCardType = "";
    target.onCreditCardTypeChanged = opts.onCreditCardTypeChanged || function() {
    };
    target.phone = !!opts.phone;
    target.phoneRegionCode = opts.phoneRegionCode || "AU";
    target.phoneFormatter = {};
    target.time = !!opts.time;
    target.timePattern = opts.timePattern || ["h", "m", "s"];
    target.timeFormat = opts.timeFormat || "24";
    target.timeFormatter = {};
    target.date = !!opts.date;
    target.datePattern = opts.datePattern || ["d", "m", "Y"];
    target.dateMin = opts.dateMin || "";
    target.dateMax = opts.dateMax || "";
    target.dateFormatter = {};
    target.numeral = !!opts.numeral;
    target.numeralIntegerScale = opts.numeralIntegerScale > 0 ? opts.numeralIntegerScale : 0;
    target.numeralDecimalScale = opts.numeralDecimalScale >= 0 ? opts.numeralDecimalScale : 2;
    target.numeralDecimalMark = opts.numeralDecimalMark || ".";
    target.numeralThousandsGroupStyle = opts.numeralThousandsGroupStyle || "thousand";
    target.numeralPositiveOnly = !!opts.numeralPositiveOnly;
    target.stripLeadingZeroes = opts.stripLeadingZeroes !== false;
    target.signBeforePrefix = !!opts.signBeforePrefix;
    target.tailPrefix = !!opts.tailPrefix;
    target.swapHiddenInput = !!opts.swapHiddenInput;
    target.numericOnly = target.creditCard || target.date || !!opts.numericOnly;
    target.uppercase = !!opts.uppercase;
    target.lowercase = !!opts.lowercase;
    target.prefix = target.creditCard || target.date ? "" : opts.prefix || "";
    target.noImmediatePrefix = !!opts.noImmediatePrefix;
    target.prefixLength = target.prefix.length;
    target.rawValueTrimPrefix = !!opts.rawValueTrimPrefix;
    target.copyDelimiter = !!opts.copyDelimiter;
    target.initValue = opts.initValue !== void 0 && opts.initValue !== null ? opts.initValue.toString() : "";
    target.delimiter = opts.delimiter || opts.delimiter === "" ? opts.delimiter : opts.date ? "/" : opts.time ? ":" : opts.numeral ? "," : opts.phone ? " " : " ";
    target.delimiterLength = target.delimiter.length;
    target.delimiterLazyShow = !!opts.delimiterLazyShow;
    target.delimiters = opts.delimiters || [];
    target.blocks = opts.blocks || [];
    target.blocksLength = target.blocks.length;
    target.root = typeof commonjsGlobal2 === "object" && commonjsGlobal2 ? commonjsGlobal2 : window;
    target.document = opts.document || target.root.document;
    target.maxLength = 0;
    target.backspace = false;
    target.result = "";
    target.onValueChanged = opts.onValueChanged || function() {
    };
    return target;
  }
};
var DefaultProperties_1 = DefaultProperties;
var Cleave = function(element, opts) {
  var owner = this;
  var hasMultipleElements = false;
  if (typeof element === "string") {
    owner.element = document.querySelector(element);
    hasMultipleElements = document.querySelectorAll(element).length > 1;
  } else {
    if (typeof element.length !== "undefined" && element.length > 0) {
      owner.element = element[0];
      hasMultipleElements = element.length > 1;
    } else {
      owner.element = element;
    }
  }
  if (!owner.element) {
    throw new Error("[cleave.js] Please check the element");
  }
  if (hasMultipleElements) {
    try {
      console.warn("[cleave.js] Multiple input fields matched, cleave.js will only take the first one.");
    } catch (e2) {
    }
  }
  opts.initValue = owner.element.value;
  owner.properties = Cleave.DefaultProperties.assign({}, opts);
  owner.init();
};
Cleave.prototype = {
  init: function() {
    var owner = this, pps = owner.properties;
    if (!pps.numeral && !pps.phone && !pps.creditCard && !pps.time && !pps.date && (pps.blocksLength === 0 && !pps.prefix)) {
      owner.onInput(pps.initValue);
      return;
    }
    pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);
    owner.isAndroid = Cleave.Util.isAndroid();
    owner.lastInputValue = "";
    owner.isBackward = "";
    owner.onChangeListener = owner.onChange.bind(owner);
    owner.onKeyDownListener = owner.onKeyDown.bind(owner);
    owner.onFocusListener = owner.onFocus.bind(owner);
    owner.onCutListener = owner.onCut.bind(owner);
    owner.onCopyListener = owner.onCopy.bind(owner);
    owner.initSwapHiddenInput();
    owner.element.addEventListener("input", owner.onChangeListener);
    owner.element.addEventListener("keydown", owner.onKeyDownListener);
    owner.element.addEventListener("focus", owner.onFocusListener);
    owner.element.addEventListener("cut", owner.onCutListener);
    owner.element.addEventListener("copy", owner.onCopyListener);
    owner.initPhoneFormatter();
    owner.initDateFormatter();
    owner.initTimeFormatter();
    owner.initNumeralFormatter();
    if (pps.initValue || pps.prefix && !pps.noImmediatePrefix) {
      owner.onInput(pps.initValue);
    }
  },
  initSwapHiddenInput: function() {
    var owner = this, pps = owner.properties;
    if (!pps.swapHiddenInput)
      return;
    var inputFormatter = owner.element.cloneNode(true);
    owner.element.parentNode.insertBefore(inputFormatter, owner.element);
    owner.elementSwapHidden = owner.element;
    owner.elementSwapHidden.type = "hidden";
    owner.element = inputFormatter;
    owner.element.id = "";
  },
  initNumeralFormatter: function() {
    var owner = this, pps = owner.properties;
    if (!pps.numeral) {
      return;
    }
    pps.numeralFormatter = new Cleave.NumeralFormatter(
      pps.numeralDecimalMark,
      pps.numeralIntegerScale,
      pps.numeralDecimalScale,
      pps.numeralThousandsGroupStyle,
      pps.numeralPositiveOnly,
      pps.stripLeadingZeroes,
      pps.prefix,
      pps.signBeforePrefix,
      pps.tailPrefix,
      pps.delimiter
    );
  },
  initTimeFormatter: function() {
    var owner = this, pps = owner.properties;
    if (!pps.time) {
      return;
    }
    pps.timeFormatter = new Cleave.TimeFormatter(pps.timePattern, pps.timeFormat);
    pps.blocks = pps.timeFormatter.getBlocks();
    pps.blocksLength = pps.blocks.length;
    pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);
  },
  initDateFormatter: function() {
    var owner = this, pps = owner.properties;
    if (!pps.date) {
      return;
    }
    pps.dateFormatter = new Cleave.DateFormatter(pps.datePattern, pps.dateMin, pps.dateMax);
    pps.blocks = pps.dateFormatter.getBlocks();
    pps.blocksLength = pps.blocks.length;
    pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);
  },
  initPhoneFormatter: function() {
    var owner = this, pps = owner.properties;
    if (!pps.phone) {
      return;
    }
    try {
      pps.phoneFormatter = new Cleave.PhoneFormatter(
        new pps.root.Cleave.AsYouTypeFormatter(pps.phoneRegionCode),
        pps.delimiter
      );
    } catch (ex) {
      throw new Error("[cleave.js] Please include phone-type-formatter.{country}.js lib");
    }
  },
  onKeyDown: function(event) {
    var owner = this, charCode = event.which || event.keyCode;
    owner.lastInputValue = owner.element.value;
    owner.isBackward = charCode === 8;
  },
  onChange: function(event) {
    var owner = this, pps = owner.properties, Util2 = Cleave.Util;
    owner.isBackward = owner.isBackward || event.inputType === "deleteContentBackward";
    var postDelimiter = Util2.getPostDelimiter(owner.lastInputValue, pps.delimiter, pps.delimiters);
    if (owner.isBackward && postDelimiter) {
      pps.postDelimiterBackspace = postDelimiter;
    } else {
      pps.postDelimiterBackspace = false;
    }
    this.onInput(this.element.value);
  },
  onFocus: function() {
    var owner = this, pps = owner.properties;
    owner.lastInputValue = owner.element.value;
    if (pps.prefix && pps.noImmediatePrefix && !owner.element.value) {
      this.onInput(pps.prefix);
    }
    Cleave.Util.fixPrefixCursor(owner.element, pps.prefix, pps.delimiter, pps.delimiters);
  },
  onCut: function(e2) {
    if (!Cleave.Util.checkFullSelection(this.element.value))
      return;
    this.copyClipboardData(e2);
    this.onInput("");
  },
  onCopy: function(e2) {
    if (!Cleave.Util.checkFullSelection(this.element.value))
      return;
    this.copyClipboardData(e2);
  },
  copyClipboardData: function(e2) {
    var owner = this, pps = owner.properties, Util2 = Cleave.Util, inputValue = owner.element.value, textToCopy = "";
    if (!pps.copyDelimiter) {
      textToCopy = Util2.stripDelimiters(inputValue, pps.delimiter, pps.delimiters);
    } else {
      textToCopy = inputValue;
    }
    try {
      if (e2.clipboardData) {
        e2.clipboardData.setData("Text", textToCopy);
      } else {
        window.clipboardData.setData("Text", textToCopy);
      }
      e2.preventDefault();
    } catch (ex) {
    }
  },
  onInput: function(value) {
    var owner = this, pps = owner.properties, Util2 = Cleave.Util;
    var postDelimiterAfter = Util2.getPostDelimiter(value, pps.delimiter, pps.delimiters);
    if (!pps.numeral && pps.postDelimiterBackspace && !postDelimiterAfter) {
      value = Util2.headStr(value, value.length - pps.postDelimiterBackspace.length);
    }
    if (pps.phone) {
      if (pps.prefix && (!pps.noImmediatePrefix || value.length)) {
        pps.result = pps.prefix + pps.phoneFormatter.format(value).slice(pps.prefix.length);
      } else {
        pps.result = pps.phoneFormatter.format(value);
      }
      owner.updateValueState();
      return;
    }
    if (pps.numeral) {
      if (pps.prefix && pps.noImmediatePrefix && value.length === 0) {
        pps.result = "";
      } else {
        pps.result = pps.numeralFormatter.format(value);
      }
      owner.updateValueState();
      return;
    }
    if (pps.date) {
      value = pps.dateFormatter.getValidatedDate(value);
    }
    if (pps.time) {
      value = pps.timeFormatter.getValidatedTime(value);
    }
    value = Util2.stripDelimiters(value, pps.delimiter, pps.delimiters);
    value = Util2.getPrefixStrippedValue(value, pps.prefix, pps.prefixLength, pps.result, pps.delimiter, pps.delimiters, pps.noImmediatePrefix, pps.tailPrefix, pps.signBeforePrefix);
    value = pps.numericOnly ? Util2.strip(value, /[^\d]/g) : value;
    value = pps.uppercase ? value.toUpperCase() : value;
    value = pps.lowercase ? value.toLowerCase() : value;
    if (pps.prefix) {
      if (pps.tailPrefix) {
        value = value + pps.prefix;
      } else {
        value = pps.prefix + value;
      }
      if (pps.blocksLength === 0) {
        pps.result = value;
        owner.updateValueState();
        return;
      }
    }
    if (pps.creditCard) {
      owner.updateCreditCardPropsByValue(value);
    }
    value = Util2.headStr(value, pps.maxLength);
    pps.result = Util2.getFormattedValue(
      value,
      pps.blocks,
      pps.blocksLength,
      pps.delimiter,
      pps.delimiters,
      pps.delimiterLazyShow
    );
    owner.updateValueState();
  },
  updateCreditCardPropsByValue: function(value) {
    var owner = this, pps = owner.properties, Util2 = Cleave.Util, creditCardInfo;
    if (Util2.headStr(pps.result, 4) === Util2.headStr(value, 4)) {
      return;
    }
    creditCardInfo = Cleave.CreditCardDetector.getInfo(value, pps.creditCardStrictMode);
    pps.blocks = creditCardInfo.blocks;
    pps.blocksLength = pps.blocks.length;
    pps.maxLength = Util2.getMaxLength(pps.blocks);
    if (pps.creditCardType !== creditCardInfo.type) {
      pps.creditCardType = creditCardInfo.type;
      pps.onCreditCardTypeChanged.call(owner, pps.creditCardType);
    }
  },
  updateValueState: function() {
    var owner = this, Util2 = Cleave.Util, pps = owner.properties;
    if (!owner.element) {
      return;
    }
    var endPos = owner.element.selectionEnd;
    var oldValue = owner.element.value;
    var newValue = pps.result;
    endPos = Util2.getNextCursorPosition(endPos, oldValue, newValue, pps.delimiter, pps.delimiters);
    if (owner.isAndroid) {
      window.setTimeout(function() {
        owner.element.value = newValue;
        Util2.setSelection(owner.element, endPos, pps.document, false);
        owner.callOnValueChanged();
      }, 1);
      return;
    }
    owner.element.value = newValue;
    if (pps.swapHiddenInput)
      owner.elementSwapHidden.value = owner.getRawValue();
    Util2.setSelection(owner.element, endPos, pps.document, false);
    owner.callOnValueChanged();
  },
  callOnValueChanged: function() {
    var owner = this, pps = owner.properties;
    pps.onValueChanged.call(owner, {
      target: {
        name: owner.element.name,
        value: pps.result,
        rawValue: owner.getRawValue()
      }
    });
  },
  setPhoneRegionCode: function(phoneRegionCode) {
    var owner = this, pps = owner.properties;
    pps.phoneRegionCode = phoneRegionCode;
    owner.initPhoneFormatter();
    owner.onChange();
  },
  setRawValue: function(value) {
    var owner = this, pps = owner.properties;
    value = value !== void 0 && value !== null ? value.toString() : "";
    if (pps.numeral) {
      value = value.replace(".", pps.numeralDecimalMark);
    }
    pps.postDelimiterBackspace = false;
    owner.element.value = value;
    owner.onInput(value);
  },
  getRawValue: function() {
    var owner = this, pps = owner.properties, Util2 = Cleave.Util, rawValue = owner.element.value;
    if (pps.rawValueTrimPrefix) {
      rawValue = Util2.getPrefixStrippedValue(rawValue, pps.prefix, pps.prefixLength, pps.result, pps.delimiter, pps.delimiters, pps.noImmediatePrefix, pps.tailPrefix, pps.signBeforePrefix);
    }
    if (pps.numeral) {
      rawValue = pps.numeralFormatter.getRawValue(rawValue);
    } else {
      rawValue = Util2.stripDelimiters(rawValue, pps.delimiter, pps.delimiters);
    }
    return rawValue;
  },
  getISOFormatDate: function() {
    var owner = this, pps = owner.properties;
    return pps.date ? pps.dateFormatter.getISOFormatDate() : "";
  },
  getISOFormatTime: function() {
    var owner = this, pps = owner.properties;
    return pps.time ? pps.timeFormatter.getISOFormatTime() : "";
  },
  getFormattedValue: function() {
    return this.element.value;
  },
  destroy: function() {
    var owner = this;
    owner.element.removeEventListener("input", owner.onChangeListener);
    owner.element.removeEventListener("keydown", owner.onKeyDownListener);
    owner.element.removeEventListener("focus", owner.onFocusListener);
    owner.element.removeEventListener("cut", owner.onCutListener);
    owner.element.removeEventListener("copy", owner.onCopyListener);
  },
  toString: function() {
    return "[Cleave Object]";
  }
};
Cleave.NumeralFormatter = NumeralFormatter_1;
Cleave.DateFormatter = DateFormatter_1;
Cleave.TimeFormatter = TimeFormatter_1;
Cleave.PhoneFormatter = PhoneFormatter_1;
Cleave.CreditCardDetector = CreditCardDetector_1;
Cleave.Util = Util_1;
Cleave.DefaultProperties = DefaultProperties_1;
(typeof commonjsGlobal2 === "object" && commonjsGlobal2 ? commonjsGlobal2 : window)["Cleave"] = Cleave;
var Cleave_1 = Cleave;
var cleave_esm_default = Cleave_1;

// node_modules/vuestic-ui/dist/es/src/components/va-input/hooks/useCleave.js
var DEFAULT_MASK_TOKENS = {
  creditCard: {
    creditCard: true
  },
  date: {
    date: true,
    datePattern: ["d", "m", "Y"]
  },
  time: {
    time: true,
    timePattern: ["h", "m"],
    timeFormat: "24"
  },
  numeral: {
    numeral: true,
    numeralThousandsGroupStyle: "thousand"
  }
};
var useCleaveProps = {
  mask: { type: [String, Object], default: "" },
  returnRaw: { type: Boolean, default: true }
};
var useCleave = (element, props2, syncValue) => {
  const cleave = ref();
  const getMask = (mask) => {
    if (typeof mask === "string") {
      return DEFAULT_MASK_TOKENS[mask] ? { ...DEFAULT_MASK_TOKENS[mask] } : {};
    }
    return { ...mask };
  };
  const destroyCleave = () => {
    if (cleave.value) {
      cleave.value.destroy();
    }
  };
  const initCleave = () => {
    destroyCleave();
    if (!element.value) {
      return;
    }
    cleave.value = new cleave_esm_default(element.value, getMask(props2.mask));
  };
  onMounted(() => {
    initCleave();
  });
  onBeforeUnmount(() => {
    destroyCleave();
  });
  watch(() => [element.value, props2.mask], () => {
    initCleave();
  });
  const computedValue = computed(() => {
    if (cleave.value) {
      if (props2.returnRaw && syncValue.value === cleave.value.getRawValue()) {
        return cleave.value.getFormattedValue();
      }
    }
    return syncValue.value;
  });
  const onInput = (event) => {
    const value = event.target.value;
    if (props2.mask !== "string" && !Object.keys(props2.mask).length) {
      syncValue.value = value;
      return;
    }
    if (cleave.value) {
      cleave.value.setRawValue(value);
      if (props2.returnRaw) {
        syncValue.value = cleave.value.getRawValue();
        return;
      }
      syncValue.value = cleave.value.getFormattedValue();
      return;
    }
    syncValue.value = value;
  };
  return {
    cleave,
    computedValue,
    onInput
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-input-wrapper/components/VaInputLabel.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaInputLabel.css";
var _sfc_main38 = defineComponent({
  name: "VaInputLabel",
  props: {
    label: {
      type: String,
      default: ""
    },
    requiredMark: {
      type: Boolean,
      default: false
    },
    color: {
      type: String,
      default: "primary"
    }
  },
  setup() {
    const { getColor } = useColors();
    return {
      getColor
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-input-wrapper/components/VaInputLabel.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaInputLabel.css";
var _hoisted_118 = {
  key: 0,
  class: "va-input-label__required-mark"
};
function _sfc_render35(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("label", {
    "aria-hidden": "true",
    class: "va-input-label",
    style: normalizeStyle({ color: _ctx.getColor(_ctx.$props.color, void 0, true) })
  }, [
    renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ label: _ctx.label, requiredMark: _ctx.requiredMark, color: _ctx.getColor(_ctx.$props.color) })), () => [
      createTextVNode(toDisplayString(_ctx.label) + " ", 1),
      _ctx.requiredMark ? (openBlock(), createElementBlock("span", _hoisted_118, " * ")) : createCommentVNode("", true)
    ])
  ], 4);
}
var VaInputLabel = _export_sfc(_sfc_main38, [["render", _sfc_render35]]);

// node_modules/vuestic-ui/dist/es/src/components/va-input-wrapper/hooks/useInputFieldAria.js
var useInputFieldAriaProps = {
  label: { type: String, default: "" },
  inputAriaLabel: { type: String, default: "$t:inputField" },
  inputAriaLabelledby: { type: String },
  inputAriaDescribedby: { type: String }
};
var useInputFieldAria = (props2) => {
  const id = useComponentUuid();
  const labelId = `input-label-${id}`;
  const characterCountId = `input-character-count-${id}`;
  const ariaAttributes = computed(() => ({
    "aria-label": props2.label !== "" ? props2.label : props2.inputAriaLabel,
    "aria-labelledby": props2.inputAriaLabelledby ? props2.inputAriaLabelledby : labelId,
    "aria-describedby": props2.inputAriaDescribedby ? props2.inputAriaDescribedby : characterCountId
  }));
  return {
    labelId,
    characterCountId,
    ariaAttributes
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useFormField.js
var useFormFieldProps = {
  disabled: { type: Boolean, default: false },
  readonly: { type: Boolean, default: false }
};
var useFormField = (prefix2, props2) => {
  const computedClasses = useBem(prefix2, computed(() => pick$1(props2, ["disabled", "readonly"])));
  return { computedClasses };
};

// node_modules/vuestic-ui/dist/es/src/composables/useFocusDeep.js
var useFocusDeep = (el) => {
  const focused = useActiveElement();
  const current = useCurrentElement(el ? useHTMLElement(el) : void 0);
  let previouslyFocusedElement = null;
  const isFocused = computed({
    get() {
      var _a2;
      if (!focused.value) {
        return false;
      }
      if (focused.value === current.value) {
        return true;
      }
      const isFocused2 = (_a2 = current.value) == null ? void 0 : _a2.contains(focused.value);
      if (isFocused2) {
        previouslyFocusedElement = focused.value;
      }
      return isFocused2;
    },
    set(value) {
      var _a2;
      let target = previouslyFocusedElement ?? current.value;
      if (!((_a2 = current.value) == null ? void 0 : _a2.contains(target))) {
        target = current.value;
      }
      if (value) {
        target == null ? void 0 : target.focus();
      } else {
        target == null ? void 0 : target.blur();
      }
    }
  });
  return Object.assign(isFocused, {
    /** Focus `el` if focus is not set to any other element */
    focusIfNothingIfFocused: () => {
      if (focused.value === document.body) {
        isFocused.value = true;
      }
    },
    focusPreviousElement: () => {
      if (previouslyFocusedElement) {
        previouslyFocusedElement.focus();
      } else {
        document.body.focus();
      }
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-input-wrapper/VaInputWrapper.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaInputWrapper.css";
var VaInputLabelProps = extractComponentProps(VaInputLabel);
var _sfc_main39 = defineComponent({
  name: "VaInputWrapper",
  components: { VaMessageList: WithSlotInheritance(VaMessageList), VaIcon, VaInputLabel },
  props: {
    ...useComponentPresetProp,
    ...useInputFieldAriaProps,
    ...useFormFieldProps,
    ...useValidationProps,
    ...VaInputLabelProps,
    modelValue: { type: null, default: "" },
    counter: { type: Boolean },
    maxLength: { type: Number, default: void 0 },
    label: { type: String, default: "" },
    placeholder: { type: String, default: "" },
    color: { type: String, default: "primary" },
    background: { type: String },
    success: { type: Boolean, default: false },
    loading: { type: Boolean, default: false },
    requiredMark: { type: Boolean, default: false },
    innerLabel: { type: Boolean, default: false }
  },
  emits: [
    "click",
    "click-prepend",
    "click-append",
    "click-prepend-inner",
    "click-append-inner",
    "click-field",
    "update:modelValue"
  ],
  setup(props2, { emit, slots }) {
    const { getColor } = useColors();
    const [vModel] = useSyncProp("modelValue", props2, emit, "");
    const isFocused = useFocusDeep();
    const counterValue = computed(
      () => props2.counter && typeof vModel.value === "string" ? vModel.value.length : void 0
    );
    const wrapperClass = useBem("va-input-wrapper", () => ({
      ...pick$1(props2, ["success", "error", "disabled", "readonly"]),
      focused: Boolean(isFocused.value),
      labeled: Boolean(props2.label || slots.label),
      labeledInner: Boolean(props2.label || slots.label) && props2.innerLabel
    }));
    const colorComputed = computed(() => getColor(props2.color));
    const backgroundComputed = computed(() => props2.background ? getColor(props2.background) : "#ffffff00");
    const messagesComputed = computed(() => props2.error ? props2.errorMessages : props2.messages);
    const { textColorComputed } = useTextColor(backgroundComputed);
    const messagesColor = computed(() => {
      if (props2.error) {
        return "danger";
      }
      if (props2.success) {
        return "success";
      }
      return "";
    });
    const errorLimit = computed(() => props2.error ? Number(props2.errorCount) : 99);
    const isCounterVisible = computed(() => counterValue.value !== void 0);
    const counterComputed = computed(
      () => props2.maxLength !== void 0 ? `${counterValue.value}/${props2.maxLength}` : counterValue.value
    );
    const {
      labelId,
      characterCountId,
      ariaAttributes
    } = useInputFieldAria(props2);
    const vaInputLabelProps = filterComponentProps(VaInputLabelProps);
    const focus = () => {
      isFocused.value = true;
    };
    const blur = () => {
      isFocused.value = false;
    };
    return {
      focus,
      blur,
      labelId,
      characterCountId,
      ariaAttributes,
      vModel,
      counterValue,
      vaInputLabelProps,
      wrapperClass,
      textColorComputed,
      isCounterVisible,
      counterComputed,
      colorComputed,
      backgroundComputed,
      messagesColor,
      messagesComputed,
      errorLimit
    };
  },
  methods: {}
});

// node_modules/vuestic-ui/dist/es/src/components/va-input-wrapper/VaInputWrapper.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaInputWrapper.css";
var _hoisted_119 = { class: "va-input-wrapper__size-keeper" };
var _hoisted_210 = { class: "va-input-wrapper__container" };
var _hoisted_36 = { class: "va-input-wrapper__text" };
var _hoisted_45 = ["placeholder", "readonly", "disabled"];
var _hoisted_54 = ["id"];
var _hoisted_64 = { class: "va-input-wrapper__counter" };
function _sfc_render36(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaInputLabel = resolveComponent("VaInputLabel");
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_message_list = resolveComponent("va-message-list");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-input-wrapper", _ctx.wrapperClass]),
    onClick: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("click", $event)),
    style: normalizeStyle(`--va-background-computed: ${String(_ctx.backgroundComputed)};--va-color-computed: ${String(_ctx.colorComputed)};--va-text-color-computed: ${String(_ctx.textColorComputed)}`)
  }, [
    createVNode(_component_va_message_list, {
      color: _ctx.messagesColor,
      "model-value": _ctx.messagesComputed,
      limit: _ctx.errorLimit,
      "inherit-slots": ["message", "messages"]
    }, {
      default: withCtx(({ ariaAttributes: messagesChildAriaAttributes }) => [
        createBaseVNode("fieldset", _hoisted_119, [
          (_ctx.$props.label || _ctx.$slots.label) && !_ctx.$props.innerLabel ? (openBlock(), createBlock(_component_VaInputLabel, mergeProps({
            key: 0,
            class: "va-input-wrapper__label va-input-wrapper__label--outer"
          }, _ctx.vaInputLabelProps, { id: _ctx.labelId }), {
            default: withCtx((bind) => [
              renderSlot(_ctx.$slots, "label", normalizeProps(guardReactiveProps(bind)))
            ]),
            _: 3
          }, 16, ["id"])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_210, [
            _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "va-input-wrapper__prepend-inner",
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click-prepend"))
            }, [
              renderSlot(_ctx.$slots, "prepend")
            ])) : createCommentVNode("", true),
            createBaseVNode("div", {
              onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("click-field", $event)),
              class: "va-input-wrapper__field"
            }, [
              _ctx.$slots.prependInner ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "va-input-wrapper__prepend-inner",
                ref: "container",
                onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("click-prepend-inner", $event))
              }, [
                renderSlot(_ctx.$slots, "prependInner")
              ], 512)) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_36, [
                (_ctx.$props.label || _ctx.$slots.label) && _ctx.$props.innerLabel ? (openBlock(), createBlock(_component_VaInputLabel, mergeProps({
                  key: 0,
                  class: "va-input-wrapper__label va-input-wrapper__label--inner"
                }, _ctx.vaInputLabelProps, { id: _ctx.labelId }), {
                  default: withCtx((bind) => [
                    renderSlot(_ctx.$slots, "label", normalizeProps(guardReactiveProps(bind)))
                  ]),
                  _: 3
                }, 16, ["id"])) : createCommentVNode("", true),
                renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ ariaAttributes: { ...messagesChildAriaAttributes, ..._ctx.ariaAttributes }, value: _ctx.vModel })), () => [
                  withDirectives(createBaseVNode("input", mergeProps({ ...messagesChildAriaAttributes, ..._ctx.ariaAttributes }, {
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.vModel = $event),
                    placeholder: _ctx.$props.placeholder,
                    readonly: _ctx.$props.readonly,
                    disabled: _ctx.$props.disabled
                  }), null, 16, _hoisted_45), [
                    [vModelDynamic, _ctx.vModel]
                  ])
                ])
              ]),
              _ctx.success ? (openBlock(), createBlock(_component_va_icon, {
                key: 1,
                color: "success",
                name: "va-check-circle",
                class: "va-input-wrapper__icon va-input-wrapper__icon--success"
              })) : createCommentVNode("", true),
              _ctx.error ? (openBlock(), createBlock(_component_va_icon, {
                key: 2,
                color: "danger",
                name: "va-warning",
                class: "va-input-wrapper__icon va-input-wrapper__icon--error"
              })) : createCommentVNode("", true),
              _ctx.$props.loading ? (openBlock(), createBlock(_component_va_icon, {
                key: 3,
                color: _ctx.$props.color,
                name: "va-loading",
                spin: "counter-clockwise",
                class: "va-input-wrapper__icon va-input-wrapper__icon--loading"
              }, null, 8, ["color"])) : createCommentVNode("", true),
              renderSlot(_ctx.$slots, "icon"),
              _ctx.$slots.appendInner ? (openBlock(), createElementBlock("div", {
                key: 4,
                class: "va-input-wrapper__append-inner",
                onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("click-append-inner", $event))
              }, [
                renderSlot(_ctx.$slots, "appendInner")
              ])) : createCommentVNode("", true)
            ]),
            _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: "va-input-wrapper__append-inner",
              onClick: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("click-append"))
            }, [
              renderSlot(_ctx.$slots, "append")
            ])) : createCommentVNode("", true)
          ]),
          _ctx.isCounterVisible ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: "va-input-wrapper__counter-wrapper",
            id: _ctx.characterCountId
          }, [
            renderSlot(_ctx.$slots, "counter", normalizeProps(guardReactiveProps({ valueLength: _ctx.counterValue, maxLength: _ctx.$props.maxLength })), () => [
              createBaseVNode("div", _hoisted_64, toDisplayString(_ctx.counterComputed), 1)
            ])
          ], 8, _hoisted_54)) : createCommentVNode("", true)
        ])
      ]),
      _: 3
    }, 8, ["color", "model-value", "limit"])
  ], 6);
}
var _VaInputWrapper = _export_sfc(_sfc_main39, [["render", _sfc_render36]]);

// node_modules/vuestic-ui/dist/es/src/components/va-input-wrapper/index.js
var VaInputWrapper = withConfigTransport$1(_VaInputWrapper);

// node_modules/vuestic-ui/dist/es/src/utils/combine-functions.js
var combineFunctions = (...list) => {
  return (...args) => list.forEach((fn) => fn(...args));
};

// node_modules/vuestic-ui/dist/es/src/composables/useFocusable.js
var useFocusableProps = {
  /** Focus element when mounted */
  autofocus: { type: Boolean, default: false }
};
var useFocusable = (el, props2) => {
  const focus = () => {
    focusElement(unwrapEl(el.value));
  };
  const blur = () => {
    blurElement(unwrapEl(el.value));
  };
  onMounted(() => {
    if (props2.autofocus) {
      focus();
    }
  });
  return {
    focus,
    blur
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useClearable.js
var useClearableProps = {
  clearable: { type: Boolean, default: false },
  clearableIcon: { type: String, default: "va-clear" },
  clearValue: { type: String, default: "" }
};
var useClearableEmits = ["clear"];
var useClearable = (props2, inputValue, el, hasError) => {
  const { isFocused, onFocus, onBlur } = useFocus(el);
  const clearedValues = [null, void 0, props2.clearValue];
  const canBeCleared = computed(() => props2.clearable && !props2.disabled && !props2.readonly && !clearedValues.includes(inputValue.value));
  const clearIconColor = computed(() => {
    if (isFocused == null ? void 0 : isFocused.value) {
      return props2.color || "primary";
    }
    if (hasError == null ? void 0 : hasError.value) {
      return "danger";
    }
    if (props2.success) {
      return "success";
    }
    return "secondary";
  });
  const clearIconProps = computed(() => ({
    name: props2.clearableIcon,
    color: clearIconColor.value,
    size: "medium",
    tabindex: canBeCleared.value ? 0 : -1
  }));
  return {
    canBeCleared,
    clearIconColor,
    clearIconProps,
    onFocus,
    onBlur
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useDeprecatedCondition.js
var useDeprecatedCondition = (validators) => {
  if (!isDev) {
    return void 0;
  }
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("`useDeprecated` hook must be used only inside of setup function!");
  }
  validators.forEach((validator) => {
    const message = validator();
    if (typeof message === "string") {
      warn(`(${instance.type.name} component) ${message}`);
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-input/VaInput.vue_vue_type_script_lang.js
var VaInputWrapperProps = extractComponentProps(VaInputWrapper);
var { createEmits: createInputEmits, createListeners: createInputListeners } = useEmitProxy(
  ["change", "keyup", "keypress", "keydown", "focus", "blur", "input"]
);
var { createEmits: createFieldEmits, createListeners: createFieldListeners } = useEmitProxy([
  "click",
  "click-prepend",
  "click-append",
  "click-prepend-inner",
  "click-append-inner"
]);
var _sfc_main40 = defineComponent({
  name: "VaInput",
  components: { VaInputWrapper, VaIcon },
  props: {
    ...VaInputWrapperProps,
    ...useFormFieldProps,
    ...useFocusableProps,
    ...useValidationProps,
    ...useClearableProps,
    ...useCleaveProps,
    ...useComponentPresetProp,
    ...useStatefulProps,
    // input
    placeholder: { type: String, default: "" },
    tabindex: { type: [String, Number], default: 0 },
    modelValue: { type: [Number, String], default: "" },
    type: { type: String, default: "text" },
    inputClass: { type: String, default: "" },
    pattern: { type: String },
    inputmode: { type: String, default: "text" },
    counter: { type: Boolean, default: false },
    // style
    ariaResetLabel: { type: String, default: "$t:reset" },
    /** Set value to input when model value is updated */
    strictBindInputValue: { type: Boolean, default: false }
  },
  emits: [
    "update:modelValue",
    ...useValidationEmits,
    ...useClearableEmits,
    ...createInputEmits(),
    ...createFieldEmits(),
    ...useStatefulEmits
  ],
  inheritAttrs: false,
  setup(props2, { emit, attrs, slots }) {
    useDeprecatedCondition([
      () => props2.type !== "textarea" || 'Use VaTextarea component instead of VaInput with type="textarea"'
    ]);
    const input = shallowRef();
    const { valueComputed } = useStateful(props2, emit, "modelValue");
    const reset = () => withoutValidation(() => {
      emit("update:modelValue", props2.clearValue);
      emit("clear");
      resetValidation();
    });
    const { focus, blur } = useFocusable(input, props2);
    const filterSlots = computed(() => {
      const iconSlot = ["icon"];
      return Object.keys(slots).filter((slot) => !iconSlot.includes(slot));
    });
    const {
      isDirty,
      computedError,
      computedErrorMessages,
      listeners: { onBlur, onFocus },
      validationAriaAttributes,
      isLoading,
      withoutValidation,
      resetValidation
    } = useValidation(props2, emit, { reset, focus, value: valueComputed });
    const { modelValue } = toRefs(props2);
    const {
      canBeCleared,
      clearIconProps
    } = useClearable(props2, modelValue, input, computedError);
    const { computedValue, onInput } = useCleave(input, props2, valueComputed);
    const inputListeners = createInputListeners(emit);
    const inputEvents = {
      ...inputListeners,
      onFocus: combineFunctions(onFocus, inputListeners.onFocus),
      onBlur: combineFunctions(onBlur, inputListeners.onBlur),
      onInput: combineFunctions(onInput, inputListeners.onInput)
    };
    const setInputValue = (newValue) => {
      if (!props2.strictBindInputValue) {
        return;
      }
      const target = input.value;
      if (!target) {
        return;
      }
      const selectionStart = target.selectionStart || 0;
      const selectionEnd = target.selectionEnd || 0;
      if (target.value !== newValue) {
        target.value = String(newValue);
      }
      target.setSelectionRange(selectionStart, selectionEnd);
    };
    watch(computedValue, (newValue) => {
      setInputValue(String(newValue));
    });
    useEvent("input", () => {
      setInputValue(String(valueComputed.value));
    }, input);
    const tabIndexComputed = computed(() => props2.disabled ? -1 : props2.tabindex);
    const computedChildAttributes = computed(() => ({
      "aria-label": props2.inputAriaLabel || props2.label,
      "aria-labelledby": props2.inputAriaLabelledby,
      "aria-required": props2.requiredMark,
      tabindex: tabIndexComputed.value,
      class: props2.inputClass,
      "aria-disabled": props2.disabled,
      "aria-readonly": props2.readonly,
      ...validationAriaAttributes.value,
      ...omit$1(attrs, ["class", "style"])
    }));
    const computedInputAttributes = computed(() => ({
      ...computedChildAttributes.value,
      ...pick$1(props2, ["type", "disabled", "readonly", "placeholder", "pattern", "inputmode", "minlength", "maxlength"])
    }));
    const valueLengthComputed = computed(
      () => props2.counter && typeof computedValue.value === "string" ? computedValue.value.length : void 0
    );
    const onFieldClick = (e2) => {
      if (!e2.target || !("tagName" in e2.target)) {
        return;
      }
      if (e2.target.tagName === "INPUT" || e2.target.tagName === "TEXTAREA") {
        return;
      }
      focus();
    };
    return {
      ...useTranslation(),
      onFieldClick,
      input,
      inputEvents,
      isLoading,
      valueLengthComputed,
      computedChildAttributes,
      computedInputAttributes,
      wrapperProps: filterComponentProps(VaInputWrapperProps),
      computedValue,
      tabIndexComputed,
      // Validations
      computedError,
      computedErrorMessages,
      // Icon
      canBeCleared,
      clearIconProps,
      fieldListeners: createFieldListeners(emit),
      filterSlots,
      isDirty,
      reset,
      focus,
      blur
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-input/VaInput.js
var _hoisted_120 = ["value"];
function _sfc_render37(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  return openBlock(), createBlock(_component_va_input_wrapper, mergeProps({
    ..._ctx.fieldListeners,
    ..._ctx.wrapperProps
  }, {
    class: ["va-input", _ctx.$attrs.class],
    style: _ctx.$attrs.style,
    loading: _ctx.$props.loading || _ctx.isLoading,
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages,
    "error-count": _ctx.errorCount,
    "counter-value": _ctx.valueLengthComputed,
    onClick: _ctx.onFieldClick
  }), createSlots({
    icon: withCtx((slotScope) => [
      _ctx.canBeCleared ? (openBlock(), createBlock(_component_va_icon, mergeProps({
        key: 0,
        role: "button",
        "aria-label": _ctx.tp(_ctx.$props.ariaResetLabel)
      }, _ctx.clearIconProps, {
        onClick: withModifiers(_ctx.reset, ["stop"]),
        onKeydown: [
          withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
          withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
        ]
      }), null, 16, ["aria-label", "onClick", "onKeydown"])) : createCommentVNode("", true),
      renderSlot(_ctx.$slots, "icon", normalizeProps(guardReactiveProps(slotScope)))
    ]),
    default: withCtx(() => [
      !_ctx.$slots.content ? (openBlock(), createElementBlock("input", mergeProps({
        key: 0,
        ref: "input",
        class: "va-input__content__input"
      }, { ..._ctx.computedInputAttributes, ..._ctx.inputEvents }, { value: _ctx.computedValue }), null, 16, _hoisted_120)) : createCommentVNode("", true)
    ]),
    _: 2
  }, [
    renderList(_ctx.filterSlots, (name) => {
      return {
        name,
        fn: withCtx((slotScope) => [
          renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
        ])
      };
    })
  ]), 1040, ["class", "style", "loading", "error", "error-messages", "error-count", "counter-value", "onClick"]);
}
var _VaInput = _export_sfc(_sfc_main40, [["render", _sfc_render37]]);

// node_modules/vuestic-ui/dist/es/src/components/va-input/index.js
var VaInput = withConfigTransport$1(_VaInput);

// node_modules/vuestic-ui/dist/es/src/components/va-color-input/VaColorInput.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaColorInput.css";
var VaInputProps = extractComponentProps(VaInput);
var _sfc_main41 = defineComponent({
  name: "VaColorInput",
  components: {
    VaInput,
    VaColorIndicator
  },
  emits: [...useStatefulEmits],
  props: {
    ...VaInputProps,
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: String, default: null },
    disabled: { type: Boolean, default: false },
    indicator: {
      type: String,
      default: "dot",
      validator: (value) => ["dot", "square"].includes(value)
    },
    ariaOpenColorPickerLabel: { type: String, default: "$t:openColorPicker" }
  },
  setup: (props2, { emit }) => {
    const colorPicker = shallowRef();
    const { valueComputed } = useStateful(props2, emit);
    const callPickerDialog = () => {
      var _a2;
      return !props2.disabled && ((_a2 = colorPicker.value) == null ? void 0 : _a2.click());
    };
    const tabIndexComputed = computed(() => props2.disabled ? -1 : 0);
    const inputValue = computed({
      get: () => props2.modelValue,
      set: throttle$1((value) => emit("update:modelValue", value), 500)
    });
    return {
      ...useTranslation(),
      valueComputed,
      inputValue,
      callPickerDialog,
      colorPicker,
      tabIndexComputed,
      vaInputProps: filterComponentProps(VaInputProps)
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-color-input/VaColorInput.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaColorInput.css";
var _hoisted_121 = { class: "va-color-input" };
function _sfc_render38(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_color_indicator = resolveComponent("va-color-indicator");
  const _component_va_input = resolveComponent("va-input");
  return openBlock(), createElementBlock("div", _hoisted_121, [
    createVNode(_component_va_input, mergeProps(_ctx.vaInputProps, {
      modelValue: _ctx.valueComputed,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.valueComputed = $event),
      class: "va-color-input__input",
      tabindex: _ctx.tabIndexComputed
    }), {
      appendInner: withCtx(() => [
        createVNode(_component_va_color_indicator, {
          class: "va-color-input__dot",
          role: "button",
          "aria-label": _ctx.tp(_ctx.$props.ariaOpenColorPickerLabel),
          "aria-disabled": _ctx.$props.disabled,
          tabindex: _ctx.tabIndexComputed,
          color: _ctx.valueComputed,
          indicator: _ctx.$props.indicator,
          size: "16px",
          onClick: _ctx.callPickerDialog,
          onKeydown: [
            withKeys(_ctx.callPickerDialog, ["space"]),
            withKeys(_ctx.callPickerDialog, ["enter"])
          ]
        }, null, 8, ["aria-label", "aria-disabled", "tabindex", "color", "indicator", "onClick", "onKeydown"])
      ]),
      _: 1
    }, 16, ["modelValue", "tabindex"]),
    withDirectives(createBaseVNode("input", {
      ref: "colorPicker",
      type: "color",
      class: "va-color-input__hidden-input",
      "aria-hidden": "true",
      tabindex: "-1",
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.inputValue = $event)
    }, null, 512), [
      [vModelText, _ctx.inputValue]
    ])
  ]);
}
var _VaColorInput = _export_sfc(_sfc_main41, [["render", _sfc_render38]]);

// node_modules/vuestic-ui/dist/es/src/components/va-color-input/index.js
var VaColorInput = withConfigTransport$1(_VaColorInput);

// node_modules/vuestic-ui/dist/es/src/components/va-color-palette/VaColorPalette.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaColorPalette.css";
var _sfc_main42 = defineComponent({
  name: "VaColorPalette",
  components: { VaColorIndicator },
  emits: [...useStatefulEmits],
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: String, default: null },
    palette: { type: Array, default: () => [] },
    indicator: {
      type: String,
      default: "dot",
      validator: (value) => ["dot", "square"].includes(value)
    },
    ariaLabel: { type: String, default: "$t:colorSelection" },
    ariaIndicatorLabel: { type: String, default: "$t:color" }
  },
  setup(props2, { emit }) {
    const { valueComputed } = useStateful(props2, emit);
    return {
      ...useTranslation(),
      valueComputed,
      isSelected: (color) => valueComputed.value === color
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-color-palette/VaColorPalette.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaColorPalette.css";
var _hoisted_122 = ["aria-label"];
function _sfc_render39(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_color_indicator = resolveComponent("va-color-indicator");
  return openBlock(), createElementBlock("ul", {
    class: "va-color-palette",
    role: "listbox",
    "aria-label": _ctx.tp(_ctx.$props.ariaLabel)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.palette, (color, index) => {
      return openBlock(), createBlock(_component_va_color_indicator, {
        key: index,
        role: "option",
        "aria-label": _ctx.tp(_ctx.$props.ariaIndicatorLabel, { color }),
        "aria-selected": _ctx.isSelected(color),
        tabindex: "0",
        modelValue: _ctx.isSelected(color),
        color,
        square: _ctx.indicator === "square",
        "onUpdate:modelValue": ($event) => _ctx.valueComputed = color
      }, null, 8, ["aria-label", "aria-selected", "modelValue", "color", "square", "onUpdate:modelValue"]);
    }), 128))
  ], 8, _hoisted_122);
}
var _VaColorPalette = _export_sfc(_sfc_main42, [["render", _sfc_render39]]);

// node_modules/vuestic-ui/dist/es/src/components/va-color-palette/index.js
var VaColorPalette = withConfigTransport$1(_VaColorPalette);

// node_modules/vuestic-ui/dist/es/src/components/va-content/VaContent.js
var _sfc_main43 = {
  name: "VaContent"
};
var _hoisted_123 = { class: "va-typography-block" };
function _sfc_render40(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_123, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var _VaContent = _export_sfc(_sfc_main43, [["render", _sfc_render40]]);

// node_modules/vuestic-ui/dist/es/src/components/va-content/index.js
var VaContent = withConfigTransport$1(_VaContent);

// node_modules/vuestic-ui/dist/es/src/utils/css.js
var safeCSSLength = (length) => typeof length === "number" ? `${length}px` : length;

// node_modules/vuestic-ui/dist/es/src/components/va-counter/hooks/useCounterPropsValidation.js
function useCounterPropsValidation(props2) {
  const validateCounterProps = () => {
    const val = Number(props2.modelValue);
    if (Number.isNaN(val)) {
      warn("The value is not a number or cannot be reduced to a number.");
      return;
    }
    if (props2.min && props2.max && props2.min > props2.max) {
      warn(`The maximum value (${props2.max}) can not be less than the minimum value (${props2.min}).`);
    }
    if (props2.min && val < props2.min) {
      warn(`The value of the counter (${val}) can not be less than the minimum value (${props2.min}).`);
    }
    if (props2.max && val > props2.max) {
      warn(`The value of the counter (${val}) can not be greater than the maximum value (${props2.max}).`);
    }
    if (props2.min && props2.max && props2.step > props2.max - props2.min) {
      warn(`The value of the step (${props2.step}) can not be greater than the difference (${props2.max - props2.min}) between maximum value (${props2.max}) and minimum value (${props2.min}).`);
    }
  };
  watch(
    [
      () => props2.step,
      () => props2.min,
      () => props2.max
    ],
    validateCounterProps,
    { immediate: true }
  );
}

// node_modules/vuestic-ui/dist/es/src/composables/useLongPress.js
function useLongPress(el, options) {
  let timeoutId = -1;
  let intervalId = -1;
  const handleMouseDown = () => {
    var _a2;
    (_a2 = options.onStart) == null ? void 0 : _a2.call(options);
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      intervalId = setInterval(() => {
        var _a22;
        return (_a22 = options.onUpdate) == null ? void 0 : _a22.call(options);
      }, options.interval || 100);
    }, unref(options.delay) || 500);
  };
  const handleMouseUp = () => {
    var _a2;
    clearTimeout(timeoutId);
    clearInterval(intervalId);
    (_a2 = options.onEnd) == null ? void 0 : _a2.call(options);
  };
  const htmlElement = useHTMLElement(el);
  useEvent(["mousedown", "touchstart", "dragstart"], handleMouseDown, htmlElement);
  useEvent([
    "mouseup",
    "mouseleave",
    "touchend",
    "touchcancel",
    "drop",
    "dragend",
    "blur"
  ], handleMouseUp, true);
}

// node_modules/vuestic-ui/dist/es/src/components/va-counter/VaCounter.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaCounter.css";
var { createEmits: createInputEmits2, createListeners: createInputListeners2 } = useEmitProxy(
  ["change"]
);
var { createEmits: createFieldEmits2, createListeners: createFieldListeners2 } = useEmitProxy([
  { listen: "click-prepend", emit: "click:decrease-button" },
  { listen: "click-append", emit: "click:increase-button" },
  { listen: "click-prepend-inner", emit: "click:decrease-icon" },
  { listen: "click-append-inner", emit: "click:increase-icon" }
]);
var VaInputWrapperProps2 = extractComponentProps(VaInputWrapper);
var _sfc_main44 = defineComponent({
  name: "VaCounter",
  components: { VaInputWrapper, VaButton },
  props: {
    ...useFormFieldProps,
    ...useStatefulProps,
    ...useComponentPresetProp,
    ...useClearableProps,
    ...VaInputWrapperProps2,
    // input
    modelValue: { type: [String, Number], default: 0 },
    manualInput: { type: Boolean, default: false },
    min: { type: Number, default: void 0 },
    max: { type: Number, default: void 0 },
    step: { type: Number, default: 1 },
    color: { type: String, default: "primary" },
    // icons & buttons
    increaseIcon: { type: String, default: "add" },
    decreaseIcon: { type: String, default: "remove" },
    buttons: { type: Boolean, default: false },
    flat: { type: Boolean, default: true },
    rounded: { type: Boolean, default: false },
    margins: { type: [String, Number], default: "4px" },
    longPressDelay: { type: Number, default: 500 },
    ariaLabel: { type: String, default: "$t:counterValue" },
    ariaDecreaseLabel: { type: String, default: "$t:decreaseCounter" },
    ariaIncreaseLabel: { type: String, default: "$t:increaseCounter" }
  },
  emits: [
    "update:modelValue",
    ...useValidationEmits,
    ...createInputEmits2(),
    ...createFieldEmits2(),
    ...useFocusEmits
  ],
  inheritAttrs: false,
  setup(props2, { emit, attrs, slots }) {
    const input = shallowRef();
    const { min: min2, max: max2, step } = toRefs(props2);
    const {
      isFocused,
      focus,
      blur
    } = useFocus(input, emit);
    const { valueComputed } = useStateful(props2, emit);
    const reset = () => withoutValidation(() => {
      emit("update:modelValue", props2.clearValue);
      emit("clear");
      resetValidation();
    });
    const {
      computedError,
      computedErrorMessages,
      withoutValidation,
      resetValidation
    } = useValidation(props2, emit, { reset, focus, value: valueComputed });
    const setCountInput = ({ target }) => {
      valueComputed.value = Number(target == null ? void 0 : target.value);
    };
    const setCountChange = ({ target }) => {
      calculateCounterValue(Number(target == null ? void 0 : target.value));
    };
    const getRoundDownWithStep = (value) => {
      if (typeof min2.value === "undefined" || !step.value) {
        return value;
      }
      return min2.value + step.value * Math.floor((value - min2.value) / step.value);
    };
    const calculateCounterValue = (counterValue) => {
      if (typeof min2.value !== "undefined" && counterValue < min2.value) {
        valueComputed.value = min2.value;
        return;
      }
      if (max2.value && counterValue > max2.value) {
        valueComputed.value = getRoundDownWithStep(max2.value);
        return;
      }
      valueComputed.value = getRoundDownWithStep(counterValue);
    };
    const isMinReached = computed(() => {
      if (typeof min2.value === "undefined") {
        return false;
      }
      return Number(valueComputed.value) <= min2.value;
    });
    const isMaxReached = computed(() => {
      if (typeof max2.value === "undefined") {
        return false;
      }
      return step.value ? Number(valueComputed.value) > max2.value - step.value : Number(valueComputed.value) >= max2.value;
    });
    const tabIndexComputed = computed(() => props2.disabled ? -1 : 0);
    const isDecreaseActionDisabled = computed(() => isMinReached.value || props2.disabled);
    const isIncreaseActionDisabled = computed(() => isMaxReached.value || props2.disabled);
    const decreaseCount = () => {
      if (isDecreaseActionDisabled.value) {
        return;
      }
      calculateCounterValue(Number(valueComputed.value) - step.value);
    };
    const increaseCount = () => {
      if (isIncreaseActionDisabled.value) {
        return;
      }
      calculateCounterValue(Number(valueComputed.value) + step.value);
    };
    useLongPress(useTemplateRef("decreaseButtonRef"), {
      onUpdate: decreaseCount,
      delay: toRef(props2, "longPressDelay")
    });
    useLongPress(useTemplateRef("increaseButtonRef"), {
      onUpdate: increaseCount,
      delay: toRef(props2, "longPressDelay")
    });
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props2.color));
    const decreaseIconProps = computed(() => ({
      class: { "va-counter__icon--inactive": isDecreaseActionDisabled.value },
      color: colorComputed.value,
      icon: props2.decreaseIcon,
      plain: true,
      disabled: isDecreaseActionDisabled.value,
      readonly: props2.readonly,
      tabindex: -1,
      "aria-label": tp(props2.ariaDecreaseLabel),
      ...!isDecreaseActionDisabled.value && { onClick: decreaseCount }
    }));
    const increaseIconProps = computed(() => ({
      class: { "va-counter__icon--inactive": isIncreaseActionDisabled.value },
      color: colorComputed.value,
      icon: props2.increaseIcon,
      plain: true,
      disabled: isIncreaseActionDisabled.value,
      readonly: props2.readonly,
      tabindex: -1,
      "aria-label": tp(props2.ariaIncreaseLabel),
      ...!isIncreaseActionDisabled.value && { onClick: increaseCount }
    }));
    const isSquareCorners = computed(() => (typeof props2.margins === "string" ? parseFloat(props2.margins) : props2.margins) === 0);
    const buttonsColor = () => {
      if (isFocused.value) {
        return props2.color;
      }
      return "background-border";
    };
    const buttonProps = computed(() => ({
      ...pick$1(props2, ["color", "textColor"]),
      round: props2.rounded,
      preset: props2.flat ? "secondary" : "",
      borderColor: props2.flat ? buttonsColor() : ""
    }));
    const decreaseButtonProps = computed(() => ({
      ...buttonProps.value,
      icon: props2.decreaseIcon,
      disabled: isDecreaseActionDisabled.value,
      "aria-label": tp(props2.ariaDecreaseLabel),
      ...!isDecreaseActionDisabled.value && { onClick: decreaseCount }
    }));
    const increaseButtonProps = computed(() => ({
      ...buttonProps.value,
      icon: props2.increaseIcon,
      disabled: isIncreaseActionDisabled.value,
      "aria-label": tp(props2.ariaIncreaseLabel),
      ...!isIncreaseActionDisabled.value && { onClick: increaseCount }
    }));
    const { tp } = useTranslation();
    const inputAttributesComputed = computed(() => ({
      tabindex: tabIndexComputed.value,
      "aria-label": tp(props2.ariaLabel),
      "aria-valuemin": min2.value,
      "aria-valuemax": max2.value,
      ...omit$1(attrs, ["class", "style"]),
      ...pick$1(props2, ["disabled", "min", "max", "step"]),
      readonly: props2.readonly || !props2.manualInput
    }));
    const classComputed = computed(() => [
      attrs.class,
      { "va-counter--input-square": isSquareCorners.value },
      { "va-counter--content-slot": slots.content && props2.buttons }
    ].filter(Boolean));
    const styleComputed = computed(() => ({
      ...attrs.style || {}
    }));
    const marginComputed = computed(() => safeCSSLength(props2.margins));
    useCounterPropsValidation(props2);
    return {
      tp,
      input,
      valueComputed,
      isFocused,
      computedError,
      computedErrorMessages,
      fieldListeners: createFieldListeners2(emit),
      inputListeners: createInputListeners2(emit),
      inputWrapperPropsComputed: filterComponentProps(VaInputWrapperProps2),
      inputAttributesComputed,
      setCountInput,
      setCountChange,
      decreaseCount,
      increaseCount,
      decreaseIconProps,
      increaseIconProps,
      decreaseButtonProps,
      increaseButtonProps,
      colorComputed,
      classComputed,
      styleComputed,
      marginComputed,
      focus,
      blur
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-counter/VaCounter.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaCounter.css";
var _hoisted_124 = {
  ref: "input",
  tabindex: "0",
  class: "va-counter__content-wrapper"
};
var _hoisted_211 = ["value", "aria-live"];
function _sfc_render41(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  return openBlock(), createBlock(_component_va_input_wrapper, mergeProps({ class: "va-counter" }, { ..._ctx.fieldListeners, ..._ctx.inputWrapperPropsComputed }, {
    class: _ctx.classComputed,
    style: _ctx.styleComputed,
    focused: _ctx.isFocused,
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages,
    onKeydown: [
      withKeys(withModifiers(_ctx.increaseCount, ["prevent"]), ["up"]),
      withKeys(withModifiers(_ctx.increaseCount, ["prevent"]), ["right"]),
      withKeys(withModifiers(_ctx.decreaseCount, ["prevent"]), ["down"]),
      withKeys(withModifiers(_ctx.decreaseCount, ["prevent"]), ["left"])
    ]
  }), createSlots({
    default: withCtx(() => [
      !_ctx.$slots.content ? (openBlock(), createElementBlock("input", mergeProps({
        key: 0,
        ref: "input",
        class: "va-input__content__input",
        type: "number",
        inputmode: "decimal"
      }, { ..._ctx.inputAttributesComputed, ..._ctx.inputListeners }, {
        value: _ctx.valueComputed,
        "aria-live": _ctx.$props.disabled ? "off" : "polite",
        onInput: _cache[4] || (_cache[4] = (...args) => _ctx.setCountInput && _ctx.setCountInput(...args)),
        onChange: _cache[5] || (_cache[5] = (...args) => _ctx.setCountChange && _ctx.setCountChange(...args))
      }), null, 16, _hoisted_211)) : createCommentVNode("", true)
    ]),
    _: 2
  }, [
    _ctx.$props.buttons ? {
      name: "prepend",
      fn: withCtx((slotScope) => [
        createBaseVNode("div", {
          class: "va-counter__prepend-wrapper",
          style: normalizeStyle({ marginRight: _ctx.marginComputed }),
          onMousedown: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.focus && _ctx.focus(...args), ["prevent"]))
        }, [
          renderSlot(_ctx.$slots, "decreaseAction", normalizeProps(guardReactiveProps({ ...slotScope, decreaseCount: _ctx.decreaseCount })), () => [
            createVNode(_component_va_button, mergeProps({ class: "va-counter__button-decrease" }, _ctx.decreaseButtonProps, { ref: "decreaseButtonRef" }), null, 16)
          ])
        ], 36)
      ]),
      key: "0"
    } : {
      name: "prependInner",
      fn: withCtx((slotScope) => [
        createBaseVNode("div", {
          class: "va-counter__prepend-inner",
          onMousedown: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.focus && _ctx.focus(...args), ["prevent"]))
        }, [
          renderSlot(_ctx.$slots, "decreaseAction", normalizeProps(guardReactiveProps({ ...slotScope, decreaseCount: _ctx.decreaseCount })), () => [
            createVNode(_component_va_button, mergeProps(_ctx.decreaseIconProps, { ref: "decreaseButtonRef" }), null, 16)
          ])
        ], 32)
      ]),
      key: "1"
    },
    _ctx.$props.buttons ? {
      name: "append",
      fn: withCtx((slotScope) => [
        createBaseVNode("div", {
          class: "va-counter__append-wrapper",
          style: normalizeStyle({ marginLeft: _ctx.marginComputed }),
          onMousedown: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.focus && _ctx.focus(...args), ["prevent"]))
        }, [
          renderSlot(_ctx.$slots, "increaseAction", normalizeProps(guardReactiveProps({ ...slotScope, increaseCount: _ctx.increaseCount })), () => [
            createVNode(_component_va_button, mergeProps({ class: "va-counter__button-increase" }, _ctx.increaseButtonProps, { ref: "increaseButtonRef" }), null, 16)
          ])
        ], 36)
      ]),
      key: "2"
    } : {
      name: "appendInner",
      fn: withCtx((slotScope) => [
        createBaseVNode("div", {
          class: "va-counter__append-inner",
          onMousedown: _cache[3] || (_cache[3] = withModifiers((...args) => _ctx.focus && _ctx.focus(...args), ["prevent"]))
        }, [
          renderSlot(_ctx.$slots, "increaseAction", normalizeProps(guardReactiveProps({ ...slotScope, increaseCount: _ctx.increaseCount })), () => [
            createVNode(_component_va_button, mergeProps(_ctx.increaseIconProps, { ref: "increaseButtonRef" }), null, 16)
          ])
        ], 32)
      ]),
      key: "3"
    },
    _ctx.$slots.content ? {
      name: "default",
      fn: withCtx((slotScope) => [
        createBaseVNode("div", _hoisted_124, [
          renderSlot(_ctx.$slots, "content", normalizeProps(guardReactiveProps({ ...slotScope, value: Number(_ctx.valueComputed) })))
        ], 512)
      ]),
      key: "4"
    } : void 0
  ]), 1040, ["class", "style", "focused", "error", "error-messages", "onKeydown"]);
}
var _VaCounter = _export_sfc(_sfc_main44, [["render", _sfc_render41]]);

// node_modules/vuestic-ui/dist/es/src/components/va-counter/index.js
var VaCounter = withConfigTransport$1(_VaCounter);

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useCommonProps.js
var useCurrentPageProp = { currentPage: { type: Number } };
var useItemsProp = { items: { type: Array, default: () => [] } };
var useSelectableProp = { selectable: { type: Boolean, default: false } };
var useItemsTrackByProp = { itemsTrackBy: { type: [String, Function], default: "" } };

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useColumns.js
var sortingOptionsValidator = (options) => {
  const isAllowedOptionsLength = options.length === 2 || options.length === 3;
  const isAvailableOptions = options.every((option) => ["asc", "desc", null].includes(option));
  const isUniqueOptions = options.length === new Set(options).size;
  return isAllowedOptionsLength && isAvailableOptions && isUniqueOptions;
};
var useColumnsProps = {
  ...useItemsProp,
  columns: { type: Array, default: () => [] },
  sortingOptions: {
    type: Array,
    default: () => ["asc", "desc", null],
    validator: sortingOptionsValidator
  }
};
var buildTableColumn = (source, initialIndex, props2) => {
  const input = typeof source === "string" ? { key: source } : source;
  const isValidOptions = input.sortingOptions ? sortingOptionsValidator(input.sortingOptions) : true;
  if (!isValidOptions) {
    warn(`The "sortingOptions" array in the column with "${input.key}" key is invalid. For this column, the "sortingOptions" value is taken as for the table: ${JSON.stringify(props2.sortingOptions)}.`);
  }
  return {
    source,
    initialIndex,
    key: input.key,
    name: input.name || input.key,
    label: input.label || startCase$1(input.key),
    thTitle: input.thTitle || input.headerTitle || input.label || startCase$1(input.key),
    sortable: input.sortable || false,
    sortingFn: input.sortingFn,
    sortingOptions: isValidOptions && input.sortingOptions || props2.sortingOptions,
    thAlign: input.thAlign || input.alignHead || "left",
    thVerticalAlign: input.thVerticalAlign || input.verticalAlignHead || "middle",
    tdAlign: input.tdAlign || input.align || "left",
    tdVerticalAlign: input.tdVerticalAlign || input.verticalAlign || "middle",
    width: input.width,
    tdClass: input.tdClass || input.classes,
    thClass: input.thClass || input.headerClasses,
    tdStyle: input.tdStyle || input.style,
    thStyle: input.thStyle || input.headerStyle
  };
};
var buildColumnsFromItems = (props2) => {
  return Object.keys(merge$1({}, ...props2.items)).map((item, index) => buildTableColumn(item, index, props2));
};
var buildNormalizedColumns = (props2) => {
  return props2.columns.map((item, index) => buildTableColumn(item, index, props2));
};
var useColumns = (props2) => {
  const columnsComputed = computed(() => {
    if (props2.columns.length === 0) {
      return buildColumnsFromItems(props2);
    } else {
      return buildNormalizedColumns(props2);
    }
  });
  return {
    columnsComputed
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useThrottle.js
var useThrottleProps = {
  delay: {
    type: Number,
    default: 0,
    validator: (value) => value >= 0
  }
};
function useThrottleFunction(fn, props2) {
  const delay = toRef(props2, "delay") ?? 0;
  const isThrottled = ref(true);
  let lastCallResult = void 0;
  return function(...args) {
    const invoke = () => fn.apply(this, args);
    if (!unref(delay)) {
      return invoke();
    }
    if (isThrottled.value) {
      isThrottled.value = false;
      setTimeout(() => isThrottled.value = true, unref(delay));
      lastCallResult = invoke();
    }
    return lastCallResult;
  };
}
function useThrottleValue(value, props2) {
  const delay = toRef(props2, "delay") ?? 0;
  if (!unref(delay)) {
    return value;
  }
  const isThrottled = ref(true);
  const previousCallValue = ref();
  const previousReturnedValue = ref();
  const currentCallValue = ref();
  watch(value, () => {
    previousCallValue.value = value.value;
    const lastCallValue = setTimeout(() => {
      currentCallValue.value = previousCallValue.value;
    }, unref(delay));
    if (isThrottled.value) {
      isThrottled.value = false;
      currentCallValue.value = value.value;
      previousReturnedValue.value = value.value;
      clearTimeout(lastCallValue);
      setTimeout(() => isThrottled.value = true, unref(delay));
    } else {
      currentCallValue.value = previousReturnedValue.value;
    }
  }, { immediate: true });
  return currentCallValue;
}

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/usePaginatedRows.js
var usePaginatedRowsProps = {
  ...useThrottleProps,
  ...useCurrentPageProp,
  perPage: { type: Number }
};
var usePaginatedRows = (sortedRows, props2) => {
  const paginatedRows = computed(() => {
    if (!props2.perPage || props2.perPage < 0) {
      return sortedRows.value;
    }
    if (!props2.currentPage || props2.currentPage < 0) {
      return sortedRows.value.slice(0, props2.perPage);
    }
    const pageStartIndex = props2.perPage * (props2.currentPage - 1);
    return sortedRows.value.slice(pageStartIndex, pageStartIndex + props2.perPage);
  });
  const paginatedRowsThrottled = useThrottleValue(paginatedRows, props2);
  return {
    paginatedRows: paginatedRowsThrottled
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useRows.js
var getItemKey = (source, itemsTrackBy) => typeof itemsTrackBy === "function" ? itemsTrackBy(source) : getValueByPath(source, itemsTrackBy) || source;
var useRowsProps = {
  ...useItemsProp,
  ...useItemsTrackByProp
};
var buildTableCell = (rowIndex, rowKey, rowData, column) => {
  var _a2;
  const source = getValueByPath(rowData, column.key);
  return {
    rowIndex,
    rowKey,
    rowData,
    column,
    source,
    value: ((_a2 = source == null ? void 0 : source.toString) == null ? void 0 : _a2.call(source)) || ""
  };
};
var buildTableRow = (source, initialIndex, itemsTrackBy, columns) => {
  const itemKey = getItemKey(source, itemsTrackBy);
  return {
    initialIndex,
    itemKey,
    source,
    cells: columns.map((column) => buildTableCell(initialIndex, itemKey, source, column)),
    rowData: source
  };
};
var useRows = (columns, props2) => {
  const expandableRows = ref({});
  const rowsComputed = computed(() => props2.items.map((rawItem, index) => ({
    ...buildTableRow(rawItem, index, props2.itemsTrackBy, columns.value),
    toggleRowDetails: (show) => {
      if (typeof show === "boolean") {
        expandableRows.value[index] = show;
      } else {
        expandableRows.value[index] = !expandableRows.value[index];
      }
    },
    isExpandableRowVisible: !!expandableRows.value[index]
  })));
  return {
    rowsComputed
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useSelectableRow.js
var useSelectableProps2 = {
  ...useSelectableProp,
  ...useItemsTrackByProp,
  modelValue: { type: Array },
  selectMode: { type: String, default: "multiple" }
};
var useSelectableRow = (paginatedRows, props2, emit) => {
  const selectedItemsFallback = ref([]);
  const selectedItemsSync = computed({
    get() {
      if (props2.modelValue === void 0) {
        return selectedItemsFallback.value;
      } else {
        return props2.modelValue;
      }
    },
    set(modelValue) {
      if (props2.modelValue === void 0) {
        selectedItemsFallback.value = modelValue;
      }
      emit("update:modelValue", modelValue);
    }
  });
  const prevSelectedRowIndex = ref(-1);
  watch(() => props2.selectMode, (newSelectMode, oldSelectMode) => {
    if (newSelectMode === "single" && oldSelectMode === "multiple") {
      selectedItemsSync.value = [];
      setPrevSelectedRowIndex(-1);
    }
  });
  watch(paginatedRows, () => {
    setPrevSelectedRowIndex(-1);
  });
  watch(selectedItemsSync, (currentSelectedItems, previousSelectedItems = []) => {
    emit("selectionChange", {
      currentSelectedItems,
      previousSelectedItems
    });
  }, { immediate: true });
  const getKey = (source) => getItemKey(source, props2.itemsTrackBy);
  const noRowsSelected = computed(() => !paginatedRows.value.some(({ source }) => selectedItemsSync.value.includes(getKey(source))));
  const allRowsSelected = computed(() => {
    if (paginatedRows.value.length === 0) {
      return false;
    }
    return paginatedRows.value.every(({ source }) => selectedItemsSync.value.includes(getKey(source)));
  });
  const severalRowsSelected = computed(() => !noRowsSelected.value && !allRowsSelected.value);
  function isRowSelected(row) {
    return selectedItemsSync.value.includes(getKey(row.source));
  }
  function selectAllRows() {
    selectedItemsSync.value = [.../* @__PURE__ */ new Set([
      ...selectedItemsSync.value,
      ...paginatedRows.value.map((row) => getKey(row.source))
    ])];
  }
  function unselectAllRows() {
    const paginatedRowsKeys = paginatedRows.value.map((row) => getKey(row.source));
    selectedItemsSync.value = selectedItemsSync.value.filter((item) => !paginatedRowsKeys.includes(item));
  }
  function selectRow(row) {
    selectedItemsSync.value = [...selectedItemsSync.value, getKey(row.source)];
  }
  function selectOnlyRow(row) {
    selectedItemsSync.value = [getKey(row.source)];
  }
  function unselectRow(row) {
    const index = selectedItemsSync.value.findIndex((item) => item === getKey(row.source));
    selectedItemsSync.value = [
      ...selectedItemsSync.value.slice(0, index),
      ...selectedItemsSync.value.slice(index + 1)
    ];
  }
  function setPrevSelectedRowIndex(rowInitialIndex) {
    if (rowInitialIndex === -1) {
      prevSelectedRowIndex.value = -1;
    } else {
      const prevSelectedRow = paginatedRows.value.find((row) => row.initialIndex === rowInitialIndex);
      prevSelectedRow ? prevSelectedRowIndex.value = paginatedRows.value.indexOf(prevSelectedRow) : prevSelectedRowIndex.value = -1;
    }
  }
  function getRowsToSelect(targetIndex) {
    let start;
    let end;
    if (isRowSelected(paginatedRows.value[prevSelectedRowIndex.value])) {
      start = Math.min(prevSelectedRowIndex.value, targetIndex);
      end = Math.max(prevSelectedRowIndex.value, targetIndex);
    } else {
      start = Math.min(prevSelectedRowIndex.value + 1, targetIndex);
      end = Math.max(prevSelectedRowIndex.value - 1, targetIndex);
    }
    return paginatedRows.value.slice(start, end + 1);
  }
  function mergeSelection(rowsToSelect) {
    const rowsToSelectedItems = rowsToSelect.map((row) => getKey(row.source));
    if (noRowsSelected.value) {
      selectedItemsSync.value = rowsToSelectedItems;
      return;
    }
    const isInternalSelection = rowsToSelectedItems.every((item) => selectedItemsSync.value.includes(item));
    if (isInternalSelection) {
      selectedItemsSync.value = selectedItemsSync.value.filter((item) => !rowsToSelectedItems.includes(item));
      return;
    }
    selectedItemsSync.value = [.../* @__PURE__ */ new Set([
      ...selectedItemsSync.value,
      ...rowsToSelectedItems
    ])];
  }
  function toggleRowSelection(row) {
    if (!props2.selectable) {
      return;
    }
    if (isRowSelected(row)) {
      unselectRow(row);
      props2.selectMode === "single" ? setPrevSelectedRowIndex(-1) : setPrevSelectedRowIndex(row.initialIndex);
    } else {
      props2.selectMode === "single" ? selectOnlyRow(row) : selectRow(row);
      setPrevSelectedRowIndex(row.initialIndex);
    }
  }
  function ctrlSelectRow(row) {
    if (!props2.selectable) {
      return;
    }
    toggleRowSelection(row);
  }
  function shiftSelectRows(row) {
    if (!props2.selectable) {
      return;
    }
    if (props2.selectMode === "single" || prevSelectedRowIndex.value === -1) {
      return toggleRowSelection(row);
    }
    const targetIndex = paginatedRows.value.indexOf(row);
    mergeSelection(getRowsToSelect(targetIndex));
    setPrevSelectedRowIndex(-1);
  }
  function toggleBulkSelection() {
    if (allRowsSelected.value) {
      unselectAllRows();
    } else {
      selectAllRows();
    }
    setPrevSelectedRowIndex(-1);
  }
  return {
    ctrlSelectRow,
    shiftSelectRows,
    toggleRowSelection,
    toggleBulkSelection,
    isRowSelected,
    noRowsSelected,
    severalRowsSelected,
    allRowsSelected
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useStylable.js
var prefix = "--va-data-table";
var isFunction2 = (val) => typeof val === "function";
var useStylableProps = {
  ...useSelectableProp,
  selectedColor: { type: String, default: "primary" },
  allowFooterSorting: { type: Boolean, default: false },
  stickyHeader: { type: Boolean, default: false },
  stickyFooter: { type: Boolean, default: false },
  height: { type: [String, Number] }
};
var getClass = (classes) => isFunction2(classes) ? classes() : classes;
var getStyle = (styles) => isFunction2(styles) ? styles() : styles;
var useStylable = (props2) => {
  const { getColor, getFocusColor: getFocusColor2, getHoverColor: getHoverColor2 } = useColors();
  const color = computed(() => getColor(props2.selectedColor));
  const CSSVariables = computed(() => ({
    hoverColor: getHoverColor2(color.value),
    selectedColor: props2.selectable ? getFocusColor2(color.value) : void 0,
    tableHeight: props2.height ? safeCSSLength(props2.height) : "var(--va-data-table-height)",
    theadBg: props2.stickyHeader ? "var(--va-data-table-thead-background, var(--va-data-table-header-background))" : "var(--va-data-table-thead-background)",
    tfootBg: props2.stickyFooter ? "var(--va-data-table-tfoot-background, var(--va-data-table-header-background))" : "var(--va-data-table-tfoot-background)"
  }));
  const getHeaderCSSVariables = (column) => ({
    [`${prefix}-width`]: column.width && safeCSSLength(column.width),
    [`${prefix}-align`]: column.thAlign,
    [`${prefix}-vertical-align`]: column.thVerticalAlign,
    [`${prefix}-cursor`]: column.sortable ? "pointer" : "default"
  });
  const getCellCSSVariables = (cell) => ({
    [`${prefix}-align`]: cell.column.tdAlign,
    [`${prefix}-vertical-align`]: cell.column.tdVerticalAlign
  });
  const getFooterCSSVariables = (column) => ({
    [`${prefix}-align`]: column.thAlign,
    [`${prefix}-vertical-align`]: column.thVerticalAlign,
    [`${prefix}-cursor`]: props2.allowFooterSorting && column.sortable ? "pointer" : "default"
  });
  return {
    CSSVariables,
    getHeaderCSSVariables,
    getCellCSSVariables,
    getFooterCSSVariables,
    getClass,
    getStyle
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useBinding.js
var isFunction3 = (val) => typeof val === "function";
var isObject3 = (val) => val !== null && typeof val === "object";
var useBindingProps = {
  rowBind: { type: null },
  cellBind: { type: null }
};
var useBinding = (props2) => {
  const getRowBind = (row) => isFunction3(props2.rowBind) ? props2.rowBind(row.source, row.initialIndex) : isObject3(props2.rowBind) ? props2.rowBind : {};
  const getCellBind = (cell, row) => isFunction3(props2.cellBind) ? props2.cellBind(cell.source, row.source, cell.column, row.initialIndex) : isObject3(props2.cellBind) ? props2.cellBind : {};
  return {
    getRowBind,
    getCellBind
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useAnimationName.js
var useAnimationNameProps = {
  ...useCurrentPageProp,
  animated: { type: Boolean, default: true }
};
var useAnimationName = (props2, rows) => {
  const animationType = ref("shuffle");
  const animationName = computed(() => props2.animated ? `table-transition-${animationType.value}` : "");
  const oldRowsLength = ref(rows.value.length);
  const isDifferentRowLength = computed(() => rows.value.length !== oldRowsLength.value);
  watch(rows, (newRows, oldRows) => {
    const hasRows = !!(newRows.length && oldRows.length);
    animationType.value = newRows.length > 50 || isDifferentRowLength.value && hasRows ? "fade" : "shuffle";
    oldRowsLength.value = newRows.length;
  });
  watch(() => props2.currentPage, () => {
    if (!isDifferentRowLength.value) {
      animationType.value = "shuffle";
    }
  });
  return animationName;
};

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useFilterable.js
var useFilterableProps = {
  ...useThrottleProps,
  filter: { type: String, default: "" },
  filterMethod: { type: Function }
};
var useFilterable = (rawRows, props2, emit) => {
  const filteredRows = computed(() => {
    if (!rawRows.value.length) {
      return rawRows.value;
    }
    if (props2.filter === "" && !props2.filterMethod) {
      return rawRows.value;
    }
    return rawRows.value.filter((row) => row.cells.some((cell) => {
      return typeof props2.filterMethod === "function" ? props2.filterMethod(cell.source) : cell.value.toLowerCase().includes(props2.filter.toLowerCase());
    }));
  });
  const filteredRowsThrottled = useThrottleValue(filteredRows, props2);
  watch(filteredRowsThrottled, () => {
    emit("filtered", {
      items: filteredRowsThrottled.value.map((row) => row.source),
      itemsIndexes: filteredRowsThrottled.value.map((row) => row.initialIndex)
    });
  });
  if (filteredRows.value.length !== rawRows.value.length) {
    emit("filtered", {
      items: filteredRows.value.map((row) => row.source),
      itemsIndexes: filteredRows.value.map((row) => row.initialIndex)
    });
  }
  return {
    filteredRows: filteredRowsThrottled
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useSortable.js
var useSortableProps = {
  ...useThrottleProps,
  sortBy: { type: String },
  columnSorted: { type: Object },
  sortingOrder: { type: [String, null] },
  disableClientSideSorting: { type: Boolean, default: false }
};
var useSortable = (columns, filteredRows, props2, emit) => {
  const sortByFallback = ref("");
  const sortBySync = computed({
    get() {
      if (props2.sortBy === void 0) {
        return sortByFallback.value;
      } else {
        return props2.sortBy;
      }
    },
    set(value) {
      if (props2.sortBy === void 0) {
        sortByFallback.value = value;
      }
      emit("update:sortBy", value);
    }
  });
  const sortingOrderFallback = ref(null);
  const sortingOrderSync = computed({
    get() {
      if (props2.sortingOrder === void 0) {
        return sortingOrderFallback.value;
      } else {
        return props2.sortingOrder;
      }
    },
    set(value) {
      if (props2.sortingOrder === void 0) {
        sortingOrderFallback.value = value;
      }
      emit("update:sortingOrder", value);
    }
  });
  const sortedRows = computed(() => {
    if (props2.disableClientSideSorting) {
      return filteredRows.value;
    }
    if (filteredRows.value.length <= 1) {
      return filteredRows.value;
    }
    const columnIndex = columns.value.findIndex(
      ({ name, sortable }) => sortBySync.value === name && sortable
    );
    const column = columns.value[columnIndex];
    if (!column) {
      return filteredRows.value;
    }
    const sortingOrderRatio = sortingOrderSync.value === "desc" ? -1 : 1;
    return [...filteredRows.value].sort((a2, b2) => {
      if (sortingOrderSync.value === null) {
        return a2.initialIndex - b2.initialIndex;
      } else {
        const firstValue = a2.cells[columnIndex].value;
        const secondValue = b2.cells[columnIndex].value;
        const firstSource = a2.cells[columnIndex].source;
        const secondSource = b2.cells[columnIndex].source;
        return sortingOrderRatio * (typeof column.sortingFn === "function" ? column.sortingFn(firstSource, secondSource) : firstValue.localeCompare(secondValue));
      }
    });
  });
  watch(sortedRows, () => {
    emit("sorted", {
      sortBy: sortBySync.value,
      sortingOrder: sortingOrderSync.value,
      items: sortedRows.value.map((row) => row.source),
      itemsIndexes: sortedRows.value.map((row) => row.initialIndex)
    });
  });
  const getNextSortingOptionsValue = (value, options) => {
    const index = options.findIndex((sortingValue) => sortingValue === value);
    return index !== -1 ? options[(index + 1) % options.length] : options[0];
  };
  function toggleSorting(column) {
    let value;
    if (column.name === sortBySync.value) {
      value = getNextSortingOptionsValue(sortingOrderSync.value, column.sortingOptions);
    } else {
      sortBySync.value = column.name;
      value = column.sortingOptions[0];
    }
    sortingOrderSync.value = value;
    emit("columnSorted", { columnName: column.name, value, column });
  }
  const toggleSortingThrottled = useThrottleFunction(toggleSorting, props2);
  const sortingOrderIconName = computed(() => {
    return sortingOrderSync.value === "asc" ? "va-arrow-up" : sortingOrderSync.value === "desc" ? "va-arrow-down" : "unfold_more";
  });
  return {
    sortBySync,
    sortingOrderSync,
    toggleSorting: toggleSortingThrottled,
    sortedRows,
    sortingOrderIconName
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useElementRef.js
var unrefElement = (el) => {
  const e2 = unref(el);
  return unwrapEl(e2);
};
var useElementRef = () => {
  const el = shallowRef();
  return computed({
    get() {
      return unrefElement(el);
    },
    set(node) {
      el.value = node;
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useTableScroll.js
var useTableScrollProps = {
  scrollTopMargin: { type: Number, default: 0 },
  scrollBottomMargin: { type: Number, default: 0 }
};
var useTableScrollEmits = ["scroll:top", "scroll:bottom"];
var useTableScroll = (props2, emit) => {
  var _a2;
  const vNodeProps = (_a2 = getCurrentInstance()) == null ? void 0 : _a2.vnode.props;
  const doRenderTopTrigger = (vNodeProps == null ? void 0 : vNodeProps["onScroll:top"]) !== void 0;
  const doRenderBottomTrigger = (vNodeProps == null ? void 0 : vNodeProps["onScroll:bottom"]) !== void 0;
  const scrollContainer = useElementRef();
  const topTrigger = useElementRef();
  const bottomTrigger = useElementRef();
  const isObservable = computed(() => !!scrollContainer.value);
  const intersectionHandler = (entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        entry.target === topTrigger.value ? emit("scroll:top") : emit("scroll:bottom");
      }
    });
  };
  const targets = computed(() => {
    const list = [];
    if (isObservable.value) {
      topTrigger.value && list.push(topTrigger.value);
      bottomTrigger.value && list.push(bottomTrigger.value);
    }
    return list;
  });
  const options = computed(() => ({
    root: scrollContainer.value,
    rootMargin: `${props2.scrollTopMargin ?? 0}px 0px ${props2.scrollBottomMargin ?? 0}px 0px`
  }));
  useIntersectionObserver(intersectionHandler, options, targets);
  return {
    scrollContainer,
    topTrigger,
    bottomTrigger,
    doRenderTopTrigger,
    doRenderBottomTrigger
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/components/VaDataTableThRow.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaDataTableThRow.css";
var _sfc_main45 = defineComponent({
  name: "VaDataTableThRow",
  components: { VaIcon, VaCheckbox },
  props: {
    ...useStylableProps,
    selectMode: { type: String, default: "multiple" },
    allRowsSelected: { type: Boolean, default: false },
    severalRowsSelected: { type: Boolean, default: false },
    columns: { type: Array, required: true },
    isFooter: { type: Boolean, default: false },
    sortBySync: { type: String, required: true },
    sortingOrderIconName: { type: String, required: true },
    sortingOrderSync: { type: String, default: null },
    ariaSelectAllRowsLabel: { type: String, default: "$t:selectAllRows" },
    ariaSortColumnByLabel: { type: String, default: "$t:sortColumnBy" }
  },
  emits: [
    "toggleBulkSelection",
    "toggleSorting"
  ],
  setup(props2, { emit }) {
    const { t: t2, tp } = useTranslation();
    const {
      getFooterCSSVariables,
      getHeaderCSSVariables,
      getClass: getClass2,
      getStyle: getStyle2
    } = useStylable(props2);
    const getAriaAttributes = (column) => {
      const ariaSort = props2.sortingOrderSync && props2.sortBySync === column.name ? props2.sortingOrderSync === "asc" ? "ascending" : "descending" : "none";
      const ariaLabel = column.sortable ? tp(props2.ariaSortColumnByLabel, { name: column.label }) : void 0;
      return {
        "aria-sort": ariaSort,
        "aria-label": ariaLabel
      };
    };
    const sortByColumn = (column) => {
      if (props2.isFooter && !props2.allowFooterSorting || !column.sortable) {
        return;
      }
      emit("toggleSorting", column);
    };
    const toggleBulkSelection = () => emit("toggleBulkSelection");
    const getColumnStyles = (column) => {
      return [
        column.width ? { minWidth: column.width, maxWidth: column.width } : {},
        props2.isFooter ? getFooterCSSVariables(column) : getHeaderCSSVariables(column),
        getStyle2(column.thStyle)
      ];
    };
    const slotNameComputed = computed(() => props2.isFooter ? "footer" : "header");
    const multiplySelectAvailable = computed(() => props2.selectMode === "multiple");
    return {
      tp,
      getClass: getClass2,
      sortByColumn,
      getColumnStyles,
      slotNameComputed,
      getAriaAttributes,
      toggleBulkSelection,
      multiplySelectAvailable
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/components/VaDataTableThRow.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaDataTableThRow.css";
var _hoisted_125 = { class: "va-data-table__table-tr" };
var _hoisted_212 = {
  key: 0,
  scope: "col",
  class: "va-data-table__table-th va-data-table__table-cell-select"
};
var _hoisted_37 = ["title", "onClick", "onKeydown"];
var _hoisted_46 = { class: "va-data-table__table-th-wrapper" };
var _hoisted_55 = { key: 0 };
function _sfc_render42(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_checkbox = resolveComponent("va-checkbox");
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("tr", _hoisted_125, [
    _ctx.$props.selectable ? (openBlock(), createElementBlock("th", _hoisted_212, [
      _ctx.multiplySelectAvailable ? (openBlock(), createBlock(_component_va_checkbox, {
        key: 0,
        class: "va-data-table__table-cell-checkbox",
        "model-value": _ctx.$props.severalRowsSelected ? "idl" : _ctx.$props.allRowsSelected,
        "aria-label": _ctx.tp(_ctx.$props.ariaSelectAllRowsLabel),
        "true-value": true,
        "false-value": false,
        color: _ctx.$props.selectedColor,
        "indeterminate-value": "idl",
        indeterminate: "",
        "onUpdate:modelValue": _ctx.toggleBulkSelection
      }, null, 8, ["model-value", "aria-label", "color", "onUpdate:modelValue"])) : createCommentVNode("", true)
    ])) : createCommentVNode("", true),
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.columns, (column) => {
      return openBlock(), createElementBlock("th", mergeProps({
        key: column.name,
        scope: "col",
        class: ["va-data-table__table-th", _ctx.getClass(column.thClass)],
        title: column.thTitle,
        style: _ctx.getColumnStyles(column)
      }, _ctx.getAriaAttributes(column), {
        onClick: withModifiers(($event) => _ctx.sortByColumn(column), ["exact"]),
        onKeydown: withKeys(withModifiers(($event) => _ctx.sortByColumn(column), ["stop"]), ["enter"])
      }), [
        createBaseVNode("div", _hoisted_46, [
          `${_ctx.slotNameComputed}(${column.name})` in _ctx.$slots ? (openBlock(), createElementBlock("span", _hoisted_55, [
            renderSlot(_ctx.$slots, `${_ctx.slotNameComputed}(${column.name})`, normalizeProps(guardReactiveProps({ label: column.label, key: column.key })))
          ])) : renderSlot(_ctx.$slots, _ctx.slotNameComputed, normalizeProps(mergeProps({ key: 1 }, { label: column.label, key: column.key })), () => [
            createBaseVNode("span", null, toDisplayString(column.label), 1)
          ]),
          column.sortable ? (openBlock(), createBlock(_component_va_icon, {
            key: 2,
            class: normalizeClass(["va-data-table__table-th-sorting-icon", { active: _ctx.sortBySync === column.name && _ctx.sortingOrderSync !== null }]),
            size: "small",
            role: column.sortable ? "button" : void 0,
            tabindex: column.sortable ? 0 : -1,
            name: _ctx.sortingOrderIconName,
            onSelectstart: withModifiers(() => {
            }, ["prevent"])
          }, null, 8, ["class", "role", "tabindex", "name"])) : createCommentVNode("", true)
        ])
      ], 16, _hoisted_37);
    }), 128))
  ]);
}
var _VaDataTableThRow = _export_sfc(_sfc_main45, [["render", _sfc_render42]]);

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/components/index.js
var VaDataTableThRow = withConfigTransport$1(_VaDataTableThRow);

// node_modules/vuestic-ui/dist/es/src/components/va-virtual-scroller/useVirtualScrollerSizes.js
var { isParsablePositiveMeasure, parseSizeValue: parseSizeValue2 } = useParsableMeasure();
var validateSizeProp = (v2, propName) => {
  const isProperValue = isParsablePositiveMeasure(v2);
  !isProperValue && warn(`[va-virtual-scroller] ${propName} should be number or parsable int greater or equal to 0. Provided: ${v2}.`);
  return isProperValue;
};
var useVirtualScrollerSizesProps = {
  horizontal: { type: Boolean, default: false },
  itemSize: {
    type: [Number, String],
    default: 0,
    validator: (v2) => {
      return validateSizeProp(v2, "itemSize");
    }
  },
  wrapperSize: {
    type: [Number, String],
    default: 100,
    validator: (v2) => {
      return v2 === "auto" || validateSizeProp(v2, "wrapperSize");
    }
  }
};
var useVirtualScrollerSizes = (props2, scrollPosition) => {
  const list = shallowRef();
  const wrapper = shallowRef();
  const clientSizeMeasure = computed(() => props2.horizontal ? "clientWidth" : "clientHeight");
  const wrapperSize = computed(() => {
    var _a2;
    if (props2.wrapperSize === "auto") {
      return ((_a2 = wrapper.value) == null ? void 0 : _a2[clientSizeMeasure.value]) || 0;
    }
    return parseSizeValue2(props2.wrapperSize, pageFontSize);
  });
  const pageFontSize = ref(16);
  const handleWindowResize = () => {
    pageFontSize.value = parseFloat(getComputedStyle(document.documentElement).fontSize);
    calcAverageItemsSize();
  };
  useEvent("resize", handleWindowResize, true);
  const itemSizeCalculated = ref(0);
  const calcAverageItemsSize = () => {
    if (!list.value) {
      return;
    }
    const sizes = [];
    const itemsList = list.value.children;
    const itemsAmount = itemsList.length;
    for (let i2 = 0; i2 < itemsAmount; i2++) {
      const currentChild = list.value.children.item(i2);
      currentChild && sizes.push(currentChild[clientSizeMeasure.value]);
    }
    itemSizeCalculated.value = itemsAmount ? Math.trunc(sizes.reduce((acc, el) => acc + el, 0) / (itemsAmount - 1)) : 0;
  };
  const instance = getCurrentInstance();
  onMounted(() => {
    var _a2, _b;
    if (!list.value) {
      list.value = (_b = (_a2 = instance == null ? void 0 : instance.parent) == null ? void 0 : _a2.refs) == null ? void 0 : _b.list;
    }
    calcAverageItemsSize();
  });
  watch(scrollPosition, calcAverageItemsSize);
  watch(wrapperSize, calcAverageItemsSize);
  let oldItemSize = 0;
  const itemSize = computed(() => {
    const sizeParsed = parseSizeValue2(props2.itemSize, pageFontSize);
    const result = Math.max(sizeParsed, itemSizeCalculated.value, 1);
    const diff = Math.abs(oldItemSize / result * 100 - 100);
    if (diff > 5 || oldItemSize === 0) {
      oldItemSize = result;
      return result;
    }
    return oldItemSize;
  });
  return { list, wrapper, itemSize, wrapperSize };
};

// node_modules/vuestic-ui/dist/es/src/composables/useTrackBy.js
var useTrackByProps = {
  trackBy: {
    type: [String, Number, Function],
    default: ""
  }
};
var useTrackBy = (props2) => {
  const getKey = (item, index, defaultValue) => {
    if (props2.trackBy && item && typeof item === "object" && !isFunction$4(props2.trackBy)) {
      const isArrayItem = Array.isArray(item);
      let key;
      if (isArrayItem && !isNaN(+props2.trackBy)) {
        key = item[+props2.trackBy];
      }
      if (!isArrayItem) {
        key = item[props2.trackBy];
      }
      if (key || key === 0) {
        return key;
      }
      warn(`${isArrayItem ? "Index" : "Key"} '${props2.trackBy}' wasn't found in provided ${isArrayItem ? "array" : "object"}: `, item);
    }
    if (isFunction$4(props2.trackBy)) {
      return props2.trackBy(item);
    }
    return defaultValue;
  };
  return { getKey };
};

// node_modules/vuestic-ui/dist/es/src/components/va-virtual-scroller/VaVirtualScroller.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaVirtualScroller.css";
var _sfc_main46 = defineComponent({
  name: "VaVirtualScroller",
  props: {
    ...useTrackByProps,
    ...useVirtualScrollerSizesProps,
    items: { type: Array, default: () => [] },
    bench: { type: Number, default: 10, validator: (v2) => v2 >= 0 },
    disabled: { type: Boolean, default: false },
    table: { type: Boolean, default: false }
  },
  emits: ["scroll:bottom"],
  setup: (props2, { emit }) => {
    const listScrollPosition = ref(0);
    const scrollDirection = computed(() => props2.horizontal ? "scrollLeft" : "scrollTop");
    const handleScroll = () => {
      if (!wrapper.value) {
        return;
      }
      listScrollPosition.value = wrapper.value[scrollDirection.value];
    };
    if (!props2.disabled) {
      useEvent("scroll", handleScroll, true);
    }
    const { list, wrapper, itemSize, wrapperSize } = useVirtualScrollerSizes(props2, listScrollPosition);
    const { getKey } = useTrackBy(props2);
    const uniqueKey = (item, index, defaultValue) => getKey(item, index, defaultValue);
    watch(listScrollPosition, (newValue) => {
      if (newValue + wrapperSize.value === containerSize.value) {
        emit("scroll:bottom");
      }
    });
    const renderStartIndex = computed(() => {
      return Math.max(0, Math.floor(listScrollPosition.value / itemSize.value) - props2.bench);
    });
    const renderItemsAmount = computed(() => {
      var _a2;
      if (!((_a2 = props2.items) == null ? void 0 : _a2.length)) {
        return 0;
      }
      return props2.disabled ? props2.items.length : Math.min(props2.items.length - renderStartIndex.value, Math.ceil(wrapperSize.value / itemSize.value) + props2.bench * 2);
    });
    const renderEndIndex = computed(() => renderStartIndex.value + renderItemsAmount.value);
    const renderBuffer = computed(() => {
      var _a2;
      if (!((_a2 = props2.items) == null ? void 0 : _a2.length)) {
        return [];
      }
      return props2.items.slice(renderStartIndex.value, renderEndIndex.value);
    });
    const sizeAttribute = computed(() => props2.horizontal ? "width" : "height");
    const isDisabledVirtualTable = computed(() => props2.table && props2.disabled);
    const wrapperStyleComputed = computed(() => ({
      [sizeAttribute.value]: isDisabledVirtualTable.value || !wrapperSize.value ? void 0 : `${wrapperSize.value}px`
    }));
    const wrapperClassComputed = useBem("va-virtual-scroller", () => ({
      ...pick$1(props2, ["horizontal"])
    }));
    const containerSize = computed(() => {
      var _a2;
      return (((_a2 = props2.items) == null ? void 0 : _a2.length) ?? 0) * itemSize.value;
    });
    const containerStyleComputed = computed(() => ({
      [sizeAttribute.value]: isDisabledVirtualTable.value ? void 0 : `${containerSize.value}px`
    }));
    const currentListOffset = computed(() => renderStartIndex.value * itemSize.value);
    const listStyleComputed = computed(() => ({
      transform: `translate${props2.horizontal ? "X" : "Y"}(${currentListOffset.value}px)`
    }));
    const scrollToAttribute = computed(() => props2.horizontal ? "left" : "top");
    const virtualScrollTo = (index) => {
      var _a2;
      if (!index && index !== 0) {
        return;
      }
      (_a2 = wrapper.value) == null ? void 0 : _a2.scrollTo({ [scrollToAttribute.value]: index * itemSize.value });
    };
    return {
      containerStyleComputed,
      wrapperStyleComputed,
      wrapperClassComputed,
      listStyleComputed,
      currentListOffset,
      renderStartIndex,
      virtualScrollTo,
      renderBuffer,
      uniqueKey,
      wrapper,
      list
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-virtual-scroller/VaVirtualScroller.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaVirtualScroller.css";
function _sfc_render43(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(["va-virtual-scroller", _ctx.wrapperClassComputed]),
    style: normalizeStyle(_ctx.wrapperStyleComputed)
  }, [
    renderSlot(_ctx.$slots, "content", normalizeProps(guardReactiveProps({ containerStyleComputed: _ctx.containerStyleComputed, listStyleComputed: _ctx.listStyleComputed, renderBuffer: _ctx.renderBuffer, uniqueKey: _ctx.uniqueKey, currentListOffset: _ctx.currentListOffset })), () => [
      createBaseVNode("div", {
        class: "va-virtual-scroller__container",
        style: normalizeStyle(_ctx.containerStyleComputed)
      }, [
        createBaseVNode("div", {
          ref: "list",
          role: "list",
          class: "va-virtual-scroller__list",
          style: normalizeStyle(_ctx.listStyleComputed)
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.renderBuffer, (item, index) => {
            return renderSlot(_ctx.$slots, "default", normalizeProps(mergeProps({
              key: _ctx.uniqueKey(item, index)
            }, { item, index: _ctx.renderStartIndex + index })));
          }), 128))
        ], 4)
      ], 4)
    ])
  ], 6);
}
var _VaVirtualScroller = _export_sfc(_sfc_main46, [["render", _sfc_render43]]);

// node_modules/vuestic-ui/dist/es/src/components/va-virtual-scroller/index.js
var VaVirtualScroller = withConfigTransport$1(_VaVirtualScroller);

// node_modules/vuestic-ui/dist/es/src/components/va-inner-loading/VaInnerLoading.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaInnerLoading.css";
var _sfc_main47 = defineComponent({
  name: "VaInnerLoading",
  components: { VaIcon },
  props: {
    ...useLoadingProps,
    ...useComponentPresetProp,
    color: { type: String },
    icon: { type: String, default: "va-loading" },
    size: { type: Number, default: 30 }
  },
  setup(props2) {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props2.color));
    return {
      colorComputed,
      computedClass: computed(() => ({
        "va-inner-loading--active": props2.loading
      })),
      ariaAttributesComputed: computed(() => ({
        "aria-busy": props2.loading
      }))
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-inner-loading/VaInnerLoading.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaInnerLoading.css";
var _hoisted_126 = {
  key: 0,
  class: "va-inner-loading__overlay",
  "aria-hidden": "true"
};
function _sfc_render44(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", mergeProps({
    class: ["va-inner-loading", _ctx.computedClass],
    "aria-live": "polite"
  }, _ctx.ariaAttributesComputed), [
    renderSlot(_ctx.$slots, "default"),
    _ctx.$props.loading ? (openBlock(), createElementBlock("div", _hoisted_126, [
      renderSlot(_ctx.$slots, "loading", {}, () => [
        createVNode(_component_va_icon, {
          class: "va-inner-loading__spinner",
          spin: "counter-clockwise",
          color: _ctx.colorComputed,
          size: _ctx.$props.size,
          name: _ctx.$props.icon
        }, null, 8, ["color", "size", "name"])
      ])
    ])) : createCommentVNode("", true)
  ], 16);
}
var _VaInnerLoading = _export_sfc(_sfc_main47, [["render", _sfc_render44]]);

// node_modules/vuestic-ui/dist/es/src/components/va-inner-loading/index.js
var VaInnerLoading = withConfigTransport$1(_VaInnerLoading);

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/VaDataTable.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaDataTable.css";
var VaVirtualScrollerProps = extractComponentProps(VaVirtualScroller, ["items", "trackBy", "horizontal", "disabled", "table"]);
var VaDataTableThRowProps = extractComponentProps(VaDataTableThRow);
var _sfc_main48 = defineComponent({
  name: "VaDataTable",
  components: {
    VaDataTableThRow,
    VaVirtualScroller,
    VaInnerLoading,
    VaCheckbox
  },
  inheritAttrs: false,
  props: {
    ...useComponentPresetProp,
    ...VaVirtualScrollerProps,
    ...useAnimationNameProps,
    ...useBindingProps,
    ...useTableScrollProps,
    ...useSortableProps,
    ...useStylableProps,
    ...useColumnsProps,
    ...useFilterableProps,
    ...usePaginatedRowsProps,
    ...useRowsProps,
    ...useSelectableProps2,
    ...useThrottleProps,
    ...pick$1(VaDataTableThRowProps, ["ariaSelectAllRowsLabel", "ariaSortColumnByLabel"]),
    hoverable: { type: Boolean, default: false },
    clickable: { type: Boolean, default: false },
    loading: { type: Boolean, default: false },
    loadingColor: { type: String, default: "primary" },
    noDataHtml: { type: String, default: "No items" },
    noDataFilteredHtml: { type: String, default: "No items match the provided filtering condition" },
    hideDefaultHeader: { type: Boolean, default: false },
    footerClone: { type: Boolean, default: false },
    striped: { type: Boolean, default: false },
    virtualScroller: { type: Boolean, default: false },
    virtualTrackBy: { type: [String, Number], default: "initialIndex" },
    grid: { type: Boolean, default: false },
    gridColumns: { type: Number, default: 0 },
    wrapperSize: { type: [Number, String], default: "auto" },
    ariaSelectRowLabel: { type: String, default: "$t:selectRowByIndex" }
  },
  emits: [
    "update:modelValue",
    // `modelValue` is selectedItems
    "update:sortBy",
    "update:sortingOrder",
    "filtered",
    "sorted",
    "selectionChange",
    "row:click",
    "row:dblclick",
    "row:contextmenu",
    "columnSorted",
    ...useTableScrollEmits
  ],
  setup(props2, { attrs, emit }) {
    const { columnsComputed } = useColumns(props2);
    const { rowsComputed } = useRows(columnsComputed, props2);
    const { filteredRows } = useFilterable(rowsComputed, props2, emit);
    const {
      sortBySync,
      sortingOrderSync,
      toggleSorting,
      sortedRows,
      sortingOrderIconName
    } = useSortable(columnsComputed, filteredRows, props2, emit);
    const { paginatedRows } = usePaginatedRows(sortedRows, props2);
    const {
      ctrlSelectRow,
      shiftSelectRows,
      toggleBulkSelection,
      isRowSelected,
      severalRowsSelected,
      allRowsSelected,
      toggleRowSelection
    } = useSelectableRow(paginatedRows, props2, emit);
    const {
      CSSVariables,
      getCellCSSVariables,
      getClass: getClass2,
      getStyle: getStyle2
    } = useStylable(props2);
    const { getRowBind, getCellBind } = useBinding(props2);
    const animationName = useAnimationName(props2, paginatedRows);
    const showNoDataHtml = computed(() => props2.items.length === 0);
    const showNoDataFilteredHtml = computed(() => paginatedRows.value.length === 0);
    const onRowClickHandler = (name, event, row) => {
      emit(name, {
        event,
        item: row.source,
        itemIndex: row.initialIndex,
        row
      });
      if (props2.selectable && props2.grid) {
        toggleRowSelection(row);
      }
    };
    const computedTableAttributes = computed(() => ({
      ...omit$1(attrs, ["class", "style"]),
      class: pick$1(props2, ["striped", "selectable", "hoverable", "clickable"])
    }));
    const filteredVirtualScrollerProps = filterComponentProps(VaVirtualScrollerProps);
    const virtualScrollerPropsComputed = computed(() => ({
      ...filteredVirtualScrollerProps.value,
      items: paginatedRows.value,
      trackBy: props2.virtualTrackBy,
      disabled: !props2.virtualScroller,
      table: true
    }));
    const computedAttributes = computed(() => ({
      class: [
        { "va-data-table--sticky": props2.stickyHeader || props2.stickyFooter },
        { "va-data-table--scroll": !!props2.height },
        { "va-data-table--virtual-scroller": isVirtualScroll.value },
        { "va-data-table--grid": props2.grid },
        attrs.class
      ],
      style: [attrs.style],
      ...virtualScrollerPropsComputed.value
    }));
    const filteredThProps = filterComponentProps(VaDataTableThRowProps);
    const thAttributesComputed = computed(() => ({
      ...filteredThProps.value,
      columns: columnsComputed.value,
      sortingOrderIconName: sortingOrderIconName.value,
      severalRowsSelected: severalRowsSelected.value,
      sortingOrderSync: sortingOrderSync.value,
      allRowsSelected: allRowsSelected.value,
      sortBySync: sortBySync.value
    }));
    const {
      scrollContainer,
      topTrigger,
      bottomTrigger,
      doRenderTopTrigger,
      doRenderBottomTrigger
    } = useTableScroll(props2, emit);
    const isVirtualScroll = computed(() => props2.virtualScroller && !props2.grid);
    const gridColumnsCount = computed(() => props2.gridColumns || "var(--va-data-table-grid-tbody-columns)");
    return {
      ...useTranslation(),
      scrollContainer,
      topTrigger,
      bottomTrigger,
      columnsComputed,
      ctrlSelectRow,
      shiftSelectRows,
      toggleBulkSelection,
      isRowSelected,
      toggleSorting,
      CSSVariables,
      getCellCSSVariables,
      getClass: getClass2,
      getStyle: getStyle2,
      thAttributesComputed,
      showNoDataHtml,
      showNoDataFilteredHtml,
      onRowClickHandler,
      computedAttributes,
      computedTableAttributes,
      animationName,
      getRowBind,
      getCellBind,
      doRenderTopTrigger,
      doRenderBottomTrigger,
      isVirtualScroll,
      gridColumnsCount
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/VaDataTable.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaDataTable.css";
var _hoisted_127 = {
  key: 0,
  ref: "topTrigger",
  class: "va-data-table__scroll-trigger"
};
var _hoisted_213 = { key: 0 };
var _hoisted_38 = {
  ref: "list",
  class: "va-data-table__table-tbody"
};
var _hoisted_47 = {
  key: "showNoDataHtml",
  class: "va-data-table__table-tr"
};
var _hoisted_56 = ["colspan", "innerHTML"];
var _hoisted_65 = {
  key: "showNoDataFilteredHtml",
  class: "va-data-table__table-tr"
};
var _hoisted_73 = ["colspan", "innerHTML"];
var _hoisted_82 = ["onClick", "onDblclick", "onContextmenu"];
var _hoisted_9 = {
  key: 0,
  class: "va-data-table__grid-column-header"
};
var _hoisted_10 = {
  key: 0,
  class: "va-data-table__table-expanded-content",
  colspan: "99999"
};
var _hoisted_11 = {
  key: 1,
  ref: "bottomTrigger",
  class: "va-data-table__scroll-trigger"
};
function _sfc_render45(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_data_table_th_row = resolveComponent("va-data-table-th-row");
  const _component_va_checkbox = resolveComponent("va-checkbox");
  const _component_va_inner_loading = resolveComponent("va-inner-loading");
  const _component_va_virtual_scroller = resolveComponent("va-virtual-scroller");
  return openBlock(), createBlock(_component_va_virtual_scroller, mergeProps({ class: "va-data-table" }, _ctx.computedAttributes, {
    ref: "scrollContainer",
    style: `--va-css-variables-selected-color: ${String(_ctx.CSSVariables.selectedColor)};--va-css-variables-hover-color: ${String(_ctx.CSSVariables.hoverColor)};--va-css-variables-table-height: ${String(_ctx.CSSVariables.tableHeight)};--va-css-variables-thead-bg: ${String(_ctx.CSSVariables.theadBg)};--va-css-variables-tfoot-bg: ${String(_ctx.CSSVariables.tfootBg)};--va-grid-columns-count: ${String(_ctx.gridColumnsCount)}`
  }), {
    content: withCtx(({
      uniqueKey,
      renderBuffer,
      currentListOffset,
      listStyleComputed,
      containerStyleComputed
    }) => [
      createVNode(_component_va_inner_loading, {
        "aria-live": "polite",
        style: normalizeStyle(containerStyleComputed),
        loading: _ctx.loading,
        color: _ctx.loadingColor
      }, {
        default: withCtx(() => [
          _ctx.doRenderTopTrigger ? (openBlock(), createElementBlock("div", _hoisted_127, null, 512)) : createCommentVNode("", true),
          createBaseVNode("table", mergeProps({
            class: "va-data-table__table",
            style: listStyleComputed
          }, _ctx.computedTableAttributes), [
            "colgroup" in _ctx.$slots ? (openBlock(), createElementBlock("colgroup", _hoisted_213, [
              renderSlot(_ctx.$slots, "colgroup", normalizeProps(guardReactiveProps(_ctx.columnsComputed)))
            ])) : createCommentVNode("", true),
            createBaseVNode("thead", {
              class: normalizeClass(["va-data-table__table-thead", { "va-data-table__table-thead--sticky": _ctx.$props.stickyHeader }]),
              style: normalizeStyle({ top: _ctx.isVirtualScroll && _ctx.$props.stickyHeader ? `-${currentListOffset}px` : void 0 })
            }, [
              renderSlot(_ctx.$slots, "headerPrepend"),
              renderSlot(_ctx.$slots, "header", {}, () => [
                !_ctx.hideDefaultHeader ? (openBlock(), createBlock(_component_va_data_table_th_row, mergeProps({ key: 0 }, _ctx.thAttributesComputed, {
                  onToggleBulkSelection: _ctx.toggleBulkSelection,
                  onToggleSorting: _ctx.toggleSorting
                }), createSlots({ _: 2 }, [
                  renderList(_ctx.$slots, (_2, slot) => {
                    return {
                      name: slot,
                      fn: withCtx((scope) => [
                        renderSlot(_ctx.$slots, slot, normalizeProps(guardReactiveProps(scope)))
                      ])
                    };
                  })
                ]), 1040, ["onToggleBulkSelection", "onToggleSorting"])) : createCommentVNode("", true)
              ]),
              renderSlot(_ctx.$slots, "headerAppend")
            ], 6),
            createBaseVNode("tbody", _hoisted_38, [
              renderSlot(_ctx.$slots, "bodyPrepend"),
              createVNode(TransitionGroup, {
                name: _ctx.isVirtualScroll ? "" : _ctx.animationName,
                css: !_ctx.$props.virtualScroller,
                appear: !_ctx.$props.virtualScroller
              }, {
                default: withCtx(() => [
                  _ctx.showNoDataHtml ? (openBlock(), createElementBlock("tr", _hoisted_47, [
                    createBaseVNode("td", {
                      class: "va-data-table__table-td no-data",
                      colspan: _ctx.columnsComputed.length + (_ctx.selectable ? 1 : 0),
                      innerHTML: _ctx.noDataHtml
                    }, null, 8, _hoisted_56)
                  ])) : _ctx.showNoDataFilteredHtml ? (openBlock(), createElementBlock("tr", _hoisted_65, [
                    createBaseVNode("td", {
                      class: "va-data-table__table-td no-data",
                      colspan: _ctx.columnsComputed.length + (_ctx.selectable ? 1 : 0),
                      innerHTML: _ctx.noDataFilteredHtml
                    }, null, 8, _hoisted_73)
                  ])) : createCommentVNode("", true),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(renderBuffer, (row, index) => {
                    return openBlock(), createElementBlock(Fragment, {
                      key: `table-row_${uniqueKey(row, index)}`
                    }, [
                      createBaseVNode("tr", mergeProps({
                        class: ["va-data-table__table-tr", [{ selected: _ctx.isRowSelected(row), "va-data-table__table-tr--expanded": row.isExpandableRowVisible }]]
                      }, _ctx.getRowBind(row), {
                        onClick: ($event) => _ctx.onRowClickHandler("row:click", $event, row),
                        onDblclick: ($event) => _ctx.onRowClickHandler("row:dblclick", $event, row),
                        onContextmenu: ($event) => _ctx.onRowClickHandler("row:contextmenu", $event, row)
                      }), [
                        _ctx.selectable && !_ctx.$props.grid ? (openBlock(), createElementBlock("td", {
                          class: "va-data-table__table-td va-data-table__table-cell-select",
                          key: `selectable_${uniqueKey(row, index)}`,
                          onSelectstart: _cache[0] || (_cache[0] = withModifiers(() => {
                          }, ["prevent"]))
                        }, [
                          createVNode(_component_va_checkbox, {
                            class: "va-data-table__table-cell-checkbox",
                            "model-value": _ctx.isRowSelected(row),
                            color: _ctx.selectedColor,
                            "aria-label": _ctx.tp(_ctx.$props.ariaSelectRowLabel, { index: row.initialIndex }),
                            onClick: [
                              withModifiers(($event) => _ctx.shiftSelectRows(row), ["shift", "exact", "stop"]),
                              withModifiers(($event) => _ctx.ctrlSelectRow(row), ["ctrl", "exact", "stop"]),
                              withModifiers(($event) => _ctx.ctrlSelectRow(row), ["exact", "stop"])
                            ]
                          }, null, 8, ["model-value", "color", "aria-label", "onClick"])
                        ], 32)) : createCommentVNode("", true),
                        (openBlock(true), createElementBlock(Fragment, null, renderList(row.cells, (cell, cellIndex) => {
                          return openBlock(), createElementBlock("td", mergeProps({
                            key: `table-cell_${cell.column.name + cell.rowIndex}`,
                            class: ["va-data-table__table-td", _ctx.getClass(cell.column.tdClass)],
                            style: [
                              cell.column.width ? { minWidth: cell.column.width, maxWidth: cell.column.width } : {},
                              _ctx.getCellCSSVariables(cell),
                              _ctx.getStyle(cell.column.tdStyle)
                            ]
                          }, _ctx.getCellBind(cell, row)), [
                            `cell(${cell.column.name})` in _ctx.$slots ? renderSlot(_ctx.$slots, `cell(${cell.column.name})`, normalizeProps(mergeProps({ key: 0 }, { ...cell, row, isExpanded: row.isExpandableRowVisible }))) : renderSlot(_ctx.$slots, "cell", normalizeProps(mergeProps({ key: 1 }, { cell, row })), () => [
                              _ctx.$props.grid ? (openBlock(), createElementBlock("span", _hoisted_9, toDisplayString(_ctx.columnsComputed[cellIndex].label), 1)) : createCommentVNode("", true),
                              createTextVNode(" " + toDisplayString(cell.value), 1)
                            ])
                          ], 16);
                        }), 128))
                      ], 16, _hoisted_82),
                      row.isExpandableRowVisible ? (openBlock(), createElementBlock("td", _hoisted_10, [
                        renderSlot(_ctx.$slots, "expandableRow", normalizeProps(guardReactiveProps(row)))
                      ])) : createCommentVNode("", true)
                    ], 64);
                  }), 128))
                ]),
                _: 2
              }, 1032, ["name", "css", "appear"]),
              renderSlot(_ctx.$slots, "bodyAppend")
            ], 512),
            _ctx.$slots.footer || _ctx.footerClone && !_ctx.$props.grid ? (openBlock(), createElementBlock("tfoot", {
              key: 1,
              class: normalizeClass(["va-data-table__table-tfoot", { "va-data-table__table-tfoot--sticky": _ctx.$props.stickyFooter }]),
              style: normalizeStyle({ bottom: _ctx.isVirtualScroll && _ctx.$props.stickyFooter ? `${currentListOffset}px` : void 0 })
            }, [
              renderSlot(_ctx.$slots, "footerPrepend"),
              renderSlot(_ctx.$slots, "footer", {}, () => [
                !_ctx.hideDefaultHeader ? (openBlock(), createBlock(_component_va_data_table_th_row, mergeProps({ key: 0 }, _ctx.thAttributesComputed, {
                  "is-footer": "",
                  onToggleBulkSelection: _ctx.toggleBulkSelection,
                  onToggleSorting: _ctx.toggleSorting
                }), createSlots({ _: 2 }, [
                  renderList(_ctx.$slots, (_2, slot) => {
                    return {
                      name: slot,
                      fn: withCtx((scope) => [
                        renderSlot(_ctx.$slots, slot, normalizeProps(guardReactiveProps(scope)))
                      ])
                    };
                  })
                ]), 1040, ["onToggleBulkSelection", "onToggleSorting"])) : createCommentVNode("", true)
              ]),
              renderSlot(_ctx.$slots, "footerAppend")
            ], 6)) : createCommentVNode("", true)
          ], 16),
          _ctx.doRenderBottomTrigger ? (openBlock(), createElementBlock("div", _hoisted_11, null, 512)) : createCommentVNode("", true)
        ]),
        _: 2
      }, 1032, ["style", "loading", "color"])
    ]),
    _: 3
  }, 16, ["style"]);
}
var _VaDataTable = _export_sfc(_sfc_main48, [["render", _sfc_render45]]);

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/index.js
var VaDataTable = withConfigTransport$1(_VaDataTable);

// node_modules/vuestic-ui/dist/es/src/components/va-date-input/hooks/input-text-parser.js
var defaultParseDateFunction = (text) => new Date(Date.parse(text));
var isValidDate = (d2) => isDate$1(d2) && !isNaN(d2.getTime());
var useDateParser = (props2) => {
  const isMultipleDates = (text) => text.includes(props2.delimiter);
  const isRange3 = (text) => text.includes(props2.rangeDelimiter);
  const isValid = ref(true);
  const parseDate = (text) => {
    const splitDate = text.split(".");
    const valueToParse = (splitDate == null ? void 0 : splitDate.length) === 3 ? splitDate.reverse().join("-") : text;
    const date = (props2.parseDate || defaultParseDateFunction)(valueToParse);
    isValid.value = isValidDate(date);
    return date;
  };
  const parseDateInputValue = (text) => {
    isValid.value = true;
    if (props2.parse) {
      return props2.parse(text, isValid);
    }
    if (isMultipleDates(text)) {
      return text.split(props2.delimiter).map(parseDate);
    }
    if (isRange3(text)) {
      const [start, end] = text.split(props2.rangeDelimiter).map(parseDate);
      return { start, end };
    }
    return parseDate(text);
  };
  return {
    parseDateInputValue,
    isValid
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-input/hooks/model-value-parser.js
var isRange = (date) => {
  if (date === null) {
    return false;
  }
  return typeof date === "object" && ("start" in date || "end" in date);
};
var parseSingleDate = (date) => typeof date === "string" ? defaultParseDateFunction(date) : new Date(date);
var parseModelValue = (date) => {
  if (Array.isArray(date)) {
    return date.map(parseSingleDate);
  }
  if (isRange(date)) {
    return {
      start: isNil$1(date.start) ? date.start : parseSingleDate(date.start),
      end: isNil$1(date.end) ? date.end : parseSingleDate(date.end)
    };
  }
  return parseSingleDate(date);
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-input/hooks/range-model-value-guard.js
var useRangeModelValueGuard = (modelValue, disabled, parseValue = parseModelValue) => {
  const bufferValue = ref(modelValue.value && parseValue(modelValue.value));
  const valueComputed = computed({
    get: () => bufferValue.value,
    set: (value) => {
      if (disabled.value) {
        modelValue.value = value;
      }
      if (!value) {
        modelValue.value = value;
        return;
      }
      if (isRange(value)) {
        if (value.end !== null) {
          modelValue.value = value;
        }
      } else {
        modelValue.value = value;
      }
      bufferValue.value = value;
    }
  });
  watch(modelValue, (newValue) => {
    bufferValue.value = newValue;
  });
  const reset = () => {
    if (bufferValue.value && isRange(bufferValue.value)) {
      bufferValue.value = modelValue.value && parseValue(modelValue.value);
    }
  };
  return {
    valueComputed,
    reset
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/utils/date-utils.js
var isDatesDayEqual = (date1, date2) => (date1 == null ? void 0 : date1.toDateString()) === (date2 == null ? void 0 : date2.toDateString());
var isDatesYearEqual = (date1, date2) => {
  return (date1 == null ? void 0 : date1.getFullYear()) === (date2 == null ? void 0 : date2.getFullYear());
};
var isDatesMonthEqual = (date1, date2) => {
  return isDatesYearEqual(date1, date2) && (date1 == null ? void 0 : date1.getMonth()) === (date2 == null ? void 0 : date2.getMonth());
};
var createYearDate = (year) => {
  const date = /* @__PURE__ */ new Date();
  date.setFullYear(year);
  return date;
};
var isRange2 = (value) => {
  if (value === null) {
    return false;
  }
  return typeof value === "object" && ("start" in value || "end" in value);
};
var isSingleDate = (value) => isDate$1(value);
var isDates = (value) => Array.isArray(value);

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/hooks/view.js
var JANUARY_MONTH_INDEX = 0;
var DECEMBER_MONTH_INDEX = 11;
var addMonth = (view) => {
  if (view.month === DECEMBER_MONTH_INDEX) {
    return { ...view, year: view.year + 1, month: JANUARY_MONTH_INDEX };
  } else {
    return { ...view, month: view.month + 1 };
  }
};
var subMonth = (view) => {
  if (view.month === JANUARY_MONTH_INDEX) {
    return { ...view, year: view.year - 1, month: DECEMBER_MONTH_INDEX };
  } else {
    return { ...view, month: view.month - 1 };
  }
};
var getDefaultDate = (modelValue) => {
  if (isDate$1(modelValue)) {
    return modelValue;
  }
  if (isDate$1(modelValue == null ? void 0 : modelValue.start)) {
    return modelValue.start;
  }
  if (Array.isArray(modelValue) && isDate$1(modelValue[0])) {
    return modelValue[0];
  }
  return /* @__PURE__ */ new Date();
};
var useView = (props2, emit, defaultOverride) => {
  const defaultDate = getDefaultDate(props2.modelValue);
  const defaultView = {
    type: "day",
    year: defaultDate.getFullYear(),
    month: defaultDate.getMonth(),
    ...defaultOverride
  };
  const statefulView = ref(defaultView);
  const syncView = computed({
    get() {
      return { ...statefulView.value, ...props2.view };
    },
    set(view) {
      statefulView.value = view;
      emit("update:view", view);
    }
  });
  const next = () => {
    if (syncView.value.type === "day") {
      syncView.value = addMonth(syncView.value);
    } else if (syncView.value.type === "month") {
      syncView.value = { ...syncView.value, year: syncView.value.year + 1 };
    }
  };
  const prev = () => {
    if (syncView.value.type === "day") {
      syncView.value = subMonth(syncView.value);
    } else if (syncView.value.type === "month") {
      syncView.value = { ...syncView.value, year: syncView.value.year - 1 };
    }
  };
  return {
    syncView,
    next,
    prev
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/hooks/grid-keyboard-navigation.js
function isUndefined(t2) {
  return t2 === void 0;
}
var useGridKeyboardNavigation = ({
  rowSize,
  start,
  end,
  onSelected,
  onFocusIndex
}) => {
  const focusedCellIndex = ref(-1);
  let previouslyClicked2 = false;
  const onMousedown = () => {
    previouslyClicked2 = true;
  };
  const onFocus = () => {
    if (previouslyClicked2) {
      return;
    }
    previouslyClicked2 = false;
    const index = onFocusIndex === void 0 ? unref(start) || 0 : unref(onFocusIndex);
    focusedCellIndex.value = index;
  };
  const onBlur = () => {
    previouslyClicked2 = false;
    focusedCellIndex.value = -1;
  };
  const onKeydown = (e2) => {
    if (["ArrowRight", "ArrowLeft", "ArrowDown", "ArrowUp", "Enter", "Space"].includes(e2.key)) {
      e2.preventDefault();
      e2.stopPropagation();
    }
    if (e2.key === "Enter" || e2.key === "Space") {
      if (onSelected === void 0) {
        return;
      }
      onSelected(focusedCellIndex.value);
      return;
    }
    if (e2.key === "ArrowRight") {
      focusedCellIndex.value += 1;
    }
    if (e2.key === "ArrowLeft") {
      focusedCellIndex.value -= 1;
    }
    if (e2.key === "ArrowDown") {
      focusedCellIndex.value += rowSize;
    }
    if (e2.key === "ArrowUp") {
      focusedCellIndex.value -= rowSize;
    }
    if (!isUndefined(start) && focusedCellIndex.value < unref(start)) {
      focusedCellIndex.value = unref(start);
    }
    if (!isUndefined(end) && focusedCellIndex.value > unref(end) - 1) {
      focusedCellIndex.value = unref(end) - 1;
    }
  };
  const containerAttributes = {
    onFocus,
    onKeydown,
    onBlur,
    onMousedown,
    tabindex: 0
  };
  return {
    focusedCellIndex,
    containerAttributes
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/hooks/model-value-helper.js
var modeInitialValue = (date, mode) => {
  if (mode === "single") {
    return date;
  } else if (mode === "range") {
    return { start: date, end: null };
  } else if (mode === "multiple") {
    return [date];
  } else if (mode === "auto") {
    return date;
  }
  throw new Error("Unknown mode");
};
var throwIncorrectModelValueError = (modelValue, mode) => {
  throw Error(`Incorrect modelValue for mode ${mode}. Got ${JSON.stringify(modelValue)}`);
};
var modeFromModelValue = (modelValue) => {
  if (isSingleDate(modelValue)) {
    return "single";
  } else if (isRange2(modelValue)) {
    return "range";
  } else if (isDates(modelValue)) {
    return "multiple";
  }
  return throwIncorrectModelValueError(modelValue, "auto");
};
var sortRange = (modelValue) => {
  if (modelValue.start && modelValue.end) {
    if (modelValue.start > modelValue.end) {
      return { start: modelValue.end, end: modelValue.start };
    }
  }
  return modelValue;
};
var useDatePickerModelValue = (props2, emit, dateEqual) => {
  const updateModelValue = (date) => {
    if (!props2.modelValue) {
      emit("update:modelValue", modeInitialValue(date, props2.mode));
      return;
    }
    const mode = props2.mode === "auto" ? modeFromModelValue(props2.modelValue) : props2.mode;
    if (mode === "single") {
      if (!isSingleDate(props2.modelValue)) {
        return throwIncorrectModelValueError(props2.modelValue, mode);
      }
      emit("update:modelValue", date);
    } else if (mode === "range") {
      if (!isRange2(props2.modelValue)) {
        return throwIncorrectModelValueError(props2.modelValue, mode);
      }
      if (props2.modelValue.end && dateEqual(props2.modelValue.end, date)) {
        return emit("update:modelValue", { start: props2.modelValue.start, end: null });
      }
      if (props2.modelValue.start && dateEqual(props2.modelValue.start, date)) {
        return emit("update:modelValue", { start: null, end: props2.modelValue.end });
      }
      if (props2.modelValue.end === null) {
        return emit("update:modelValue", sortRange({ start: props2.modelValue.start, end: date }));
      }
      if (props2.modelValue.start === null) {
        return emit("update:modelValue", sortRange({ end: props2.modelValue.end, start: date }));
      }
      emit("update:modelValue", { start: date, end: null });
    } else if (mode === "multiple") {
      if (!isDates(props2.modelValue)) {
        return throwIncorrectModelValueError(props2.modelValue, mode);
      }
      const isDatesIncludesDate = !!props2.modelValue.find((d2) => dateEqual(d2, date));
      if (isDatesIncludesDate) {
        emit("update:modelValue", props2.modelValue.filter((d2) => !dateEqual(d2, date)));
      } else {
        emit("update:modelValue", [...props2.modelValue, date].sort((a2, b2) => a2.getTime() - b2.getTime()));
      }
    }
  };
  return {
    updateModelValue
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/hooks/use-picker.js
var getDateEqualFunction = (type) => {
  return {
    month: isDatesMonthEqual,
    day: isDatesDayEqual,
    year: isDatesYearEqual
  }[type];
};
var useDatePicker = (type, dates, props2, emit) => {
  const datesEqual = getDateEqualFunction(type);
  const isAllowedDate = props2.allowedDays || props2.allowedMonths || props2.allowedYears;
  const isDateDisabled = (date) => isAllowedDate === void 0 ? false : !isAllowedDate(date);
  const hoveredIndex = ref(-1);
  const hoveredValue = computed(() => dates.value[hoveredIndex.value]);
  const { updateModelValue } = useDatePickerModelValue(
    props2,
    emit,
    datesEqual
  );
  const onClick = (date) => {
    if (props2.readonly || isDateDisabled(date)) {
      return;
    }
    updateModelValue(date);
    emit(`click:${type}`, date);
  };
  const isToday = (date) => {
    const today = /* @__PURE__ */ new Date();
    return datesEqual(today, date);
  };
  const isSelected = (date) => {
    if (!props2.modelValue) {
      return false;
    }
    if (isSingleDate(props2.modelValue)) {
      return datesEqual(props2.modelValue, date);
    } else if (isDates(props2.modelValue)) {
      return !!props2.modelValue.find((d2) => datesEqual(d2, date));
    } else if (isRange2(props2.modelValue)) {
      return datesEqual(props2.modelValue.start, date) || datesEqual(props2.modelValue.end, date);
    }
    return false;
  };
  const isInRange = (date) => {
    if (!props2.modelValue) {
      return false;
    }
    if (!isRange2(props2.modelValue)) {
      return false;
    }
    if (props2.modelValue.start && props2.modelValue.end) {
      return props2.modelValue.start < date && props2.modelValue.end > date;
    }
    const selectedDate = props2.modelValue.start || props2.modelValue.end;
    if (selectedDate) {
      if (!hoveredValue.value) {
        return false;
      }
      return selectedDate < date ? hoveredValue.value >= date : hoveredValue.value <= date;
    }
    return false;
  };
  watch(hoveredValue, (date) => {
    emit(`hover:${type}`, date);
  });
  return {
    hoveredIndex,
    hoveredValue,
    onClick,
    isToday,
    isSelected,
    isInRange
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaDayPicker/va-date-picker-calendar-hook.js
var getMonthDaysCount = (year, month) => new Date(year, month + 1, 0).getDate();
var getMonthStartWeekday = (year, month) => new Date(year, month, 1).getDay();
var getNumbersArray = (length) => Array.from(Array(length).keys()).map((k2) => k2 + 1);
var useVaDatePickerCalendar = (view, options) => {
  const CALENDAR_ROWS_COUNT = 6;
  const localizeWeekday = (weekdayNumber) => {
    var _a2;
    if (options && ((_a2 = options.firstWeekday) == null ? void 0 : _a2.value) === "Monday") {
      return weekdayNumber === 0 ? 6 : weekdayNumber - 1;
    }
    return weekdayNumber;
  };
  const currentMonthStartWeekday = computed(() => localizeWeekday(getMonthStartWeekday(view.value.year, view.value.month)));
  const getPreviousDates = () => {
    if (currentMonthStartWeekday.value === 0) {
      return [];
    }
    const prevMonthDaysCount = getMonthDaysCount(view.value.year, view.value.month - 1);
    const prevMonthDays = getNumbersArray(prevMonthDaysCount);
    return prevMonthDays.slice(-currentMonthStartWeekday.value).map((d2) => new Date(view.value.year, view.value.month - 1, d2));
  };
  const getCurrentDates = () => {
    const currentMonthDays = getNumbersArray(getMonthDaysCount(view.value.year, view.value.month));
    return currentMonthDays.map((d2) => new Date(view.value.year, view.value.month, d2));
  };
  const prevAndCurrentDays = computed(() => [...getPreviousDates(), ...getCurrentDates()]);
  const currentMonthEndIndex = computed(() => prevAndCurrentDays.value.length);
  const calendarDates = computed(() => {
    const days = prevAndCurrentDays.value;
    const daysRemaining = 7 * CALENDAR_ROWS_COUNT - days.length;
    const nextMonthDaysCount = getMonthDaysCount(view.value.year, view.value.month + 1);
    const nextMonthDays = getNumbersArray(nextMonthDaysCount);
    return [
      ...days,
      ...nextMonthDays.slice(0, daysRemaining).map((d2) => new Date(view.value.year, view.value.month + 1, d2))
    ];
  });
  return { calendarDates, currentMonthStartIndex: currentMonthStartWeekday, currentMonthEndIndex };
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaDatePickerCell.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaDatePickerCell.css";
var _sfc_main49 = defineComponent({
  name: "VaDatePickerCell",
  props: {
    otherMonth: { type: Boolean, default: false },
    today: { type: Boolean, default: false },
    inRange: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    selected: { type: Boolean, default: false },
    weekend: { type: Boolean, default: false },
    hidden: { type: Boolean, default: false },
    focused: { type: Boolean, default: false },
    highlightWeekend: { type: Boolean, default: false },
    highlightToday: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    color: { type: String, default: "primary" }
  },
  emits: ["click"],
  setup(props2, { emit }) {
    const onClick = () => {
      if (!props2.disabled) {
        emit("click");
      }
    };
    const { getColor } = useColors();
    const bg = computed(() => getColor(props2.color));
    const { textColorComputed } = useTextColor(bg);
    return {
      bg,
      onClick,
      textColorComputed
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaDatePickerCell.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaDatePickerCell.css";
function _sfc_render46(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.hidden ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: "va-date-picker-cell va-date-picker-cell_clear",
    style: normalizeStyle(`--va-bg: ${String(_ctx.bg)};--va-text-color-computed: ${String(_ctx.textColorComputed)}`)
  }, null, 4)) : (openBlock(), createElementBlock("div", {
    key: 1,
    class: normalizeClass(["va-date-picker-cell", {
      "va-date-picker-cell_other-month": _ctx.otherMonth,
      "va-date-picker-cell_today": _ctx.highlightToday && _ctx.today,
      "va-date-picker-cell_in-range": _ctx.inRange,
      "va-date-picker-cell_disabled": _ctx.disabled,
      "va-date-picker-cell_highlighted-weekend": _ctx.highlightWeekend && _ctx.weekend,
      "va-date-picker-cell_selected": _ctx.selected,
      "va-date-picker-cell_focused": _ctx.focused,
      "va-date-picker-cell_readonly": _ctx.readonly
    }]),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args)),
    onKeypress: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.onClick && _ctx.onClick(...args), ["prevent", "stop"]), ["space", "enter"])),
    style: normalizeStyle(`--va-bg: ${String(_ctx.bg)};--va-text-color-computed: ${String(_ctx.textColorComputed)}`)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 38));
}
var VaDatePickerCell = _export_sfc(_sfc_main49, [["render", _sfc_render46]]);

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaDayPicker/VaDayPicker.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaDayPicker.css";
var _sfc_main50 = defineComponent({
  name: "VaDayPicker",
  components: { VaDatePickerCell },
  props: {
    monthNames: { type: Array, required: true },
    weekdayNames: { type: Array, required: true },
    firstWeekday: { type: String, default: "Sunday" },
    hideWeekDays: { type: Boolean, default: false },
    view: { type: Object, default: () => ({ type: "day" }) },
    modelValue: { type: [Date, Array, Object] },
    mode: { type: String, default: "auto" },
    showOtherMonths: { type: Boolean, default: false },
    allowedDays: { type: Function },
    weekends: { type: Function },
    highlightWeekend: { type: Boolean, default: false },
    highlightToday: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "hover:day", "click:day"],
  setup(props2, { emit }) {
    const { firstWeekday, weekdayNames, view } = toRefs(props2);
    const { calendarDates, currentMonthStartIndex, currentMonthEndIndex } = useVaDatePickerCalendar(view, { firstWeekday });
    const weekdayNamesComputed = computed(() => {
      return firstWeekday.value === "Sunday" ? weekdayNames.value : [...weekdayNames.value.slice(1), weekdayNames.value[0]];
    });
    const {
      hoveredIndex,
      onClick,
      isToday,
      isSelected,
      isInRange
    } = useDatePicker("day", calendarDates, props2, emit);
    const gridStartIndex = computed(() => props2.showOtherMonths ? 0 : currentMonthStartIndex.value);
    const gridEndIndex = computed(() => props2.showOtherMonths ? calendarDates.value.length : currentMonthEndIndex.value);
    const {
      focusedCellIndex,
      containerAttributes
    } = useGridKeyboardNavigation({
      rowSize: 7,
      start: gridStartIndex,
      end: gridEndIndex,
      onSelected: (selectedValue) => onClick(calendarDates.value[selectedValue])
    });
    watch(focusedCellIndex, (index) => {
      hoveredIndex.value = index;
    });
    watch(hoveredIndex, (index) => {
      focusedCellIndex.value = index;
    });
    const isOtherMonth = (date) => props2.view.month !== date.getMonth();
    const isDateDisabled = (date) => props2.allowedDays === void 0 ? false : !props2.allowedDays(date);
    const isDateWeekend = (date) => {
      if (props2.weekends === void 0) {
        return date.getDay() === 6 || date.getDay() === 0;
      }
      return props2.weekends(date);
    };
    return {
      hoveredIndex,
      calendarDates,
      onClick,
      isToday,
      isSelected,
      isInRange,
      isOtherMonth,
      isDateDisabled,
      isDateWeekend,
      containerAttributes,
      weekdayNamesComputed,
      focusedCellIndex
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaDayPicker/VaDayPicker.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaDayPicker.css";
var _hoisted_128 = ["onMouseenter"];
var _hoisted_214 = { class: "va-date-picker-cell__day" };
function _sfc_render47(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_date_picker_cell = resolveComponent("va-date-picker-cell");
  return openBlock(), createElementBlock("div", mergeProps({ class: "va-day-picker" }, _ctx.containerAttributes), [
    !_ctx.hideWeekDays ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.weekdayNamesComputed, (weekday) => {
      return openBlock(), createElementBlock("div", {
        key: weekday,
        class: "va-day-picker__weekday"
      }, [
        renderSlot(_ctx.$slots, "weekday", {}, () => [
          createTextVNode(toDisplayString(weekday), 1)
        ])
      ]);
    }), 128)) : createCommentVNode("", true),
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.calendarDates, (date, index) => {
      return openBlock(), createElementBlock("div", {
        class: "va-day-picker__calendar__day-wrapper",
        key: index,
        onMouseenter: ($event) => _ctx.hoveredIndex = index,
        onMouseleave: _cache[0] || (_cache[0] = ($event) => _ctx.hoveredIndex = -1)
      }, [
        createVNode(_component_va_date_picker_cell, {
          hidden: _ctx.isOtherMonth(date) && !_ctx.showOtherMonths,
          today: _ctx.isToday(date),
          selected: _ctx.isSelected(date),
          "in-range": _ctx.isInRange(date),
          "other-month": _ctx.isOtherMonth(date),
          weekend: _ctx.isDateWeekend(date),
          disabled: _ctx.isDateDisabled(date),
          focused: _ctx.hoveredIndex === index,
          "highlight-today": _ctx.highlightToday,
          "highlight-weekend": _ctx.highlightWeekend,
          readonly: _ctx.$props.readonly,
          color: _ctx.color,
          onClick: ($event) => {
            _ctx.onClick(date);
            _ctx.focusedCellIndex = index;
          }
        }, {
          default: withCtx(() => [
            createBaseVNode("span", _hoisted_214, [
              renderSlot(_ctx.$slots, "day", normalizeProps(guardReactiveProps({ date })), () => [
                createTextVNode(toDisplayString(date.getDate()), 1)
              ])
            ])
          ]),
          _: 2
        }, 1032, ["hidden", "today", "selected", "in-range", "other-month", "weekend", "disabled", "focused", "highlight-today", "highlight-weekend", "readonly", "color", "onClick"])
      ], 40, _hoisted_128);
    }), 128))
  ], 16);
}
var VaDayPicker = _export_sfc(_sfc_main50, [["render", _sfc_render47]]);

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaDatePickerHeader/VaDatePickerHeader.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaDatePickerHeader.css";
var _sfc_main51 = defineComponent({
  name: "VaDatePickerHeader",
  components: { VaButton },
  emits: ["update:view"],
  props: {
    monthNames: { type: Array, required: true },
    view: { type: Object },
    color: { type: String },
    disabled: { type: Boolean, default: false },
    ariaNextPeriodLabel: { type: String, default: "$t:nextPeriod" },
    ariaPreviousPeriodLabel: { type: String, default: "$t:previousPeriod" },
    ariaSwitchViewLabel: { type: String, default: "$t:switchView" }
  },
  setup(props2, { emit }) {
    const { syncView, prev, next } = useView(props2, emit);
    const switchView = () => {
      if (syncView.value.type === "day") {
        syncView.value = { ...syncView.value, type: "month" };
      } else if (syncView.value.type === "month") {
        syncView.value = { ...syncView.value, type: "year" };
      }
    };
    const changeView = (view) => {
      syncView.value = view;
    };
    const currentColor = useElementTextColor(useElementBackground(useCurrentElement()));
    return {
      ...useTranslation(),
      currentColor,
      prev,
      next,
      changeView,
      switchView,
      syncView
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaDatePickerHeader/VaDatePickerHeader.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaDatePickerHeader.css";
var _hoisted_129 = {
  key: 0,
  class: "va-date-picker-header va-date-picker__header"
};
var _hoisted_215 = { class: "va-date-picker__header__text" };
var _hoisted_39 = { class: "va-date-picker__header__month" };
function _sfc_render48(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  return _ctx.syncView.type !== "year" ? (openBlock(), createElementBlock("div", _hoisted_129, [
    renderSlot(_ctx.$slots, "buttonPrev", normalizeProps(guardReactiveProps({ onClick: _ctx.prev })), () => [
      createVNode(_component_va_button, {
        disabled: _ctx.$props.disabled,
        icon: "va-arrow-left",
        preset: "plain",
        size: "small",
        color: _ctx.color,
        textColor: _ctx.currentColor,
        "aria-label": _ctx.tp(_ctx.$props.ariaPreviousPeriodLabel),
        round: "",
        onClick: _ctx.prev
      }, null, 8, ["disabled", "color", "textColor", "aria-label", "onClick"])
    ]),
    createBaseVNode("div", _hoisted_215, [
      renderSlot(_ctx.$slots, "header", normalizeProps(guardReactiveProps({ year: _ctx.syncView.year, month: _ctx.syncView.month, monthNames: _ctx.monthNames, view: _ctx.syncView, changeView: _ctx.changeView, switchView: _ctx.switchView })), () => [
        createVNode(_component_va_button, {
          disabled: _ctx.$props.disabled,
          preset: "plain",
          size: "small",
          color: _ctx.color,
          textColor: _ctx.currentColor,
          "aria-label": _ctx.tp(_ctx.$props.ariaSwitchViewLabel),
          onClick: _ctx.switchView
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "year", normalizeProps(guardReactiveProps({ year: _ctx.syncView.year })), () => [
              createTextVNode(toDisplayString(_ctx.syncView.year), 1)
            ]),
            _ctx.syncView.type === "day" ? renderSlot(_ctx.$slots, "month", normalizeProps(mergeProps({ key: 0 }, { month: _ctx.syncView.month })), () => [
              createBaseVNode("span", _hoisted_39, toDisplayString(_ctx.monthNames[_ctx.syncView.month]), 1)
            ]) : createCommentVNode("", true)
          ]),
          _: 3
        }, 8, ["disabled", "color", "textColor", "aria-label", "onClick"])
      ])
    ]),
    renderSlot(_ctx.$slots, "buttonNext", normalizeProps(guardReactiveProps({ onClick: _ctx.next })), () => [
      createVNode(_component_va_button, {
        disabled: _ctx.$props.disabled,
        icon: "va-arrow-right",
        preset: "plain",
        size: "small",
        color: _ctx.color,
        textColor: _ctx.currentColor,
        "aria-label": _ctx.tp(_ctx.$props.ariaNextPeriodLabel),
        onClick: _ctx.next,
        round: ""
      }, null, 8, ["disabled", "color", "textColor", "aria-label", "onClick"])
    ])
  ])) : createCommentVNode("", true);
}
var VaDatePickerHeader = _export_sfc(_sfc_main51, [["render", _sfc_render48]]);

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaMonthPicker/VaMonthPicker.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaMonthPicker.css";
var _sfc_main52 = defineComponent({
  name: "VaMonthPicker",
  components: { VaDatePickerCell },
  props: {
    modelValue: { type: [Date, Array, Object] },
    monthNames: { type: Array, required: true },
    view: { type: Object, default: () => ({ type: "month" }) },
    allowedMonths: { type: Function, default: void 0 },
    highlightToday: { type: Boolean, default: true },
    mode: { type: String, default: "auto" },
    readonly: { type: Boolean, default: false },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "hover:month", "click:month"],
  setup(props2, { emit }) {
    const { view } = toRefs(props2);
    const months = computed(() => Array.from(Array(12).keys()).map((month) => new Date(view.value.year, month)));
    const {
      hoveredIndex,
      onClick,
      isToday,
      isSelected,
      isInRange
    } = useDatePicker("month", months, props2, emit);
    const isDisabled = (date) => props2.allowedMonths === void 0 ? false : !props2.allowedMonths(date);
    const {
      focusedCellIndex,
      containerAttributes
    } = useGridKeyboardNavigation({
      rowSize: 3,
      start: 0,
      end: months.value.length,
      onSelected: (selectedIndex) => onClick(months.value[selectedIndex])
    });
    watch(focusedCellIndex, (index) => {
      hoveredIndex.value = index;
    });
    watch(hoveredIndex, (index) => {
      focusedCellIndex.value = index;
    });
    return {
      months,
      hoveredIndex,
      onClick,
      isToday,
      isSelected,
      isInRange,
      isDisabled,
      containerAttributes,
      focusedCellIndex
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaMonthPicker/VaMonthPicker.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaMonthPicker.css";
var _hoisted_130 = ["onMouseenter"];
function _sfc_render49(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_date_picker_cell = resolveComponent("va-date-picker-cell");
  return openBlock(), createElementBlock("div", mergeProps({ class: "va-month-picker" }, _ctx.containerAttributes), [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.months, (month, monthIndex) => {
      return openBlock(), createElementBlock("div", {
        key: monthIndex,
        class: "va-month-picker__month-wrapper",
        onMouseenter: ($event) => _ctx.hoveredIndex = monthIndex,
        onMouseleave: _cache[0] || (_cache[0] = ($event) => _ctx.hoveredIndex = -1)
      }, [
        createVNode(_component_va_date_picker_cell, {
          "in-range": !!_ctx.isInRange(month),
          selected: !!_ctx.isSelected(month),
          disabled: !!_ctx.isDisabled(month),
          today: !!_ctx.isToday(month),
          focused: _ctx.hoveredIndex === monthIndex,
          "highlight-today": _ctx.highlightToday,
          readonly: _ctx.$props.readonly,
          color: _ctx.color,
          onClick: ($event) => {
            _ctx.onClick(month);
            _ctx.focusedCellIndex = monthIndex;
          }
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "month", normalizeProps(guardReactiveProps({ monthIndex, month: _ctx.monthNames[monthIndex] })), () => [
              createTextVNode(toDisplayString(_ctx.monthNames[monthIndex]), 1)
            ])
          ]),
          _: 2
        }, 1032, ["in-range", "selected", "disabled", "today", "focused", "highlight-today", "readonly", "color", "onClick"])
      ], 40, _hoisted_130);
    }), 128))
  ], 16);
}
var VaMonthPicker = _export_sfc(_sfc_main52, [["render", _sfc_render49]]);

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaYearPicker/VaYearPicker.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaYearPicker.css";
var _sfc_main53 = defineComponent({
  name: "VaYearPicker",
  components: { VaDatePickerCell },
  props: {
    modelValue: { type: [Date, Array, Object] },
    allowedYears: { type: Function, default: void 0 },
    highlightToday: { type: Boolean, default: true },
    startYear: { type: Number, default: 1970 },
    mode: { type: String, default: "auto" },
    view: { type: Object, default: () => ({ type: "year" }) },
    endYear: { type: Number, default: () => (/* @__PURE__ */ new Date()).getFullYear() + 50 },
    readonly: { type: Boolean, default: false },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "hover:year", "click:year"],
  setup(props2, { emit }) {
    const rootNode = shallowRef();
    const { view } = toRefs(props2);
    const generateYearsArray = (start, end) => {
      const yearsCount = end - start + 1;
      return Array.from(Array(yearsCount).keys()).map((i2) => createYearDate(start + i2));
    };
    const years = computed(() => generateYearsArray(props2.startYear, props2.endYear));
    const scrollIntoYearIndex = (index) => {
      if (!rootNode.value) {
        return;
      }
      const scrollHeight = rootNode.value.scrollHeight;
      const rootNodeHeight = rootNode.value.offsetHeight;
      const currentYearOffset = scrollHeight / years.value.length * index;
      const cellSize = scrollHeight / years.value.length;
      const relativeScrollPosition = currentYearOffset - rootNode.value.scrollTop;
      if (relativeScrollPosition < 0) {
        rootNode.value.scrollTo({ top: currentYearOffset });
      } else if (relativeScrollPosition > rootNodeHeight) {
        rootNode.value.scrollTo({ top: currentYearOffset - rootNodeHeight + cellSize });
      }
    };
    const scrollIntoYearIndexCenter = (index) => {
      if (!rootNode.value) {
        return;
      }
      const scrollHeight = rootNode.value.scrollHeight;
      const rootNodeHeight = rootNode.value.offsetHeight;
      const currentYearOffset = scrollHeight / years.value.length * index;
      rootNode.value.scrollTo({ top: currentYearOffset - rootNodeHeight / 2 });
    };
    onMounted(() => {
      const currentYearIndex = years.value.findIndex((date) => date.getFullYear() === view.value.year);
      scrollIntoYearIndexCenter(currentYearIndex);
    });
    const {
      hoveredIndex,
      onClick,
      isToday,
      isSelected,
      isInRange
    } = useDatePicker("year", years, props2, emit);
    const isYearDisabled = (year) => props2.allowedYears === void 0 ? false : !props2.allowedYears(year);
    const {
      focusedCellIndex,
      containerAttributes
    } = useGridKeyboardNavigation({
      rowSize: 1,
      start: 0,
      end: years.value.length,
      onFocusIndex: computed(() => years.value.findIndex((date) => date.getFullYear() === view.value.year)),
      onSelected: (selectedIndex) => onClick(years.value[selectedIndex])
    });
    watch(focusedCellIndex, (index) => index !== -1 && scrollIntoYearIndex(index));
    watch(focusedCellIndex, (index) => {
      hoveredIndex.value = index;
    });
    watch(hoveredIndex, (index) => {
      focusedCellIndex.value = index;
    });
    return {
      hoveredIndex,
      years,
      rootNode,
      onClick,
      isToday,
      isSelected,
      isInRange,
      isYearDisabled,
      focusedCellIndex,
      containerAttributes
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaYearPicker/VaYearPicker.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaYearPicker.css";
function _sfc_render50(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_date_picker_cell = resolveComponent("va-date-picker-cell");
  return openBlock(), createElementBlock("div", mergeProps({
    ref: "rootNode",
    class: "va-year-picker"
  }, _ctx.containerAttributes, {
    onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers(() => {
    }, ["prevent"]), ["space"]))
  }), [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.years, (year, index) => {
      return openBlock(), createBlock(_component_va_date_picker_cell, {
        key: year.toString(),
        "in-range": _ctx.isInRange(year),
        selected: _ctx.isSelected(year),
        disabled: _ctx.isYearDisabled(year),
        today: _ctx.isToday(year),
        focused: _ctx.focusedCellIndex === index,
        "highlight-today": _ctx.highlightToday,
        readonly: _ctx.$props.readonly,
        color: _ctx.color,
        onClick: ($event) => {
          _ctx.onClick(year);
          _ctx.focusedCellIndex = index;
        },
        onMouseenter: ($event) => _ctx.hoveredIndex = index,
        onMouseleave: _cache[0] || (_cache[0] = ($event) => _ctx.hoveredIndex = -1)
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(year.getFullYear()), 1)
        ]),
        _: 2
      }, 1032, ["in-range", "selected", "disabled", "today", "focused", "highlight-today", "readonly", "color", "onClick", "onMouseenter"]);
    }), 128))
  ], 16);
}
var VaYearPicker = _export_sfc(_sfc_main53, [["render", _sfc_render50]]);

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/VaDatePicker.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaDatePicker.css";
var DEFAULT_MONTH_NAMES = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
var DEFAULT_WEEKDAY_NAMES = ["SU", "MO", "TU", "WE", "TH", "FR", "SA"];
var _sfc_main54 = defineComponent({
  name: "VaDatePicker",
  components: { VaDayPicker, VaDatePickerHeader, VaMonthPicker, VaYearPicker },
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    ...extractComponentProps(VaDatePickerHeader),
    ...extractComponentProps(VaDayPicker),
    ...extractComponentProps(VaMonthPicker),
    ...extractComponentProps(VaYearPicker),
    modelValue: { type: [Date, Array, Object] },
    monthNames: { type: Array, default: DEFAULT_MONTH_NAMES },
    weekdayNames: { type: Array, default: DEFAULT_WEEKDAY_NAMES },
    view: { type: Object },
    type: { type: String, default: "day" },
    readonly: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    // Colors
    color: { type: String, default: void 0 },
    weekendsColor: { type: String, default: void 0 }
  },
  emits: [
    ...useStatefulEmits,
    ...extractComponentEmits(VaDatePickerHeader),
    ...extractComponentEmits(VaYearPicker),
    ...extractComponentEmits(VaDayPicker),
    ...extractComponentEmits(VaMonthPicker)
  ],
  setup(props2, { emit }) {
    const currentPicker = ref();
    const { valueComputed } = useStateful(props2, emit);
    const { syncView } = useView(props2, emit, { type: props2.type });
    const classComputed = computed(() => ({
      "va-date-picker_without-week-days": props2.hideWeekDays,
      "va-date-picker_disabled": props2.disabled
    }));
    const onDayModelValueUpdate = (modelValue) => {
      if (props2.readonly) {
        return;
      }
      if (props2.type === "day") {
        valueComputed.value = modelValue;
      }
    };
    const onMonthClick = (date) => {
      emit("click:month", date);
      const year = date.getFullYear();
      const month = date.getMonth();
      if (props2.type !== "month") {
        syncView.value = { type: "day", year, month };
      }
    };
    const onMonthModelValueUpdate = (modelValue) => {
      if (props2.type === "month") {
        valueComputed.value = modelValue;
      }
    };
    const onYearClick = (date) => {
      emit("click:year", date);
      const year = date.getFullYear();
      if (props2.type !== "year") {
        syncView.value = { type: "month", year, month: syncView.value.month };
      }
    };
    const onYearModelValueUpdate = (modelValue) => {
      if (props2.type === "year") {
        valueComputed.value = modelValue;
      }
    };
    const { colorsToCSSVariable } = useColors();
    const styleComputed = computed(() => ({
      ...colorsToCSSVariable({
        color: props2.color,
        "weekends-color": props2.weekendsColor
      }, "va-date-picker")
    }));
    const focusCurrentPicker = () => {
      var _a2;
      return (_a2 = currentPicker.value) == null ? void 0 : _a2.$el.focus();
    };
    watch(syncView, (newValue, prevValue) => {
      if (newValue.type === prevValue.type) {
        return;
      }
      nextTick(focusCurrentPicker);
    });
    const isPickerReadonly = (pickerName) => {
      return props2.readonly && props2.type === pickerName;
    };
    return {
      dayPickerProps: filterComponentProps(extractComponentProps(VaDayPicker)),
      headerProps: filterComponentProps(extractComponentProps(VaDatePickerHeader)),
      monthPickerProps: filterComponentProps(extractComponentProps(VaMonthPicker)),
      yearPickerProps: filterComponentProps(extractComponentProps(VaYearPicker)),
      syncView,
      classComputed,
      valueComputed,
      onDayModelValueUpdate,
      onMonthClick,
      onMonthModelValueUpdate,
      onYearClick,
      onYearModelValueUpdate,
      styleComputed,
      currentPicker,
      focusCurrentPicker,
      isPickerReadonly
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/VaDatePicker.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaDatePicker.css";
var _hoisted_131 = { class: "va-date-picker__picker-wrapper" };
function _sfc_render51(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_date_picker_header = resolveComponent("va-date-picker-header");
  const _component_va_day_picker = resolveComponent("va-day-picker");
  const _component_va_month_picker = resolveComponent("va-month-picker");
  const _component_va_year_picker = resolveComponent("va-year-picker");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-date-picker", _ctx.classComputed]),
    style: normalizeStyle(_ctx.styleComputed)
  }, [
    createVNode(_component_va_date_picker_header, mergeProps(_ctx.headerProps, {
      view: _ctx.syncView,
      "onUpdate:view": _cache[0] || (_cache[0] = ($event) => _ctx.syncView = $event)
    }), createSlots({ _: 2 }, [
      renderList(_ctx.$slots, (_2, name) => {
        return {
          name,
          fn: withCtx((bind) => [
            renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
          ])
        };
      })
    ]), 1040, ["view"]),
    createBaseVNode("div", _hoisted_131, [
      _ctx.syncView.type === "day" ? (openBlock(), createBlock(_component_va_day_picker, mergeProps({
        key: 0,
        ref: "currentPicker"
      }, _ctx.dayPickerProps, {
        "model-value": _ctx.valueComputed,
        view: _ctx.syncView,
        readonly: _ctx.$props.disabled || _ctx.isPickerReadonly("day"),
        "onUpdate:modelValue": _ctx.onDayModelValueUpdate,
        "onHover:day": _cache[1] || (_cache[1] = (value) => _ctx.$emit("hover:day", value)),
        "onClick:day": _cache[2] || (_cache[2] = (value) => _ctx.$emit("click:day", value))
      }), createSlots({ _: 2 }, [
        renderList(_ctx.$slots, (_2, name) => {
          return {
            name,
            fn: withCtx((bind) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
            ])
          };
        })
      ]), 1040, ["model-value", "view", "readonly", "onUpdate:modelValue"])) : createCommentVNode("", true),
      _ctx.syncView.type === "month" ? (openBlock(), createBlock(_component_va_month_picker, mergeProps({
        key: 1,
        ref: "currentPicker"
      }, _ctx.monthPickerProps, {
        view: _ctx.syncView,
        "model-value": _ctx.valueComputed,
        readonly: _ctx.$props.disabled || _ctx.isPickerReadonly("month"),
        "onUpdate:modelValue": _ctx.onMonthModelValueUpdate,
        "onHover:month": _cache[3] || (_cache[3] = (value) => _ctx.$emit("hover:month", value)),
        "onClick:month": _ctx.onMonthClick
      }), createSlots({ _: 2 }, [
        renderList(_ctx.$slots, (_2, name) => {
          return {
            name,
            fn: withCtx((bind) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
            ])
          };
        })
      ]), 1040, ["view", "model-value", "readonly", "onUpdate:modelValue", "onClick:month"])) : createCommentVNode("", true),
      _ctx.syncView.type === "year" ? (openBlock(), createBlock(_component_va_year_picker, mergeProps({
        key: 2,
        ref: "currentPicker"
      }, _ctx.yearPickerProps, {
        view: _ctx.syncView,
        "model-value": _ctx.valueComputed,
        readonly: _ctx.$props.disabled || _ctx.isPickerReadonly("year"),
        "onHover:year": _cache[4] || (_cache[4] = (value) => _ctx.$emit("hover:year", value)),
        "onUpdate:modelValue": _ctx.onYearModelValueUpdate,
        "onClick:year": _ctx.onYearClick
      }), createSlots({ _: 2 }, [
        renderList(_ctx.$slots, (_2, name) => {
          return {
            name,
            fn: withCtx((bind) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
            ])
          };
        })
      ]), 1040, ["view", "model-value", "readonly", "onUpdate:modelValue", "onClick:year"])) : createCommentVNode("", true)
    ])
  ], 6);
}
var _VaDatePicker = _export_sfc(_sfc_main54, [["render", _sfc_render51]]);

// node_modules/vuestic-ui/dist/es/src/composables/useDropdownable.js
var VaDropdownProps2 = extractComponentProps(
  VaDropdown,
  ["innerAnchorSelector", "stateful", "keyboardNavigation", "modelValue"]
);
var useDropdownableProps = {
  ...VaDropdownProps2,
  modelValue: {},
  /**
   * Close dropdown on value updated.
   * @default null - behavior controlled by component
   */
  closeOnChange: { type: Boolean, default: null },
  isOpen: { type: Boolean, default: void 0 }
};
var useDropdownableEmits = ["update:isOpen"];
var useDropdownable = function(props2, emit, options = {}) {
  const [isOpenSync] = useSyncProp("isOpen", props2, emit, false);
  const doWatch = computed(() => props2.closeOnChange !== null ? props2.closeOnChange : unref(options.defaultCloseOnValueUpdate || false));
  watch(() => props2.modelValue, () => {
    if (doWatch.value) {
      isOpenSync.value = false;
    }
  });
  return {
    dropdownProps: filterComponentProps(VaDropdownProps2),
    isOpenSync
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useParsable.js
var useParsable = (parsable, parse2, format) => {
  const text = computed({
    get() {
      const value2 = parsable.value;
      if (typeof value2 === "string") {
        return value2;
      }
      return format(value2);
    },
    set(v2) {
      if (typeof parsable.value === "string") {
        parsable.value = v2;
      } else {
        parsable.value = parse2(v2);
      }
    }
  });
  const value = computed({
    get() {
      if (typeof parsable.value === "string") {
        return parse2(parsable.value);
      }
      return parsable.value;
    },
    set(v2) {
      if (typeof parsable.value === "string") {
        parsable.value = format(v2);
      } else {
        parsable.value = v2;
      }
    }
  });
  return {
    text,
    value
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-input/VaDateInput.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaDateInput.css";
var VaInputWrapperProps3 = extractComponentProps(VaInputWrapper, ["focused", "maxLength", "counterValue"]);
var VaDatePickerProps = extractComponentProps(_VaDatePicker);
extractComponentProps(
  VaDropdown,
  ["innerAnchorSelector", "stateful", "keyboardNavigation", "modelValue", "trigger"]
);
var _sfc_main55 = defineComponent({
  name: "VaDateInput",
  components: {
    VaDropdown,
    VaDropdownContent,
    VaDatePicker: _VaDatePicker,
    VaInputWrapper,
    VaIcon
  },
  props: {
    ...useDropdownableProps,
    ...useClearableProps,
    ...VaInputWrapperProps3,
    ...VaDatePickerProps,
    ...useValidationProps,
    ...useComponentPresetProp,
    clearValue: { type: Date, default: void 0 },
    modelValue: { type: [Date, Array, Object, String, Number] },
    resetOnClose: { type: Boolean, default: true },
    closeOnContentClick: { type: Boolean, default: false },
    offset: { ...useDropdownableProps.offset, default: () => [2, 0] },
    format: { type: Function },
    formatDate: { type: Function, default: (d2) => d2.toLocaleDateString() },
    parse: { type: Function },
    parseDate: { type: Function },
    parseValue: { type: Function },
    delimiter: { type: String, default: ", " },
    rangeDelimiter: { type: String, default: " ~ " },
    manualInput: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    leftIcon: { type: Boolean, default: false },
    icon: { type: String, default: "va-calendar" },
    ariaToggleDropdownLabel: { type: String, default: "$t:toggleDropdown" },
    ariaResetLabel: { type: String, default: "$t:resetDate" },
    ariaSelectedDateLabel: { type: String, default: "$t:selectedDate" }
  },
  emits: [
    ...useFocusEmits,
    ...extractComponentEmits(_VaDatePicker),
    ...useClearableEmits,
    ...useValidationEmits,
    ...useStatefulEmits,
    ...useDropdownableEmits,
    "update:text"
  ],
  inheritAttrs: false,
  setup(props2, { emit, slots, attrs }) {
    const input = shallowRef();
    const datePicker = ref();
    const { resetOnClose } = toRefs(props2);
    const { trapFocusIn, freeFocus } = useTrapFocus();
    const trapFocus = () => {
      const el = unwrapEl(datePicker.value);
      if (!el) {
        freeFocus();
        return;
      }
      trapFocusIn(el);
    };
    watch([datePicker], () => {
      trapFocus();
    });
    const { valueComputed: statefulValue } = useStateful(props2, emit);
    const { isOpenSync, dropdownProps } = useDropdownable(props2, emit, {
      defaultCloseOnValueUpdate: computed(() => !Array.isArray(statefulValue.value))
    });
    const { isFocused: isInputFocused, focus, blur, onFocus: focusListener, onBlur: blurListener } = useFocus(input);
    const isPickerFocused = useFocusDeep(datePicker);
    const isRangeModelValueGuardDisabled = computed(() => !resetOnClose.value);
    const {
      valueComputed,
      reset: resetInvalidRange
    } = useRangeModelValueGuard(statefulValue, isRangeModelValueGuardDisabled, props2.parseValue);
    watch(isOpenSync, (isOpened) => {
      if (!isOpened && !isRangeModelValueGuardDisabled.value) {
        resetInvalidRange();
      }
    });
    const dateOrNothing = (date) => date ? props2.formatDate(date) : "...";
    const { parseDateInputValue, isValid } = useDateParser(props2);
    watch(valueComputed, () => {
      isValid.value = true;
    });
    const modelValueToString = (value) => {
      if (props2.format) {
        return props2.format(valueComputed.value);
      }
      if (isDates(value)) {
        return value.map((d2) => props2.formatDate(d2)).join(props2.delimiter);
      }
      if (isSingleDate(value)) {
        return props2.formatDate(value);
      }
      if (isRange2(value)) {
        return dateOrNothing(value.start) + props2.rangeDelimiter + dateOrNothing(value.end);
      }
      throw new Error("VaDatePicker: Invalid model value. Value should be Date, Date[] or { start: Date, end: Date | null }");
    };
    const {
      text,
      value: valueWithoutText
    } = useParsable(valueComputed, parseDateInputValue, modelValueToString);
    const valueText = computed(() => {
      if (!isValid.value) {
        return "";
      }
      if (!valueComputed.value) {
        if (!props2.clearValue) {
          return "";
        }
        return modelValueToString(props2.clearValue);
      }
      return text.value;
    });
    const onInputTextChanged = ({ target }) => {
      if (props2.disabled) {
        return;
      }
      const parsedValue = parseDateInputValue(target.value);
      if (isValid.value) {
        valueComputed.value = parsedValue;
      }
    };
    const reset = () => withoutValidation(() => {
      statefulValue.value = props2.clearValue;
      emit("clear");
      resetValidation();
    });
    const hideAndFocus = () => {
      isOpenSync.value = false;
      focus();
    };
    const focusDatePicker = () => {
      nextTick(() => {
        var _a2;
        return (_a2 = datePicker.value) == null ? void 0 : _a2.focusCurrentPicker();
      });
    };
    const focusInputOrPicker = () => {
      isOpenSync.value ? focusDatePicker() : focus();
    };
    const checkProhibitedDropdownOpening = (e2) => {
      if (isOpenSync.value) {
        return false;
      }
      if (props2.disabled || props2.readonly) {
        return true;
      }
      return props2.manualInput && (e2 == null ? void 0 : e2.code) !== "Space";
    };
    const toggleDropdown = (event) => {
      if (checkProhibitedDropdownOpening(event instanceof KeyboardEvent ? event : void 0)) {
        return;
      }
      isOpenSync.value = !isOpenSync.value;
      nextTick(focusInputOrPicker);
    };
    const showDropdown = () => {
      if (props2.disabled || props2.readonly) {
        return;
      }
      isOpenSync.value = true;
      nextTick(focusDatePicker);
    };
    const {
      computedError,
      computedErrorMessages,
      listeners,
      validationAriaAttributes,
      withoutValidation,
      resetValidation
    } = useValidation(props2, emit, { reset, focus, value: valueComputed });
    const hasError = computed(() => !isValid.value && valueComputed.value !== props2.clearValue || computedError.value);
    const filterSlots = computed(() => {
      const slotsWithIcons = [
        props2.leftIcon && "prependInner",
        (!props2.leftIcon || props2.clearable) && "icon"
      ];
      return Object.keys(slots).filter((slot) => !slotsWithIcons.includes(slot));
    });
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props2, valueComputed);
    const cursorStyleComputed = computed(() => {
      if (props2.disabled) {
        return {};
      }
      if (props2.manualInput) {
        return { cursor: "text" };
      }
      return { cursor: "pointer" };
    });
    const iconTabindexComputed = computed(() => {
      if (!props2.manualInput) {
        return -1;
      }
      return props2.disabled || props2.readonly ? -1 : 0;
    });
    const iconProps = computed(() => ({
      role: iconTabindexComputed.value === 0 ? "button" : "none",
      ariaHidden: iconTabindexComputed.value === -1,
      name: props2.icon,
      color: "secondary",
      tabindex: iconTabindexComputed.value
    }));
    const filteredWrapperProps = filterComponentProps(VaInputWrapperProps3);
    const computedInputWrapperProps = computed(() => ({
      ...filteredWrapperProps.value,
      focused: isInputFocused.value || isPickerFocused.value,
      error: hasError.value,
      errorMessages: computedErrorMessages.value,
      readonly: props2.readonly || !props2.manualInput
    }));
    const computedInputListeners = computed(() => ({
      focus: () => {
        if (props2.disabled) {
          return;
        }
        focusListener();
        if (props2.readonly) {
          return;
        }
        onFocus();
        listeners.onFocus();
      },
      blur: () => {
        if (props2.disabled) {
          return;
        }
        blurListener();
        if (props2.readonly) {
          return;
        }
        onBlur();
        listeners.onBlur();
      }
    }));
    const { tp } = useTranslation();
    const inputAttributesComputed = computed(() => ({
      readonly: props2.readonly || !props2.manualInput,
      disabled: props2.disabled,
      tabindex: props2.disabled ? -1 : 0,
      placeholder: props2.placeholder,
      value: valueText.value,
      ariaLabel: props2.label || tp(props2.ariaSelectedDateLabel),
      ariaRequired: props2.requiredMark,
      ariaDisabled: props2.disabled,
      ariaReadOnly: props2.readonly,
      ...validationAriaAttributes.value,
      ...omit$1(attrs, ["class", "style"])
    }));
    const dropdownPropsComputed = computed(() => ({
      ...dropdownProps.value,
      stateful: false,
      closeOnAnchorClick: false,
      keyboardNavigation: true,
      innerAnchorSelector: ".va-input-wrapper__field",
      trigger: "none"
    }));
    return {
      tp,
      datePicker,
      valueText,
      valueWithoutText,
      valueComputed,
      isOpenSync,
      onInputTextChanged,
      trapFocus,
      isInputFocused,
      isPickerFocused,
      input,
      inputWrapperProps: computedInputWrapperProps,
      inputListeners: computedInputListeners,
      inputAttributesComputed,
      datePickerProps: filterComponentProps(VaDatePickerProps),
      dropdownPropsComputed,
      filterSlots,
      canBeCleared,
      clearIconProps,
      iconProps,
      cursorStyleComputed,
      hideAndFocus,
      toggleDropdown,
      showDropdown,
      focusInputOrPicker,
      focusDatePicker,
      reset,
      focus,
      blur
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-date-input/VaDateInput.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaDateInput.css";
function _sfc_render52(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  const _component_va_date_picker = resolveComponent("va-date-picker");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createBlock(_component_va_dropdown, mergeProps({
    modelValue: _ctx.isOpenSync,
    "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => _ctx.isOpenSync = $event),
    class: ["va-date-input", _ctx.$attrs.class],
    style: _ctx.$attrs.style
  }, _ctx.dropdownPropsComputed, {
    onOpen: _ctx.focusDatePicker,
    role: "none"
  }), {
    anchor: withCtx(() => [
      renderSlot(_ctx.$slots, "input", normalizeProps(guardReactiveProps({ valueText: _ctx.valueText, inputAttributes: _ctx.inputAttributesComputed, inputWrapperProps: _ctx.inputWrapperProps, inputListeners: _ctx.inputListeners })), () => [
        createVNode(_component_va_input_wrapper, mergeProps({
          class: "va-date-input__anchor",
          style: _ctx.cursorStyleComputed
        }, _ctx.inputWrapperProps, toHandlers(_ctx.inputListeners), {
          "model-value": _ctx.valueText,
          onClick: withModifiers(_ctx.toggleDropdown, ["stop"]),
          onChange: _ctx.onInputTextChanged
        }), createSlots({
          icon: withCtx(() => [
            _ctx.canBeCleared ? (openBlock(), createBlock(_component_va_icon, mergeProps({
              key: 0,
              "aria-label": _ctx.tp(_ctx.$props.ariaResetLabel)
            }, { ..._ctx.iconProps, ..._ctx.clearIconProps }, {
              onClick: withModifiers(_ctx.reset, ["stop"]),
              onKeydown: [
                withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
                withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
              ]
            }), null, 16, ["aria-label", "onClick", "onKeydown"])) : createCommentVNode("", true),
            !_ctx.$props.leftIcon && _ctx.$props.icon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
              key: 1,
              "aria-label": _ctx.tp(_ctx.$props.ariaToggleDropdownLabel)
            }, _ctx.iconProps, {
              onClick: withModifiers(_ctx.showDropdown, ["stop"]),
              onKeydown: [
                withKeys(withModifiers(_ctx.showDropdown, ["stop"]), ["enter"]),
                withKeys(withModifiers(_ctx.showDropdown, ["stop"]), ["space"])
              ]
            }), null, 16, ["aria-label", "onClick", "onKeydown"])) : createCommentVNode("", true)
          ]),
          _: 2
        }, [
          renderList(_ctx.filterSlots, (name) => {
            return {
              name,
              fn: withCtx((slotScope) => [
                renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
              ])
            };
          }),
          _ctx.$slots.prependInner || _ctx.$props.leftIcon ? {
            name: "prependInner",
            fn: withCtx((slotScope) => [
              renderSlot(_ctx.$slots, "prependInner", normalizeProps(guardReactiveProps(slotScope))),
              _ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
                key: 0,
                "aria-label": _ctx.tp(_ctx.$props.ariaToggleDropdownLabel)
              }, _ctx.iconProps, {
                onClick: withModifiers(_ctx.showDropdown, ["stop"]),
                onKeydown: [
                  withKeys(withModifiers(_ctx.showDropdown, ["stop"]), ["enter"]),
                  withKeys(withModifiers(_ctx.showDropdown, ["stop"]), ["space"])
                ]
              }), null, 16, ["aria-label", "onClick", "onKeydown"])) : createCommentVNode("", true)
            ]),
            key: "0"
          } : void 0
        ]), 1040, ["style", "model-value", "onClick", "onChange"])
      ])
    ]),
    default: withCtx(() => [
      createVNode(_component_va_dropdown_content, {
        class: "va-date-input__dropdown-content",
        onKeydown: _cache[8] || (_cache[8] = withKeys(($event) => _ctx.focus(), ["esc"])),
        role: "dialog"
      }, {
        default: withCtx(() => [
          createVNode(_component_va_date_picker, mergeProps({ ref: "datePicker" }, _ctx.datePickerProps, {
            modelValue: _ctx.valueWithoutText,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.valueWithoutText = $event),
            "onClick:day": _cache[1] || (_cache[1] = ($event) => _ctx.$emit("click:day", $event)),
            "onClick:month": _cache[2] || (_cache[2] = ($event) => _ctx.$emit("click:month", $event)),
            "onClick:year": _cache[3] || (_cache[3] = ($event) => _ctx.$emit("click:year", $event)),
            "onHover:day": _cache[4] || (_cache[4] = ($event) => _ctx.$emit("hover:day", $event)),
            "onHover:month": _cache[5] || (_cache[5] = ($event) => _ctx.$emit("hover:month", $event)),
            "onHover:year": _cache[6] || (_cache[6] = ($event) => _ctx.$emit("hover:year", $event)),
            "onUpdate:view": _cache[7] || (_cache[7] = ($event) => {
              _ctx.$nextTick(() => _ctx.trapFocus());
              _ctx.$emit("update:view", $event);
            })
          }), createSlots({ _: 2 }, [
            renderList(_ctx.$slots, (_2, name) => {
              return {
                name,
                fn: withCtx((bind) => [
                  renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
                ])
              };
            })
          ]), 1040, ["modelValue"])
        ]),
        _: 3
      })
    ]),
    _: 3
  }, 16, ["modelValue", "class", "style", "onOpen"]);
}
var _VaDateInput = _export_sfc(_sfc_main55, [["render", _sfc_render52]]);

// node_modules/vuestic-ui/dist/es/src/components/va-date-input/index.js
var VaDateInput = withConfigTransport$1(_VaDateInput);

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/index.js
var VaDatePicker = withConfigTransport$1(_VaDatePicker);

// node_modules/vuestic-ui/dist/es/src/components/va-divider/VaDivider.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaDivider.css";
var prefixClass = "va-divider";
var _sfc_main56 = defineComponent({
  name: "VaDivider",
  props: {
    ...useComponentPresetProp,
    vertical: { type: Boolean, default: false },
    dashed: { type: Boolean, default: false },
    inset: { type: Boolean, default: false },
    orientation: {
      type: String,
      default: "center",
      validator: (value) => ["left", "right", "center"].includes(value)
    },
    color: { type: String, default: "backgroundBorder" }
  },
  setup(props2, { slots }) {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props2.color));
    return {
      colorComputed,
      hasSlot: computed(() => !!slots.default),
      classComputed: computed(() => ({
        [`${prefixClass}--vertical`]: props2.vertical,
        [`${prefixClass}--inset`]: props2.inset,
        [`${prefixClass}--${props2.orientation}`]: props2.orientation && !props2.vertical,
        [`${prefixClass}--dashed`]: props2.dashed
      }))
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-divider/VaDivider.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaDivider.css";
var _hoisted_132 = ["aria-orientation"];
var _hoisted_216 = {
  key: 0,
  class: "va-divider__text"
};
function _sfc_render53(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    role: "separator",
    class: normalizeClass(["va-divider", _ctx.classComputed]),
    "aria-orientation": _ctx.vertical ? "vertical" : "horizontal",
    "aria-hidden": true,
    style: normalizeStyle(`--va-color-computed: ${String(_ctx.colorComputed)}`)
  }, [
    _ctx.hasSlot && !_ctx.vertical ? (openBlock(), createElementBlock("div", _hoisted_216, [
      renderSlot(_ctx.$slots, "default")
    ])) : createCommentVNode("", true)
  ], 14, _hoisted_132);
}
var _VaDivider = _export_sfc(_sfc_main56, [["render", _sfc_render53]]);

// node_modules/vuestic-ui/dist/es/src/components/va-divider/index.js
var VaDivider = withConfigTransport$1(_VaDivider);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/types.js
var VaFileUploadKey = Symbol("VaFileUpload");

// node_modules/vuestic-ui/dist/es/src/components/va-list/VaList.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaList.css";
var _sfc_main57 = defineComponent({
  name: "VaList",
  props: {
    ...useComponentPresetProp,
    fit: { type: Boolean, default: false }
  },
  setup(props2) {
    const computedClass = computed(() => ({ "va-list--fit": props2.fit }));
    return {
      computedClass
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-list/VaList.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaList.css";
function _sfc_render54(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-list", _ctx.computedClass]),
    role: "list"
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var _VaList = _export_sfc(_sfc_main57, [["render", _sfc_render54]]);

// node_modules/vuestic-ui/dist/es/src/components/va-list/VaListItem.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaListItem.css";
var _sfc_main58 = defineComponent({
  name: "VaListItem",
  emits: ["focus", "click"],
  props: {
    ...useRouterLinkProps,
    ...useComponentPresetProp,
    tag: { type: String, default: "div" },
    disabled: { type: Boolean, default: false }
  },
  setup(props2) {
    const tabIndexComputed = computed(() => props2.disabled ? -1 : 0);
    const computedClass = useBem("va-list-item", () => ({
      ...pick$1(props2, ["disabled"])
    }));
    const {
      tagComputed,
      hrefComputed
    } = useRouterLink(props2);
    return {
      tagComputed,
      hrefComputed,
      tabIndexComputed,
      computedClass
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-list/VaListItem.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaListItem.css";
function _sfc_render55(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
    class: normalizeClass(["va-list-item", _ctx.computedClass]),
    role: "listitem",
    href: _ctx.hrefComputed,
    target: _ctx.target,
    to: _ctx.to,
    replace: _ctx.replace,
    exact: _ctx.exact,
    "active-class": _ctx.activeClass,
    "exact-active-class": _ctx.exactActiveClass,
    tabindex: _ctx.tabIndexComputed
  }, {
    default: withCtx(() => [
      createBaseVNode("div", {
        class: "va-list-item__inner",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click")),
        onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("focus"))
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 32)
    ]),
    _: 3
  }, 8, ["href", "target", "to", "replace", "exact", "active-class", "exact-active-class", "class", "tabindex"]);
}
var _VaListItem = _export_sfc(_sfc_main58, [["render", _sfc_render55]]);

// node_modules/vuestic-ui/dist/es/src/components/va-list/VaListLabel.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaListLabel.css";
var _sfc_main59 = defineComponent({
  name: "VaListLabel",
  props: {
    ...useComponentPresetProp,
    color: { type: String, default: "primary" }
  },
  setup: (props2) => {
    const { getColor } = useColors();
    return {
      computedStyle: computed(() => ({
        color: getColor(props2.color)
      }))
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-list/VaListLabel.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaListLabel.css";
function _sfc_render56(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "va-list-label",
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 4);
}
var _VaListLabel = _export_sfc(_sfc_main59, [["render", _sfc_render56]]);

// node_modules/vuestic-ui/dist/es/src/components/va-list/VaListItemLabel.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaListItemLabel.css";
var _sfc_main60 = defineComponent({
  name: "VaListItemLabel",
  props: {
    ...useComponentPresetProp,
    caption: { type: Boolean, default: false },
    lines: { type: Number, default: 1 }
  },
  setup(props2) {
    const computedClass = computed(() => ({ "va-list-item-label--caption": props2.caption }));
    const computedStyle = computed(() => ({ "-webkit-line-clamp": props2.lines }));
    return {
      computedClass,
      computedStyle
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-list/VaListItemLabel.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaListItemLabel.css";
function _sfc_render57(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-list-item-label", _ctx.computedClass]),
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
var _VaListItemLabel = _export_sfc(_sfc_main60, [["render", _sfc_render57]]);

// node_modules/vuestic-ui/dist/es/src/components/va-list/VaListItemSection.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaListItemSection.css";
var _sfc_main61 = defineComponent({
  name: "VaListItemSection",
  props: {
    ...useComponentPresetProp,
    icon: { type: Boolean, default: false },
    avatar: { type: Boolean, default: false }
  },
  setup(props2) {
    const computedClass = computed(() => ({
      "va-list-item-section--main": !props2.icon && !props2.avatar,
      "va-list-item-section--icon": props2.icon,
      "va-list-item-section--avatar": props2.avatar
    }));
    return {
      computedClass
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-list/VaListItemSection.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaListItemSection.css";
function _sfc_render58(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-list-item-section", _ctx.computedClass])
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var _VaListItemSection = _export_sfc(_sfc_main61, [["render", _sfc_render58]]);

// node_modules/vuestic-ui/dist/es/src/components/va-list/VaListSeparator.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaListSeparator.css";
var _sfc_main62 = defineComponent({
  name: "VaListSeparator",
  props: {
    ...useComponentPresetProp,
    fit: { type: Boolean, default: false },
    spaced: { type: Boolean, default: false }
  },
  setup(props2) {
    const computedClass = computed(() => ({
      "va-list-separator--offset": !props2.fit,
      "va-list-separator--spaced": props2.spaced
    }));
    return {
      computedClass
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-list/VaListSeparator.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaListSeparator.css";
function _sfc_render59(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    "aria-hidden": "true",
    class: normalizeClass(["va-list-separator", _ctx.computedClass])
  }, null, 2);
}
var _VaListSeparator = _export_sfc(_sfc_main62, [["render", _sfc_render59]]);

// node_modules/vuestic-ui/dist/es/src/components/va-list/index.js
var VaListItem = withConfigTransport$1(_VaListItem);
var VaListLabel = withConfigTransport$1(_VaListLabel);
var VaListItemLabel = withConfigTransport$1(_VaListItemLabel);
var VaListItemSection = withConfigTransport$1(_VaListItemSection);
var VaListSeparator = withConfigTransport$1(_VaListSeparator);
var VaList = withConfigTransport$1(_VaList);

// node_modules/vuestic-ui/dist/es/src/components/va-progress-bar/VaProgressBar.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaProgressBar.css";
var _sfc_main63 = defineComponent({
  name: "VaProgressBar",
  props: {
    ...useComponentPresetProp,
    modelValue: { type: Number, default: 0 },
    indeterminate: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    size: {
      type: [Number, String],
      default: "medium"
    },
    buffer: { type: Number, default: 100 },
    rounded: { type: Boolean, default: true },
    reverse: { type: Boolean, default: false },
    contentInside: { type: Boolean, default: false },
    showPercent: { type: Boolean, default: false },
    max: { type: Number, default: 100 },
    ariaLabel: { type: String, default: "$t:progressState" }
  },
  setup(props2) {
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const colorComputed = computed(() => getColor(props2.color));
    const { textColorComputed } = useTextColor(colorComputed);
    const isTextSize = computed(() => typeof props2.size === "string" && ["small", "medium", "large"].includes(props2.size));
    const getCSSHeight = () => {
      if (typeof props2.size === "number") {
        return `${props2.size}px`;
      }
      if (isTextSize.value) {
        return;
      }
      return props2.size;
    };
    const { tp } = useTranslation();
    const progressBarValue = computed(() => 100 / props2.max * props2.modelValue);
    return {
      rootClass: computed(() => ({
        "va-progress-bar--square": !props2.rounded,
        [`va-progress-bar--${props2.size}`]: isTextSize.value
      })),
      rooStyle: computed(() => ({
        "--va-progress-bar-color": colorComputed.value,
        "--va-progress-bar-background-color": getHoverColor2(colorComputed.value)
      })),
      wrapperStyle: computed(() => ({
        height: getCSSHeight()
      })),
      bufferStyle: computed(() => ({
        width: `${props2.indeterminate ? 100 : clamp$1(props2.buffer, 0, 100)}%`,
        color: textColorComputed.value,
        [props2.reverse ? "right" : "left"]: 0
      })),
      progressStyle: computed(() => ({
        marginLeft: props2.reverse ? "auto" : void 0,
        width: `${clamp$1(progressBarValue.value, 0, 100)}%`
      })),
      intermediateStyle: computed(() => ({
        animationDirection: props2.reverse ? "reverse" : "normal"
      })),
      ariaAttributesComputed: computed(() => ({
        role: "progressbar",
        "aria-label": tp(props2.ariaLabel),
        "aria-valuenow": !props2.indeterminate ? props2.modelValue : void 0
      }))
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-progress-bar/VaProgressBar.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaProgressBar.css";
var _hoisted_133 = {
  key: 0,
  class: "va-progress-bar__info"
};
function _sfc_render60(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    class: ["va-progress-bar", _ctx.rootClass],
    style: _ctx.rooStyle
  }, _ctx.ariaAttributesComputed), [
    !_ctx.$props.contentInside ? (openBlock(), createElementBlock("div", _hoisted_133, [
      renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ value: _ctx.$props.modelValue })), () => [
        _ctx.$props.showPercent ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createTextVNode(toDisplayString(_ctx.$props.modelValue) + "% ", 1)
        ], 64)) : createCommentVNode("", true)
      ])
    ])) : createCommentVNode("", true),
    createBaseVNode("div", {
      class: "va-progress-bar__wrapper",
      style: normalizeStyle(_ctx.wrapperStyle)
    }, [
      createBaseVNode("div", {
        class: "va-progress-bar__buffer",
        style: normalizeStyle(_ctx.bufferStyle)
      }, [
        _ctx.$props.contentInside ? renderSlot(_ctx.$slots, "default", normalizeProps(mergeProps({ key: 0 }, { value: _ctx.$props.modelValue })), () => [
          _ctx.$props.showPercent ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString(_ctx.$props.modelValue) + "% ", 1)
          ], 64)) : createCommentVNode("", true)
        ]) : createCommentVNode("", true)
      ], 4),
      _ctx.indeterminate ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createBaseVNode("div", {
          class: "va-progress-bar__progress--indeterminate-start",
          style: normalizeStyle(_ctx.intermediateStyle)
        }, null, 4),
        createBaseVNode("div", {
          class: "va-progress-bar__progress--indeterminate-end",
          style: normalizeStyle(_ctx.intermediateStyle)
        }, null, 4)
      ], 64)) : (openBlock(), createElementBlock("div", {
        key: 1,
        class: "va-progress-bar__progress",
        style: normalizeStyle(_ctx.progressStyle)
      }, null, 4))
    ], 4)
  ], 16);
}
var _VaProgressBar = _export_sfc(_sfc_main63, [["render", _sfc_render60]]);

// node_modules/vuestic-ui/dist/es/src/components/va-progress-bar/index.js
var VaProgressBar = withConfigTransport$1(_VaProgressBar);

// node_modules/vuestic-ui/dist/es/src/composables/useStrictInject.js
var useStrictInject = (injectionSymbol, errorMessage) => {
  const strictInjection = inject(injectionSymbol);
  if (!strictInjection) {
    throw new Error(errorMessage);
  }
  return strictInjection;
};

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadUndo/VaFileUploadUndo.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaFileUploadUndo.css";
var INJECTION_ERROR_MESSAGE = "The VaFileUploadUndo component should be used in the context of VaFileUpload component";
var _sfc_main64 = defineComponent({
  name: "VaFileUploadUndo",
  components: {
    VaProgressBar,
    VaButton
  },
  props: {
    vertical: { type: Boolean, default: false }
  },
  emits: ["recover"],
  setup: (props2) => {
    const progress = ref(100);
    const {
      undoDuration,
      undoButtonText,
      deletedFileMessage
    } = useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE);
    const computedClasses = useBem("va-file-upload-undo", () => ({
      vertical: props2.vertical
    }));
    const undoDurationStyle = computed(() => `${undoDuration.value ?? 0}ms`);
    onMounted(() => {
      const timer = setTimeout(() => {
        progress.value = 0;
        clearTimeout(timer);
      }, 0);
    });
    return {
      progress,
      undoDuration,
      undoButtonText,
      computedClasses,
      undoDurationStyle,
      deletedFileMessage
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadUndo/VaFileUploadUndo.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaFileUploadUndo.css";
var _hoisted_134 = { class: "va-file-upload-undo__text" };
function _sfc_render61(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_progress_bar = resolveComponent("va-progress-bar");
  const _component_va_button = resolveComponent("va-button");
  return openBlock(), createElementBlock(Fragment, null, [
    createVNode(_component_va_progress_bar, {
      "model-value": _ctx.progress,
      rounded: false,
      class: "va-file-upload-undo-progress-bar",
      style: normalizeStyle(`--va-undo-duration-style: ${String(_ctx.undoDurationStyle)}`)
    }, null, 8, ["model-value", "style"]),
    createBaseVNode("div", {
      class: normalizeClass(["va-file-upload-undo", _ctx.computedClasses]),
      style: normalizeStyle(`--va-undo-duration-style: ${String(_ctx.undoDurationStyle)}`)
    }, [
      createBaseVNode("span", _hoisted_134, toDisplayString(_ctx.deletedFileMessage), 1),
      createVNode(_component_va_button, {
        class: "va-file-upload-undo__button",
        "aria-label": _ctx.undoButtonText,
        size: "small",
        outline: "",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("recover"))
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.undoButtonText), 1)
        ]),
        _: 1
      }, 8, ["aria-label"])
    ], 6)
  ], 64);
}
var _VaFileUploadUndo = _export_sfc(_sfc_main64, [["render", _sfc_render61]]);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadUndo/index.js
var VaFileUploadUndo = withConfigTransport$1(_VaFileUploadUndo);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadListItem/VaFileUploadListItem.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaFileUploadListItem.css";
var INJECTION_ERROR_MESSAGE2 = "The VaFileUploadListItem component should be used in the context of VaFileUpload component";
var _sfc_main65 = defineComponent({
  name: "VaFileUploadListItem",
  components: {
    VaListItem,
    VaListItemSection,
    VaFileUploadUndo,
    VaButton
  },
  emits: ["remove"],
  props: {
    file: { type: Object, default: null },
    color: { type: String, default: "success" },
    ariaRemoveFileLabel: { type: String, default: "$t:removeFile" }
  },
  setup(props2, { emit }) {
    const {
      undo,
      disabled,
      undoDuration
    } = useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE2);
    const { onFocus, onBlur } = useFocus();
    const removed = ref(false);
    const removeFile = () => {
      if (undo.value) {
        removed.value = true;
        setTimeout(() => {
          if (removed.value) {
            emit("remove");
            removed.value = false;
          }
        }, undoDuration.value ?? 0);
      } else {
        emit("remove");
        removed.value = false;
      }
    };
    const recoverFile = () => {
      removed.value = false;
    };
    const computedClasses = useBem("va-file-upload-list-item", () => ({
      undo: removed.value
    }));
    return {
      ...useTranslation(),
      undo,
      removed,
      disabled,
      computedClasses,
      onBlur,
      onFocus,
      removeFile,
      recoverFile
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadListItem/VaFileUploadListItem.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaFileUploadListItem.css";
var _hoisted_135 = { class: "va-file-upload-list-item__content" };
var _hoisted_217 = {
  key: 0,
  class: "va-file-upload-list-item__name"
};
var _hoisted_310 = { class: "va-file-upload-list-item__size" };
function _sfc_render62(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_file_upload_undo = resolveComponent("va-file-upload-undo");
  const _component_va_list_item_section = resolveComponent("va-list-item-section");
  const _component_va_button = resolveComponent("va-button");
  const _component_va_list_item = resolveComponent("va-list-item");
  return openBlock(), createBlock(_component_va_list_item, {
    class: normalizeClass(["va-file-upload-list-item", _ctx.computedClasses]),
    tabindex: "-1",
    disabled: _ctx.disabled,
    "aria-disabled": _ctx.disabled
  }, {
    default: withCtx(() => [
      _ctx.removed && _ctx.undo ? (openBlock(), createBlock(_component_va_list_item_section, { key: 0 }, {
        default: withCtx(() => [
          createVNode(_component_va_file_upload_undo, { onRecover: _ctx.recoverFile }, null, 8, ["onRecover"])
        ]),
        _: 1
      })) : (openBlock(), createBlock(_component_va_list_item_section, { key: 1 }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_135, [
            _ctx.file && _ctx.file.name ? (openBlock(), createElementBlock("div", _hoisted_217, toDisplayString(_ctx.file && _ctx.file.name), 1)) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_310, toDisplayString(_ctx.file && _ctx.file.size), 1),
            !_ctx.disabled ? (openBlock(), createBlock(_component_va_button, {
              key: 1,
              flat: "",
              color: "danger",
              icon: "clear",
              class: "va-file-upload-list-item__delete",
              "aria-label": _ctx.tp(_ctx.$props.ariaRemoveFileLabel),
              onClick: withModifiers(_ctx.removeFile, ["stop"]),
              onKeydown: [
                withKeys(withModifiers(_ctx.removeFile, ["stop"]), ["enter"]),
                withKeys(withModifiers(_ctx.removeFile, ["stop"]), ["space"])
              ],
              onFocus: _ctx.onFocus,
              onBlur: _ctx.onBlur
            }, null, 8, ["aria-label", "onClick", "onKeydown", "onFocus", "onBlur"])) : createCommentVNode("", true)
          ])
        ]),
        _: 1
      }))
    ]),
    _: 1
  }, 8, ["class", "disabled", "aria-disabled"]);
}
var _VaFileUploadListItem = _export_sfc(_sfc_main65, [["render", _sfc_render62]]);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadListItem/index.js
var VaFileUploadListItem = withConfigTransport$1(_VaFileUploadListItem);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadGalleryItem/VaFileUploadGalleryItem.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaFileUploadGalleryItem.css";
var INJECTION_ERROR_MESSAGE3 = "The VaFileUploadGalleryItem component should be used in the context of VaFileUpload component";
var _sfc_main66 = defineComponent({
  name: "VaFileUploadGalleryItem",
  components: {
    VaFileUploadUndo,
    VaButton,
    VaListItem,
    VaListItemSection
  },
  emits: ["remove"],
  props: {
    file: { type: Object, default: null },
    color: { type: String, default: "success" },
    ariaRemoveFileLabel: { type: String, default: "$t:removeFile" }
  },
  setup(props2, { emit }) {
    const {
      undo,
      disabled,
      undoDuration
    } = useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE3);
    const { isFocused, onFocus, onBlur } = useFocus();
    const previewImage = ref("");
    const removed = ref(false);
    const overlayStylesComputed = computed(() => ({
      backgroundColor: colorToRgba(props2.color, 0.7)
    }));
    const classesComputed = useBem("va-file-upload-gallery-item", () => ({
      notImage: !previewImage.value,
      focused: isFocused.value,
      undo: removed.value
    }));
    const removeImage = () => {
      if (undo.value) {
        removed.value = true;
        setTimeout(() => {
          if (!removed.value) {
            return;
          }
          emit("remove");
          removed.value = false;
        }, undoDuration.value ?? 0);
      } else {
        emit("remove");
        removed.value = false;
      }
    };
    const recoverImage = () => {
      removed.value = false;
    };
    const convertToImg = () => {
      if (!props2.file.name || !props2.file.image) {
        return;
      }
      if (props2.file.image.url) {
        previewImage.value = props2.file.image.url;
      } else if (props2.file.image instanceof File) {
        const reader = new FileReader();
        reader.readAsDataURL(props2.file.image);
        reader.onload = (e2) => {
          var _a2, _b;
          if (((_a2 = e2.target) == null ? void 0 : _a2.result).includes("image")) {
            previewImage.value = (_b = e2.target) == null ? void 0 : _b.result;
          }
        };
      }
    };
    onMounted(convertToImg);
    watch(() => props2.file, convertToImg);
    const { t: t2, tp } = useTranslation();
    const { textColorComputed } = useTextColor(toRef(props2, "color"));
    return {
      t: t2,
      tp,
      undo,
      textColorComputed,
      removed,
      disabled,
      isFocused,
      previewImage,
      classesComputed,
      overlayStylesComputed,
      onBlur,
      onFocus,
      removeImage,
      recoverImage
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadGalleryItem/VaFileUploadGalleryItem.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaFileUploadGalleryItem.css";
var _hoisted_136 = ["src", "alt"];
var _hoisted_218 = { class: "va-file-upload-gallery-item__overlay" };
var _hoisted_311 = ["title"];
function _sfc_render63(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_file_upload_undo = resolveComponent("va-file-upload-undo");
  const _component_va_list_item_section = resolveComponent("va-list-item-section");
  const _component_va_button = resolveComponent("va-button");
  const _component_va_list_item = resolveComponent("va-list-item");
  return openBlock(), createBlock(_component_va_list_item, {
    class: normalizeClass(["va-file-upload-gallery-item", _ctx.classesComputed]),
    tabindex: "-1",
    disabled: _ctx.disabled,
    "aria-disabled": _ctx.disabled,
    onFocus: _ctx.onFocus,
    onBlur: _ctx.onBlur
  }, {
    default: withCtx(() => [
      _ctx.removed && _ctx.undo ? (openBlock(), createBlock(_component_va_list_item_section, { key: 0 }, {
        default: withCtx(() => [
          createVNode(_component_va_file_upload_undo, {
            vertical: "",
            onRecover: _ctx.recoverImage
          }, null, 8, ["onRecover"])
        ]),
        _: 1
      })) : (openBlock(), createBlock(_component_va_list_item_section, { key: 1 }, {
        default: withCtx(() => [
          _ctx.previewImage ? (openBlock(), createElementBlock("img", {
            key: 0,
            src: _ctx.previewImage,
            alt: _ctx.file.name || "",
            class: "va-file-upload-gallery-item__image"
          }, null, 8, _hoisted_136)) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_218, [
            createBaseVNode("div", {
              class: "va-file-upload-gallery-item__overlay-background",
              style: normalizeStyle(_ctx.overlayStylesComputed)
            }, null, 4),
            _ctx.file && _ctx.file.name ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "va-file-upload-gallery-item__name",
              title: _ctx.file.name,
              style: normalizeStyle({ color: _ctx.textColorComputed })
            }, toDisplayString(_ctx.file.name), 13, _hoisted_311)) : createCommentVNode("", true),
            !_ctx.disabled ? (openBlock(), createBlock(_component_va_button, {
              key: 1,
              flat: "",
              color: "danger",
              icon: "va-delete",
              class: "va-file-upload-gallery-item__delete",
              "aria-label": _ctx.tp(_ctx.$props.ariaRemoveFileLabel),
              onClick: _ctx.removeImage,
              onFocus: _ctx.onFocus,
              onBlur: _ctx.onBlur
            }, null, 8, ["aria-label", "onClick", "onFocus", "onBlur"])) : createCommentVNode("", true)
          ])
        ]),
        _: 1
      }))
    ]),
    _: 1
  }, 8, ["class", "disabled", "aria-disabled", "onFocus", "onBlur"]);
}
var _VaFileUploadGalleryItem = _export_sfc(_sfc_main66, [["render", _sfc_render63]]);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadGalleryItem/index.js
var VaFileUploadGalleryItem = withConfigTransport$1(_VaFileUploadGalleryItem);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadSingleItem/VaFileUploadSingleItem.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaFileUploadSingleItem.css";
var INJECTION_ERROR_MESSAGE4 = "The VaFileUploadSingleItem component should be used in the context of VaFileUpload component";
var _sfc_main67 = defineComponent({
  name: "VaFileUploadSingleItem",
  components: {
    VaButton,
    VaListItem,
    VaListItemSection
  },
  emits: ["remove"],
  props: {
    file: { type: Object, default: null },
    ariaRemoveFileLabel: { type: String, default: "$t:removeFile" }
  },
  setup() {
    const { t: t2, tp } = useTranslation();
    const { disabled } = useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE4);
    return {
      disabled,
      t: t2,
      tp
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadSingleItem/VaFileUploadSingleItem.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaFileUploadSingleItem.css";
var _hoisted_137 = { class: "va-file-upload-single-item__name" };
function _sfc_render64(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_list_item_section = resolveComponent("va-list-item-section");
  const _component_va_list_item = resolveComponent("va-list-item");
  return openBlock(), createBlock(_component_va_list_item, {
    disabled: _ctx.disabled,
    "aria-disabled": _ctx.disabled,
    class: "va-file-upload-single-item",
    tabindex: "-1"
  }, {
    default: withCtx(() => [
      createVNode(_component_va_list_item_section, { class: "va-file-upload-single-item__content" }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_137, toDisplayString(_ctx.file && _ctx.file.name), 1),
          !_ctx.disabled ? (openBlock(), createBlock(_component_va_button, {
            key: 0,
            class: "va-file-upload-single-item__button",
            "aria-label": _ctx.tp(_ctx.$props.ariaRemoveFileLabel),
            size: "small",
            color: "danger",
            preset: "secondary",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("remove"))
          }, {
            default: withCtx(() => [
              createTextVNode(" Delete ")
            ]),
            _: 1
          }, 8, ["aria-label"])) : createCommentVNode("", true)
        ]),
        _: 1
      })
    ]),
    _: 1
  }, 8, ["disabled", "aria-disabled"]);
}
var _VaFileUploadSingleItem = _export_sfc(_sfc_main67, [["render", _sfc_render64]]);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadSingleItem/index.js
var VaFileUploadSingleItem = withConfigTransport$1(_VaFileUploadSingleItem);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadList/VaFileUploadList.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaFileUploadList.css";
var VaFileUploadGalleryItemProps = extractComponentProps(VaFileUploadGalleryItem);
var VaFileUploadListItemProps = extractComponentProps(VaFileUploadListItem);
var VaFileUploadSingleItemProps = extractComponentProps(VaFileUploadSingleItem);
var _sfc_main68 = defineComponent({
  name: "VaFileUploadList",
  components: {
    VaList,
    VaFileUploadListItem,
    VaFileUploadGalleryItem,
    VaFileUploadSingleItem
  },
  emits: ["remove", "removeSingle"],
  props: {
    type: { type: String, default: "" },
    files: { type: Array, default: null },
    ...VaFileUploadGalleryItemProps,
    ...VaFileUploadListItemProps,
    ...VaFileUploadSingleItemProps
  },
  setup(props2) {
    const filesList = computed(() => props2.files.map(convertFile));
    const convertFile = (file) => ({
      name: file.name || file.url || "",
      size: formatSize(file.size),
      date: formatDate(/* @__PURE__ */ new Date()),
      image: file
    });
    const formatSize = (bytes) => {
      if (bytes === 0) {
        return "0 Bytes";
      }
      if (!bytes) {
        return "";
      }
      const k2 = 1024;
      const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
      const i2 = Math.floor(Math.log(bytes) / Math.log(k2));
      return parseFloat((bytes / Math.pow(k2, i2)).toFixed(2)) + " " + sizes[i2];
    };
    const formatDate = (date = /* @__PURE__ */ new Date()) => {
      return date.toLocaleDateString("en-US", {
        hour: "2-digit",
        minute: "2-digit",
        month: "short",
        day: "numeric",
        year: "numeric"
      });
    };
    return {
      galleryItemProps: filterComponentProps(VaFileUploadGalleryItemProps),
      itemProps: filterComponentProps(VaFileUploadListItemProps),
      singleItemProps: filterComponentProps(VaFileUploadSingleItemProps),
      filesList
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadList/VaFileUploadList.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaFileUploadList.css";
function _sfc_render65(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_file_upload_list_item = resolveComponent("va-file-upload-list-item");
  const _component_va_file_upload_gallery_item = resolveComponent("va-file-upload-gallery-item");
  const _component_va_file_upload_single_item = resolveComponent("va-file-upload-single-item");
  const _component_va_list = resolveComponent("va-list");
  return openBlock(), createBlock(_component_va_list, {
    class: normalizeClass(["va-file-upload-list", `va-file-upload-list--${_ctx.type}`]),
    role: _ctx.type !== "single" ? "list" : void 0
  }, {
    default: withCtx(() => [
      _ctx.type === "list" ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.filesList, (file, index) => {
        return openBlock(), createBlock(_component_va_file_upload_list_item, mergeProps({
          key: file.name
        }, _ctx.itemProps, {
          file,
          role: "listitem",
          onRemove: ($event) => _ctx.$emit("remove", index)
        }), null, 16, ["file", "onRemove"]);
      }), 128)) : createCommentVNode("", true),
      _ctx.type === "gallery" ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.filesList, (file, index) => {
        return openBlock(), createBlock(_component_va_file_upload_gallery_item, mergeProps(_ctx.galleryItemProps, {
          key: file.name,
          file,
          role: "listitem",
          onRemove: ($event) => _ctx.$emit("remove", index)
        }), null, 16, ["file", "onRemove"]);
      }), 128)) : createCommentVNode("", true),
      _ctx.type === "single" && _ctx.filesList.length ? (openBlock(), createBlock(_component_va_file_upload_single_item, mergeProps({ key: 2 }, _ctx.singleItemProps, {
        file: _ctx.filesList[_ctx.filesList.length - 1],
        onRemove: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("removeSingle"))
      }), null, 16, ["file"])) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["role", "class"]);
}
var _VaFileUploadList = _export_sfc(_sfc_main68, [["render", _sfc_render65]]);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadList/index.js
var VaFileUploadList = withConfigTransport$1(_VaFileUploadList);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUpload.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaFileUpload.css";
var VaFileUploadListProps = extractComponentProps(VaFileUploadList);
var _sfc_main69 = defineComponent({
  name: "VaFileUpload",
  components: {
    VaModal,
    VaButton,
    VaFileUploadList
  },
  props: {
    ...useComponentPresetProp,
    ...VaFileUploadListProps,
    fileTypes: { type: String, default: "" },
    dropzone: { type: Boolean, default: false },
    hideFileList: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    disabled: { type: Boolean, default: false },
    undo: { type: Boolean, default: false },
    undoDuration: { type: Number, default: 3e3 },
    undoButtonText: { type: String, default: "$t:undo" },
    dropZoneText: { type: String, default: "$t:dropzone" },
    uploadButtonText: { type: String, default: "$t:uploadFile" },
    deletedFileMessage: { type: String, default: "$t:fileDeleted" },
    modelValue: {
      type: [Object, Array],
      default: () => []
    },
    type: {
      type: String,
      default: "list",
      validator: (value) => ["list", "gallery", "single"].includes(value)
    }
  },
  emits: ["update:modelValue", "file-removed", "file-added"],
  setup(props2, { emit }) {
    const fileInputRef = shallowRef();
    const modal = ref(false);
    const dropzoneHighlight = ref(false);
    const { getColor, shiftHSLAColor: shiftHSLAColor2 } = useColors();
    const colorComputed = computed(() => getColor(props2.color));
    const computedStyle = computed(() => ({
      backgroundColor: props2.dropzone ? shiftHSLAColor2(colorComputed.value, { a: dropzoneHighlight.value ? -0.82 : -0.92 }) : "transparent"
    }));
    const computedClasses = useBem("va-file-upload", () => ({
      dropzone: props2.dropzone,
      disabled: props2.disabled
    }));
    const files = computed({
      get() {
        return Array.isArray(props2.modelValue) ? props2.modelValue : [props2.modelValue];
      },
      set(files2) {
        if (props2.type === "single") {
          emit("update:modelValue", files2[0]);
        } else {
          emit("update:modelValue", files2);
        }
      }
    });
    const filterInvalidFiles = (files2) => files2.filter((file) => {
      const fileName = file.name || file.url;
      if (!fileName) {
        return false;
      }
      if (file.url) {
        return true;
      }
      const MIMETypes = ["audio/*", "video/*", "image/*"];
      const isContainedMIMEType = MIMETypes.find((t2) => props2.fileTypes.includes(t2));
      if (isContainedMIMEType) {
        return true;
      }
      const extension = fileName.substring(fileName.lastIndexOf(".") + 1).toLowerCase();
      const isCorrectExt = props2.fileTypes.includes(extension);
      if (!isCorrectExt) {
        modal.value = true;
      }
      return isCorrectExt;
    });
    const uploadFile = (e2) => {
      var _a2, _b;
      const f2 = ((_a2 = e2.target) == null ? void 0 : _a2.files) || ((_b = e2.dataTransfer) == null ? void 0 : _b.files);
      if (!f2) {
        return;
      }
      const validatedFiles = props2.fileTypes ? filterInvalidFiles(Array.from(f2)) : f2;
      files.value = props2.type === "single" ? validatedFiles : [...files.value, ...validatedFiles];
      emit("file-added", validatedFiles);
    };
    const changeFieldValue = (e2) => {
      uploadFile(e2);
      if (fileInputRef.value) {
        fileInputRef.value.value = "";
      }
    };
    const removeFile = (index) => {
      if (index in files.value) {
        const removedFile = files.value[index];
        files.value = files.value.filter((item, idx) => idx !== index);
        emit("file-removed", removedFile);
      }
    };
    const removeSingleFile = () => {
      if (files.value.length > 0) {
        const removedFile = files.value[0];
        files.value = [];
        emit("file-removed", removedFile);
      }
    };
    const callFileDialogue = () => {
      if (fileInputRef.value) {
        fileInputRef.value.click();
      }
    };
    onMounted(() => {
      if (Array.isArray(files.value)) {
        const filteredFiles = filterInvalidFiles(files.value);
        if (filteredFiles.length !== files.value.length) {
          files.value = filteredFiles;
        }
      }
    });
    const { tp } = useTranslation();
    provide(VaFileUploadKey, {
      undo: toRef(props2, "undo"),
      disabled: toRef(props2, "disabled"),
      undoDuration: toRef(props2, "undoDuration"),
      undoButtonText: computed(() => tp(props2.undoButtonText)),
      deletedFileMessage: computed(() => tp(props2.deletedFileMessage))
    });
    return {
      fileUploadListProps: filterComponentProps(VaFileUploadListProps),
      modal,
      dropzoneHighlight,
      fileInputRef,
      colorComputed,
      computedStyle,
      computedClasses,
      files,
      tp,
      uploadFile,
      changeFieldValue,
      removeFile,
      removeSingleFile,
      callFileDialogue
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUpload.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaFileUpload.css";
var _hoisted_138 = { class: "va-file-upload__field" };
var _hoisted_219 = {
  key: 0,
  class: "va-file-upload__field__text"
};
var _hoisted_312 = ["accept", "multiple", "disabled"];
function _sfc_render66(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_file_upload_list = resolveComponent("va-file-upload-list");
  const _component_va_modal = resolveComponent("va-modal");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-file-upload", _ctx.computedClasses]),
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      createBaseVNode("div", _hoisted_138, [
        _ctx.dropzone ? (openBlock(), createElementBlock("div", _hoisted_219, toDisplayString(_ctx.tp(_ctx.dropZoneText)), 1)) : createCommentVNode("", true),
        createVNode(_component_va_button, {
          class: "va-file-upload__field__button",
          disabled: _ctx.disabled,
          "aria-disabled": _ctx.disabled,
          color: _ctx.colorComputed,
          style: normalizeStyle({ "pointer-events": _ctx.dropzoneHighlight ? "none" : void 0 }),
          onChange: _ctx.changeFieldValue,
          onClick: _ctx.callFileDialogue
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.tp(_ctx.uploadButtonText)), 1)
          ]),
          _: 1
        }, 8, ["disabled", "aria-disabled", "color", "style", "onChange", "onClick"])
      ])
    ]),
    createBaseVNode("input", {
      ref: "fileInputRef",
      type: "file",
      class: "va-file-upload__field__input",
      tabindex: -1,
      "aria-hidden": "true",
      accept: _ctx.fileTypes,
      multiple: _ctx.type !== "single",
      disabled: _ctx.disabled,
      onChange: _cache[0] || (_cache[0] = (...args) => _ctx.changeFieldValue && _ctx.changeFieldValue(...args)),
      onDragenter: _cache[1] || (_cache[1] = ($event) => _ctx.dropzoneHighlight = true),
      onDragleave: _cache[2] || (_cache[2] = ($event) => _ctx.dropzoneHighlight = false)
    }, null, 40, _hoisted_312),
    _ctx.files.length && !_ctx.$props.hideFileList ? (openBlock(), createBlock(_component_va_file_upload_list, mergeProps({ key: 0 }, _ctx.fileUploadListProps, {
      type: _ctx.type,
      files: _ctx.files,
      color: _ctx.colorComputed,
      onRemove: _ctx.removeFile,
      onRemoveSingle: _ctx.removeSingleFile
    }), null, 16, ["type", "files", "color", "onRemove", "onRemoveSingle"])) : createCommentVNode("", true),
    createVNode(_component_va_modal, {
      modelValue: _ctx.modal,
      "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.modal = $event),
      "hide-default-actions": "",
      title: "File validation",
      message: "File type is incorrect!"
    }, null, 8, ["modelValue"])
  ], 6);
}
var _VaFileUpload = _export_sfc(_sfc_main69, [["render", _sfc_render66]]);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/index.js
var VaFileUpload = withConfigTransport$1(_VaFileUpload);

// node_modules/vuestic-ui/dist/es/src/composables/useForm/useFormParent.js
var createFormContext = (options) => {
  const fields = ref(/* @__PURE__ */ new Map());
  return {
    // Vue unwrap ref automatically, but types are not for some reason
    immediate: computed(() => options.immediate),
    fields: computed(() => [...fields.value.values()]),
    doShowError: computed(() => !options.hideErrors),
    doShowErrorMessages: computed(() => !options.hideErrorMessages),
    doShowLoading: computed(() => !options.hideLoading),
    isFormDirty: ref(false),
    registerField: (uid, field) => {
      fields.value.set(uid, field);
    },
    unregisterField: (uid) => {
      fields.value.delete(uid);
    }
  };
};
var useFormParent = (options) => {
  const formContext = createFormContext(options);
  provide(FormServiceKey, formContext);
  const { fields, isFormDirty } = formContext;
  const fieldNames = computed(() => fields.value.map((field) => unref(field.name)).filter(Boolean));
  const fieldsNamed = computed(() => fields.value.reduce((acc, field) => {
    if (unref(field.name)) {
      acc[unref(field.name)] = field;
    }
    return acc;
  }, {}));
  const formData = computed(() => fields.value.reduce((acc, field) => {
    if (unref(field.name)) {
      acc[unref(field.name)] = field.value;
    }
    return acc;
  }, {}));
  const isValid = computed(() => fields.value.every((field) => unref(field.isValid)));
  const isLoading = computed(() => fields.value.some((field) => unref(field.isLoading)));
  const isDirty = computed({
    get() {
      return fields.value.some((field) => unref(field.isLoading)) || isFormDirty.value;
    },
    set(v2) {
      isFormDirty.value = v2;
    }
  });
  const errorMessages = computed(() => fields.value.map((field) => unref(field.errorMessages)).flat());
  const errorMessagesNamed = computed(() => fields.value.reduce((acc, field) => {
    if (unref(field.name)) {
      acc[unref(field.name)] = unref(field.errorMessages);
    }
    return acc;
  }, {}));
  const validate = () => {
    isDirty.value = true;
    return fields.value.reduce((acc, field) => {
      return field.validate() && acc;
    }, true);
  };
  const validateAsync = () => {
    isDirty.value = true;
    return Promise.all(fields.value.map((field) => field.validateAsync())).then((results) => {
      return results.every(Boolean);
    });
  };
  const reset = () => {
    isDirty.value = false;
    fields.value.forEach((field) => field.reset());
  };
  const resetValidation = () => {
    isDirty.value = false;
    fields.value.forEach((field) => field.resetValidation());
  };
  const focus = () => {
    var _a2;
    (_a2 = fields.value[0]) == null ? void 0 : _a2.focus();
  };
  const focusInvalidField = () => {
    const invalidField = fields.value.find((field) => !field.isValid);
    invalidField == null ? void 0 : invalidField.focus();
  };
  useFormChild({
    name: ref(void 0),
    isValid,
    isLoading,
    isDirty,
    validate,
    validateAsync,
    reset,
    resetValidation,
    focus,
    errorMessages
  });
  return {
    immediate: computed(() => options.immediate),
    isDirty,
    formData,
    fields,
    fieldsNamed,
    fieldNames,
    isValid,
    isLoading,
    errorMessages,
    errorMessagesNamed,
    validate,
    reset,
    resetValidation,
    focus,
    focusInvalidField
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-form/VaForm.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaForm.css";
var props = { stateful: true };
var statefulConfig = {
  VaInput: props,
  VaSelect: props,
  VaCheckbox: props,
  VaRadio: props,
  VaDatePicker: props,
  VaTimePicker: props,
  VaColorPicker: props,
  VaSlider: props,
  VaSwitch: props,
  VaFileUpload: props,
  VaRating: props,
  VaDateInput: props,
  VaTimeInput: props
};
var _sfc_main70 = defineComponent({
  name: "VaForm",
  props: {
    ...useComponentPresetProp,
    autofocus: { type: Boolean, default: false },
    immediate: { type: Boolean, default: false },
    tag: { type: String, default: "div" },
    trigger: { type: String, default: "blur" },
    modelValue: { type: Boolean, default: true },
    hideErrors: { type: Boolean, default: false },
    hideErrorMessages: { type: Boolean, default: false },
    hideLoading: { type: Boolean, default: false },
    stateful: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"],
  setup(props2, { emit }) {
    const context = useFormParent(props2);
    watch(context.isValid, (value) => {
      emit("update:modelValue", value);
    });
    watch(() => props2.autofocus, (value) => {
      if (value) {
        context.focus();
      }
    }, { immediate: true });
    watch(context.fields, (newVal) => {
      if (newVal.length && props2.immediate) {
        context.validate();
      }
    }, { immediate: true });
    useLocalConfigProvider(computed(() => {
      if (!props2.stateful) {
        return {};
      }
      return statefulConfig;
    }));
    const {
      immediate,
      isDirty,
      formData,
      fields,
      fieldsNamed,
      fieldNames,
      isValid,
      isLoading,
      errorMessages,
      errorMessagesNamed,
      validate,
      reset,
      resetValidation,
      focus,
      focusInvalidField
    } = context;
    return {
      isDirty,
      formData,
      fields,
      fieldsNamed,
      fieldNames,
      isValid,
      isLoading,
      errorMessages,
      errorMessagesNamed,
      validate,
      reset,
      resetValidation,
      focus,
      focusInvalidField,
      context
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-form/VaForm.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaForm.css";
function _sfc_render67(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), mergeProps({ class: "va-form" }, _ctx.$attrs), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ isValid: _ctx.isValid, validate: _ctx.validate })))
    ]),
    _: 3
  }, 16);
}
var _VaForm = _export_sfc(_sfc_main70, [["render", _sfc_render67]]);

// node_modules/vuestic-ui/dist/es/src/components/va-form/index.js
var VaForm = withConfigTransport$1(_VaForm);

// node_modules/vuestic-ui/dist/es/src/utils/sleep.js
var sleep = (ms = 0) => {
  return new Promise((resolve) => setTimeout(resolve, ms));
};

// node_modules/vuestic-ui/dist/es/src/components/va-infinite-scroll/hooks/useScroll.js
var useScroll = (props2, element, handler) => {
  const addScrollListener = () => {
    var _a2;
    (_a2 = element.value) == null ? void 0 : _a2.addEventListener(
      "scroll",
      handler.value,
      { passive: true }
    );
  };
  const removeScrollListener = () => {
    var _a2;
    (_a2 = element.value) == null ? void 0 : _a2.removeEventListener(
      "scroll",
      handler.value
    );
  };
  onMounted(() => {
    if (!element.value) {
      return;
    }
    element.value.style.overflowY = "scroll";
    if (props2.reverse) {
      element.value.scrollTop = element.value.scrollHeight;
    }
    addScrollListener();
  });
  onBeforeUnmount(removeScrollListener);
  return {
    addScrollListener,
    removeScrollListener
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-infinite-scroll/VaInfiniteScroll.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaInfiniteScroll.css";
var _sfc_main71 = defineComponent({
  name: "VaInfiniteScroll",
  components: { VaProgressCircle },
  props: {
    ...useComponentPresetProp,
    load: { type: Function, required: true },
    offset: { type: Number, default: 500 },
    reverse: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    scrollTarget: { type: [String, Object], default: void 0 },
    debounce: { type: Number, default: 100 },
    tag: { type: String, default: "div" }
  },
  emits: ["onload", "onerror"],
  setup(props2, { emit }) {
    const element = shallowRef();
    const spinnerSlotContainer = shallowRef();
    const fetching = ref(false);
    const error = ref(false);
    const forcedScrolling = ref(false);
    const debouncedLoad = ref();
    const notScrolledContentBeforeLoad = ref(0);
    const prevScrollTop = ref(0);
    const scrollTargetElement = computed(() => {
      var _a2;
      let target;
      if (typeof props2.scrollTarget === "string") {
        target = document.querySelector(props2.scrollTarget);
      } else {
        target = props2.scrollTarget || ((_a2 = element.value) == null ? void 0 : _a2.parentElement);
      }
      return target || document.body;
    });
    const {
      addScrollListener,
      removeScrollListener
    } = useScroll(props2, scrollTargetElement, debouncedLoad);
    const { getColor } = useColors();
    const spinnerColor = computed(() => {
      return error.value ? getColor("danger") : getColor("primary");
    });
    const spinnerHeight = computed(() => {
      var _a2;
      return ((_a2 = spinnerSlotContainer.value) == null ? void 0 : _a2.offsetHeight) || 0;
    });
    const computedOffset = computed(() => {
      return props2.offset + spinnerHeight.value;
    });
    const stop = () => {
      if (props2.disabled) {
        return;
      }
      fetching.value = false;
      removeScrollListener();
    };
    const resume = () => {
      if (props2.disabled) {
        return;
      }
      addScrollListener();
    };
    const onLoad = () => {
      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value;
      notScrolledContentBeforeLoad.value = scrollHeight - scrollTop;
      const scrollDelta = scrollTop - prevScrollTop.value;
      prevScrollTop.value = scrollTop;
      if (props2.disabled || error.value || fetching.value) {
        return;
      }
      if (forcedScrolling.value) {
        forcedScrolling.value = false;
        return;
      }
      const isReverseScrollDirection = props2.reverse && scrollDelta > 0 || !props2.reverse && scrollDelta < 0;
      if (isReverseScrollDirection) {
        return;
      }
      const offset2 = props2.reverse ? scrollTop : scrollHeight - scrollTop - clientHeight;
      if (offset2 > computedOffset.value) {
        return;
      }
      fetching.value = true;
      props2.load().then(finishLoading).catch(onError);
    };
    const forceSetScrollTopToTarget = (value) => {
      forcedScrolling.value = true;
      scrollTargetElement.value.scrollTop = value;
    };
    const updateTargetElementScrollTop = () => {
      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value;
      if (props2.reverse) {
        const isScrolledUp = scrollHeight - scrollTop < notScrolledContentBeforeLoad.value;
        const isSpinnerHidden = scrollTop >= spinnerHeight.value;
        if (isScrolledUp && isSpinnerHidden) {
          return;
        }
        scrollHeight - notScrolledContentBeforeLoad.value > spinnerHeight.value ? forceSetScrollTopToTarget(scrollHeight - notScrolledContentBeforeLoad.value) : forceSetScrollTopToTarget(spinnerHeight.value);
      }
      if (!props2.reverse) {
        const isSpinnerHidden = scrollHeight - scrollTop - clientHeight >= spinnerHeight.value;
        !isSpinnerHidden && forceSetScrollTopToTarget(scrollHeight - clientHeight - spinnerHeight.value);
      }
    };
    const finishLoading = () => {
      updateTargetElementScrollTop();
      fetching.value = false;
      emit("onload");
    };
    const stopErrorDisplay = () => {
      updateTargetElementScrollTop();
      forcedScrolling.value = false;
      error.value = false;
      fetching.value = false;
      emit("onerror");
    };
    const onError = () => {
      stop();
      error.value = true;
      sleep(1200).then(stopErrorDisplay).then(resume);
    };
    watch(() => props2.debounce, (value) => {
      debouncedLoad.value = debounce$2(onLoad, value);
    }, { immediate: true });
    watch(() => props2.disabled, (value) => {
      value ? stop() : resume();
    });
    return {
      element,
      spinnerSlotContainer,
      spinnerColor,
      fetching
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-infinite-scroll/VaInfiniteScroll.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaInfiniteScroll.css";
var _hoisted_139 = { class: "va-infinite-scroll__spinner__default" };
function _sfc_render68(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_progress_circle = resolveComponent("va-progress-circle");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.$props.tag), {
    ref: "element",
    role: "feed",
    class: normalizeClass(["va-infinite-scroll", { "va-infinite-scroll--reversed": _ctx.$props.reverse }]),
    "aria-busy": _ctx.fetching
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default"),
      createBaseVNode("div", {
        ref: "spinnerSlotContainer",
        class: normalizeClass(["va-infinite-scroll__spinner", { "va-infinite-scroll__spinner--invisible": !_ctx.fetching }])
      }, [
        !_ctx.$props.disabled ? renderSlot(_ctx.$slots, "loading", { key: 0 }, () => [
          createBaseVNode("div", _hoisted_139, [
            createVNode(_component_va_progress_circle, {
              size: "small",
              thickness: 0.15,
              color: _ctx.spinnerColor,
              indeterminate: ""
            }, null, 8, ["color"])
          ])
        ]) : createCommentVNode("", true)
      ], 2)
    ]),
    _: 3
  }, 8, ["class", "aria-busy"]);
}
var _VaInfiniteScroll = _export_sfc(_sfc_main71, [["render", _sfc_render68]]);

// node_modules/vuestic-ui/dist/es/src/components/va-infinite-scroll/index.js
var VaInfiniteScroll = withConfigTransport$1(_VaInfiniteScroll);

// node_modules/vuestic-ui/dist/es/src/components/va-layout/hooks/useGridTemplateArea.js
var areaIndexes = {
  top: [0, 1, 2],
  left: [0, 3, 6],
  right: [2, 5, 8],
  bottom: [6, 7, 8]
};
var areaElements = ["left", "right", "top", "bottom"];
var useGridTemplateArea = (props2) => {
  const sort = () => {
    return [...areaElements].sort((a2, b2) => {
      return (props2[a2].order ?? 0) - (props2[b2].order ?? 0);
    });
  };
  const applyTemplate = (template, areaIndexes2, areaName) => {
    areaIndexes2.forEach((index) => {
      template[index] = areaName;
    });
  };
  return computed(() => {
    const sorted = sort();
    const template = [
      ".",
      ".",
      ".",
      ".",
      ".",
      ".",
      ".",
      ".",
      "."
    ].map(() => "content");
    sorted.forEach((areaName) => {
      applyTemplate(template, areaIndexes[areaName], areaName);
    });
    return [
      '"' + template.slice(0, 3).join(" ") + '"',
      '"' + template.slice(3, 6).join(" ") + '"',
      '"' + template.slice(6, 9).join(" ") + '"'
    ].join(" ");
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-layout/hooks/useLayout.js
var useLayoutProps = {
  top: {
    type: Object,
    default: () => ({ order: 2 })
  },
  right: {
    type: Object,
    default: () => ({ order: 1 })
  },
  left: {
    type: Object,
    default: () => ({ order: 1 })
  },
  bottom: {
    type: Object,
    default: () => ({ order: 2 })
  }
};
var VaLayoutKey = "VaLayout";
var useLayout = (props2) => {
  const items2 = ref({
    top: null,
    right: null,
    bottom: null,
    left: null
  });
  const paddings = computed(() => {
    const { top, right, bottom, left } = items2.value;
    const { top: topConfig, right: rightConfig, bottom: bottomConfig, left: leftConfig } = props2;
    return {
      top: top && !topConfig.absolute ? top.sizes.height : 0,
      right: right && !rightConfig.absolute ? right.sizes.width : 0,
      bottom: bottom && !bottomConfig.absolute ? bottom.sizes.height : 0,
      left: left && !leftConfig.absolute ? left.sizes.width : 0
    };
  });
  const orders = computed(() => ({
    top: props2.top.order || 0,
    right: props2.right.order || 0,
    bottom: props2.bottom.order || 0,
    left: props2.left.order || 0
  }));
  provide(VaLayoutKey, {
    items: items2,
    paddings,
    orders
  });
  return {
    paddings,
    orders,
    items: items2
  };
};
var useFixedLayoutChild = (area, sizes) => {
  const layout = inject(VaLayoutKey, null);
  if (!layout) {
    throw new Error("VaLayoutChild must be used inside VaLayout");
  }
  watchEffect(() => {
    if (sizes.value) {
      layout.items.value[area] = {
        sizes: sizes.value
      };
    } else {
      layout.items.value[area] = null;
    }
  });
  onBeforeUnmount(() => {
    layout.items.value[area] = null;
  });
  return {
    paddings: computed(() => {
      return Object.keys(layout.paddings.value).reduce((acc, key) => {
        if (layout.orders.value[key] > layout.orders.value[area]) {
          acc[key] = layout.paddings.value[key];
        }
        return acc;
      }, {});
    })
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-layout/components/VaLayoutAbsoluteWrapper.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaLayoutAbsoluteWrapper.css";
var _sfc_main72 = {};
var _hoisted_140 = { class: "va-layout__absolute-area-wrapper" };
function _sfc_render69(_ctx, _cache) {
  return openBlock(), createElementBlock("div", _hoisted_140, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var VaLayoutAbsoluteWrapper = _export_sfc(_sfc_main72, [["render", _sfc_render69]]);

// node_modules/vuestic-ui/dist/es/src/components/va-layout/components/VaResizeObserver.vue_vue_type_script_lang.js
var _sfc_main73 = defineComponent({
  name: "VaLayoutSizeKeeper",
  emits: {
    resize: (size3) => true
  },
  setup(props2, { emit }) {
    const el = ref();
    let observer = null;
    watch(el, (newEl) => {
      if (observer) {
        observer.disconnect();
      }
      observer = new ResizeObserver(([el2]) => {
        emit("resize", el2.contentRect);
      });
      observer.observe(newEl);
    });
    return {
      el
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-layout/components/VaResizeObserver.js
var _hoisted_141 = {
  class: "va-resize-observer",
  ref: "el"
};
function _sfc_render70(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_141, [
    renderSlot(_ctx.$slots, "default")
  ], 512);
}
var VaResizeObserver = _export_sfc(_sfc_main73, [["render", _sfc_render70]]);

// node_modules/vuestic-ui/dist/es/src/components/va-layout/components/VaLayoutFixedWrapper.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaLayoutFixedWrapper.css";
var _sfc_main74 = defineComponent({
  name: "VaLayoutFixedWrapper",
  components: { VaResizeObserver },
  props: {
    area: { type: String, required: true }
  },
  setup(props2) {
    const size3 = ref(null);
    const direction = computed(() => {
      if (props2.area === "top" || props2.area === "bottom") {
        return "vertical";
      } else {
        return "horizontal";
      }
    });
    const getPxOrZero = (value) => {
      if (!value) {
        return "0px";
      }
      return value + "px";
    };
    const styles = computed(() => {
      if (direction.value === "vertical") {
        return { width: `calc(100% - ${getPxOrZero(paddings.value.left)} - ${getPxOrZero(paddings.value.right)})`, [props2.area]: 0 };
      } else {
        return { height: `calc(100% - ${getPxOrZero(paddings.value.top)} - ${getPxOrZero(paddings.value.bottom)})`, [props2.area]: 0 };
      }
    });
    const { paddings } = useFixedLayoutChild(props2.area, size3);
    const computedStyle = computed(() => {
      return Object.keys(paddings.value).reduce((acc, key) => {
        if (key === props2.area) {
          return acc;
        }
        return {
          ...acc,
          [key]: `${paddings.value[key]}px`
        };
      }, {});
    });
    return {
      direction,
      computedStyle,
      paddings,
      size: size3,
      styles
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-layout/components/VaLayoutFixedWrapper.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaLayoutFixedWrapper.css";
function _sfc_render71(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaResizeObserver = resolveComponent("VaResizeObserver");
  return openBlock(), createElementBlock("div", {
    class: "va-layout-fixed-wrapper",
    style: normalizeStyle([[{
      height: _ctx.size && _ctx.direction === "vertical" ? _ctx.size.height + "px" : "auto",
      width: _ctx.size && _ctx.direction === "horizontal" ? _ctx.size.width + "px" : "auto"
    }], `--va-styles-width: ${String(_ctx.styles.width)};--va-styles-height: ${String(_ctx.styles.height)}`])
  }, [
    createVNode(_component_VaResizeObserver, {
      class: normalizeClass(["va-layout-fixed-wrapper__content", `va-layout-fixed-wrapper__content--${_ctx.area}`]),
      onResize: _cache[0] || (_cache[0] = ($event) => _ctx.size = $event)
    }, {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"])
  ], 4);
}
var VaLayoutFixedWrapper = _export_sfc(_sfc_main74, [["render", _sfc_render71]]);

// node_modules/vuestic-ui/dist/es/src/components/va-layout/components/VaLayoutArea.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaLayoutArea.css";
var _sfc_main75 = defineComponent({
  name: "VaLayoutArea",
  components: {
    VaLayoutAbsoluteWrapper,
    VaLayoutFixedWrapper
  },
  props: {
    area: { type: String, required: true },
    config: { type: Object, required: true }
  },
  emits: ["overlay-click"],
  setup(props2) {
    return {
      absolute: computed(() => props2.config.absolute || false),
      fixed: computed(() => props2.config.fixed || false),
      overlay: computed(() => props2.config.overlay || false),
      // Content z-index is always 0, other areas must have bigger z-index by 1
      zIndex: computed(() => (props2.config.order || 0) + 1)
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-layout/components/VaLayoutArea.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaLayoutArea.css";
function _sfc_render72(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaLayoutFixedWrapper = resolveComponent("VaLayoutFixedWrapper");
  const _component_VaLayoutAbsoluteWrapper = resolveComponent("VaLayoutAbsoluteWrapper");
  return openBlock(), createElementBlock(Fragment, null, [
    _ctx.absolute ? (openBlock(), createBlock(_component_VaLayoutAbsoluteWrapper, {
      key: 0,
      style: normalizeStyle(`--va-props-area: ${String(_ctx.$props.area)};--va-z-index: ${String(_ctx.zIndex)};--va-z-index-1: ${String(_ctx.zIndex - 1)}`)
    }, {
      default: withCtx(() => [
        createBaseVNode("div", {
          class: normalizeClass(`va-layout-area va-layout__area va-layout__area--${_ctx.area}`)
        }, [
          _ctx.fixed ? (openBlock(), createBlock(_component_VaLayoutFixedWrapper, {
            key: 0,
            area: _ctx.area
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["area"])) : renderSlot(_ctx.$slots, "default", { key: 1 })
        ], 2)
      ]),
      _: 3
    }, 8, ["style"])) : (openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass(`va-layout-area va-layout__area va-layout__area--${_ctx.area}`),
      style: normalizeStyle(`--va-props-area: ${String(_ctx.$props.area)};--va-z-index: ${String(_ctx.zIndex)};--va-z-index-1: ${String(_ctx.zIndex - 1)}`)
    }, [
      _ctx.fixed ? (openBlock(), createBlock(_component_VaLayoutFixedWrapper, {
        key: 0,
        area: _ctx.area
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["area"])) : renderSlot(_ctx.$slots, "default", { key: 1 })
    ], 6)),
    createVNode(Transition, {
      style: normalizeStyle(`--va-props-area: ${String(_ctx.$props.area)};--va-z-index: ${String(_ctx.zIndex)};--va-z-index-1: ${String(_ctx.zIndex - 1)}`)
    }, {
      default: withCtx(() => [
        _ctx.overlay ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["va-layout-area__overlay", { "va-layout-area__overlay--fixed": _ctx.fixed }]),
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("overlay-click"))
        }, null, 2)) : createCommentVNode("", true)
      ]),
      _: 1
    }, 8, ["style"])
  ], 64);
}
var VaLayoutArea = _export_sfc(_sfc_main75, [["render", _sfc_render72]]);

// node_modules/vuestic-ui/dist/es/src/components/va-layout/VaLayout.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaLayout.css";
var areaNames = [
  "top",
  "left",
  "right",
  "bottom"
];
var _sfc_main76 = defineComponent({
  name: "VaLayout",
  props: {
    ...useLayoutProps,
    allowBodyScrollOnOverlay: { type: Boolean, default: false }
  },
  emits: [
    "top-overlay-click",
    "left-overlay-click",
    "right-overlay-click",
    "bottom-overlay-click"
  ],
  components: { VaLayoutArea },
  setup(props2, { slots }) {
    const { paddings } = useLayout(props2);
    const doDisableScroll = computed(() => {
      return !props2.allowBodyScrollOnOverlay && areaNames.some((area) => {
        var _a2;
        return (_a2 = props2[area]) == null ? void 0 : _a2.overlay;
      });
    });
    const document2 = useDocument();
    watchEffect(() => {
      var _a2;
      const overflowParent = (_a2 = document2.value) == null ? void 0 : _a2.body;
      if (!overflowParent) {
        return;
      }
      if (doDisableScroll.value) {
        overflowParent.style.overflow = "hidden";
      } else {
        overflowParent.style.overflow = "";
      }
    });
    return {
      areaNames,
      templateArea: useGridTemplateArea(props2),
      verticalTemplate: computed(() => {
        return [
          slots.top ? "min-content" : "0fr",
          "1fr",
          slots.bottom ? "min-content" : "0fr"
        ].filter(Boolean).join(" ");
      }),
      horizontalTemplate: computed(() => {
        return [
          slots.left ? "min-content" : "0fr",
          "1fr",
          slots.right ? "min-content" : "0fr"
        ].filter(Boolean).join(" ");
      }),
      paddings
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-layout/VaLayout.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaLayout.css";
var _hoisted_142 = { class: "va-layout__area va-layout__area--content" };
function _sfc_render73(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaLayoutArea = resolveComponent("VaLayoutArea");
  return openBlock(), createElementBlock("div", {
    class: "va-layout",
    style: normalizeStyle(`--va-horizontal-template: ${String(_ctx.horizontalTemplate)};--va-vertical-template: ${String(_ctx.verticalTemplate)};--va-template-area: ${String(_ctx.templateArea)};--va-paddings-top-px: ${String(_ctx.paddings.top + "px")};--va-paddings-bottom-px: ${String(_ctx.paddings.bottom + "px")};--va-paddings-left-px: ${String(_ctx.paddings.left + "px")};--va-paddings-right-px: ${String(_ctx.paddings.right + "px")}`)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.areaNames, (area) => {
      return openBlock(), createBlock(_component_VaLayoutArea, {
        key: area,
        area,
        config: _ctx.$props[area] || {},
        onOverlayClick: ($event) => _ctx.$emit(`${area}-overlay-click`)
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, area)
        ]),
        _: 2
      }, 1032, ["area", "config", "onOverlayClick"]);
    }), 128)),
    createBaseVNode("div", _hoisted_142, [
      renderSlot(_ctx.$slots, "default", {}, () => [
        renderSlot(_ctx.$slots, "content")
      ])
    ])
  ], 4);
}
var _VaLayout = _export_sfc(_sfc_main76, [["render", _sfc_render73]]);

// node_modules/vuestic-ui/dist/es/src/components/va-layout/index.js
var VaLayout = withConfigTransport(_VaLayout);

// node_modules/vuestic-ui/dist/es/src/components/va-navbar/VaNavbar.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaNavbar.css";
var _sfc_main77 = defineComponent({
  name: "VaNavbar",
  props: {
    ...useFixedBarProps,
    ...useComponentPresetProp,
    color: { type: String, default: "background-secondary" },
    textColor: { type: String },
    shape: { type: Boolean, default: false },
    shadowed: { type: Boolean, default: false },
    bordered: { type: Boolean, default: false }
  },
  setup(props2) {
    const { scrollRoot, isScrolledDown } = setupScroll(props2.fixed);
    const { fixedBarStyleComputed } = useFixedBar(props2, isScrolledDown);
    const { getColor, shiftHSLAColor: shiftHSLAColor2 } = useColors();
    const color = computed(() => getColor(props2.color));
    const { textColorComputed } = useTextColor(color);
    const shapeStyleComputed = computed(() => ({
      borderTopColor: shiftHSLAColor2(color.value, { h: -1, s: -11, l: 10 })
    }));
    const computedStyle = computed(() => ({
      ...fixedBarStyleComputed.value,
      backgroundColor: color.value,
      color: textColorComputed.value,
      fill: textColorComputed.value
    }));
    const bemClasses = useBem("va-navbar", () => ({
      shadowed: props2.shadowed,
      bordered: props2.bordered
    }));
    return {
      bemClasses,
      scrollRoot,
      computedStyle,
      shapeStyleComputed
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-navbar/VaNavbar.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaNavbar.css";
var _hoisted_143 = { class: "va-navbar__left" };
var _hoisted_220 = { class: "va-navbar__center" };
var _hoisted_313 = { class: "va-navbar__right" };
function _sfc_render74(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("header", {
    ref: "scrollRoot",
    class: normalizeClass(["va-navbar", _ctx.bemClasses]),
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      createBaseVNode("div", _hoisted_143, [
        renderSlot(_ctx.$slots, "left")
      ]),
      createBaseVNode("div", _hoisted_220, [
        renderSlot(_ctx.$slots, "center")
      ]),
      createBaseVNode("div", _hoisted_313, [
        renderSlot(_ctx.$slots, "right")
      ])
    ]),
    _ctx.shape ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "va-navbar__background-shape",
      style: normalizeStyle(_ctx.shapeStyleComputed)
    }, null, 4)) : createCommentVNode("", true)
  ], 6);
}
var _VaNavbar = _export_sfc(_sfc_main77, [["render", _sfc_render74]]);

// node_modules/vuestic-ui/dist/es/src/components/va-navbar/VaNavbarItem/VaNavbarItem.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaNavbarItem.css";
var _sfc_main78 = defineComponent({
  name: "VaNavbarItem",
  props: {}
  // TODO: In web components build props are required (it's a vue bug)
});
var _hoisted_144 = { class: "va-navbar__item" };
function _sfc_render75(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_144, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var _VaNavbarItem = _export_sfc(_sfc_main78, [["render", _sfc_render75]]);

// node_modules/vuestic-ui/dist/es/src/components/va-navbar/index.js
var VaNavbar = withConfigTransport$1(_VaNavbar);
var VaNavbarItem = withConfigTransport$1(_VaNavbarItem);

// node_modules/vuestic-ui/dist/es/src/components/va-radio/VaRadio.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaRadio.css";
var _sfc_main79 = defineComponent({
  name: "VaRadio",
  components: { VaMessageListWrapper },
  emits: useSelectableEmits,
  props: {
    ...useSelectableProps,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    modelValue: {
      type: [Boolean, Array, String, Object, Number],
      default: null
    },
    options: {
      type: Array,
      default: () => []
    },
    name: { type: String, default: "" },
    label: { type: String, default: void 0 },
    leftLabel: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    option: {
      type: [Object, String, Number],
      default: void 0
    },
    vertical: { type: Boolean, default: false }
  },
  setup(props2, { emit }) {
    const { getColor } = useColors();
    const elements = {
      container: shallowRef(),
      input: shallowRef(),
      label: shallowRef()
    };
    const {
      computedError,
      computedErrorMessages,
      validationAriaAttributes,
      onBlur,
      onFocus
    } = useSelectable(props2, emit, elements);
    const { getText: originalGetText, getDisabled: originalGetDisabled, getValue: getValue2 } = useSelectableList(props2);
    const getText = (option) => {
      if (props2.options.length > 0) {
        return originalGetText(option);
      }
      return props2.label ?? originalGetText(option);
    };
    const getDisabled = (option) => originalGetDisabled(option) || props2.disabled;
    const isNoOption = computed(() => props2.options.length === 0 && !props2.option);
    const isChecked = (option) => {
      if (isNoOption.value) {
        return props2.modelValue;
      }
      return props2.modelValue === getValue2(option);
    };
    const computedOptions = computed(() => {
      if (isNoOption.value) {
        return [{}];
      }
      if (props2.option) {
        return [props2.option];
      } else {
        return props2.options;
      }
    });
    const radioClass = (option) => ({
      "va-radio--left-label": props2.leftLabel,
      "va-radio--selected": isChecked(option),
      "va-radio--readonly": props2.readonly,
      "va-radio--disabled": props2.disabled,
      "va-radio--indeterminate": props2.indeterminate,
      "va-radio--error": computedError.value,
      "va-radio--single-option": isNoOption.value
    });
    const selectOption = (option, event) => {
      var _a2;
      if (isNoOption.value) {
        emit("update:modelValue", ((_a2 = event == null ? void 0 : event.target) == null ? void 0 : _a2.checked) || false);
        return;
      }
      emit("update:modelValue", option);
    };
    const labelStyle = computed(() => {
      return {
        color: computedError.value ? getColor("danger") : ""
      };
    });
    const inputStyle = computed(() => {
      const style = {
        background: getColor(props2.color),
        borderColor: getColor(props2.color)
      };
      if (computedError.value) {
        style.borderColor = getColor("danger");
      }
      return style;
    });
    const iconBackgroundComputedStyles = computed(() => ({
      backgroundColor: getColor(props2.color)
    }));
    const iconDotComputedStyles = computed(() => {
      return {
        borderColor: computedError.value ? getColor("danger") : getColor(props2.color),
        backgroundColor: getColor(props2.color)
      };
    });
    const iconComputedStyles = computed(() => {
      return { borderColor: computedError.value ? getColor("danger") : getColor(props2.color) };
    });
    const computedName = computed(() => props2.name || generateUniqueId());
    const inputAttributesComputed = (option) => {
      const disabled = getDisabled(option);
      return {
        name: computedName.value,
        disabled,
        readonly: props2.readonly,
        tabindex: disabled ? -1 : 0
      };
    };
    const flexDirection = computed(() => props2.vertical ? "column" : "row");
    return {
      flexDirection,
      getDisabled,
      isChecked,
      computedOptions,
      radioClass,
      labelStyle,
      inputStyle,
      computedError,
      computedErrorMessages,
      iconBackgroundComputedStyles,
      iconDotComputedStyles,
      iconComputedStyles,
      selectOption,
      onFocus,
      onBlur,
      inputAttributesComputed,
      computedName,
      roleComputed: computed(() => {
        var _a2;
        return ((_a2 = props2.options) == null ? void 0 : _a2.length) > 0 ? "radiogroup" : "";
      }),
      getText,
      getValue: getValue2
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-radio/VaRadio.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaRadio.css";
var _hoisted_145 = ["role"];
var _hoisted_221 = ["value", "checked", "aria-checked", "onChange"];
var _hoisted_314 = createBaseVNode("span", {
  "aria-hidden": "true",
  class: "va-radio__icon"
}, [
  createBaseVNode("span", { class: "va-radio__icon__background" }),
  createBaseVNode("span", { class: "va-radio__icon__dot" })
], -1);
function _sfc_render76(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaMessageListWrapper = resolveComponent("VaMessageListWrapper");
  return openBlock(), createBlock(_component_VaMessageListWrapper, {
    disabled: _ctx.disabled,
    success: _ctx.success,
    messages: _ctx.messages,
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages,
    "error-count": _ctx.errorCount,
    onBlur: _ctx.onBlur,
    style: normalizeStyle(`--va-flex-direction: ${String(_ctx.flexDirection)};--va-label-style-color: ${String(_ctx.labelStyle.color)};--va-icon-computed-styles-border-color: ${String(_ctx.iconComputedStyles.borderColor)};--va-icon-dot-computed-styles-border-color: ${String(_ctx.iconDotComputedStyles.borderColor)};--va-icon-dot-computed-styles-background-color: ${String(_ctx.iconDotComputedStyles.backgroundColor)};--va-icon-background-computed-styles-background-color: ${String(_ctx.iconBackgroundComputedStyles.backgroundColor)}`)
  }, {
    default: withCtx(({ ariaAttributes }) => [
      createBaseVNode("div", mergeProps({
        ref: "container",
        class: "va-radio",
        role: _ctx.roleComputed
      }, ariaAttributes), [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.computedOptions, (option, index) => {
          return openBlock(), createElementBlock("label", {
            key: index,
            class: normalizeClass([_ctx.radioClass(option), "va-radio__square"])
          }, [
            createBaseVNode("input", mergeProps({
              ref_for: true,
              ref: "input",
              class: "va-radio__input",
              type: "radio",
              role: "radio",
              value: _ctx.isChecked(option),
              checked: _ctx.isChecked(option),
              "aria-checked": _ctx.isChecked(option)
            }, { ..._ctx.inputAttributesComputed(option), ...ariaAttributes }, {
              onChange: ($event) => _ctx.selectOption(_ctx.getValue(option), $event),
              onFocus: _cache[0] || (_cache[0] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
              onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.onBlur && _ctx.onBlur(...args))
            }), null, 16, _hoisted_221),
            renderSlot(_ctx.$slots, "icon", normalizeProps(guardReactiveProps({
              value: _ctx.isChecked(option),
              text: _ctx.getText(option),
              disabled: _ctx.getDisabled(option),
              index
            })), () => [
              _hoisted_314
            ]),
            _ctx.getText(option) || _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
              key: 0,
              ref_for: true,
              ref: "label",
              class: "va-radio__text"
            }, [
              renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({
                value: _ctx.isChecked(option),
                text: _ctx.getText(option),
                disabled: _ctx.getDisabled(option),
                index
              })), () => [
                createTextVNode(toDisplayString(_ctx.getText(option)), 1)
              ])
            ], 512)) : createCommentVNode("", true)
          ], 2);
        }), 128))
      ], 16, _hoisted_145)
    ]),
    _: 3
  }, 8, ["disabled", "success", "messages", "error", "error-messages", "error-count", "onBlur", "style"]);
}
var _VaRadio = _export_sfc(_sfc_main79, [["render", _sfc_render76]]);

// node_modules/vuestic-ui/dist/es/src/components/va-radio/index.js
var VaRadio = withConfigTransport$1(_VaRadio);

// node_modules/vuestic-ui/dist/es/src/components/va-switch/VaSwitch.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSwitch.css";
var _sfc_main80 = defineComponent({
  name: "VaSwitch",
  components: { VaProgressCircle, VaMessageListWrapper },
  emits: [
    ...useSelectableEmits,
    "focus",
    "blur",
    "update:modelValue"
  ],
  props: {
    ...useSelectableProps,
    ...useComponentPresetProp,
    id: { type: String, default: "" },
    name: { type: String, default: "" },
    modelValue: {
      type: [Number, Boolean, Array, String, Object],
      default: false
    },
    trueLabel: { type: String, default: null },
    falseLabel: { type: String, default: null },
    trueInnerLabel: { type: String, default: null },
    falseInnerLabel: { type: String, default: null },
    ariaLabel: { type: String, default: "$t:switch" },
    color: { type: String, default: "primary" },
    offColor: { type: String, default: "background-element" },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["medium", "small", "large"].includes(value)
    }
  },
  setup(props2, { emit, slots }) {
    const elements = {
      container: shallowRef(),
      input: shallowRef(),
      label: shallowRef()
    };
    const { getColor } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const {
      isChecked,
      computedError,
      isIndeterminate,
      computedErrorMessages,
      validationAriaAttributes,
      toggleSelection,
      onBlur,
      onFocus,
      reset,
      focus
    } = useSelectable(props2, emit, elements);
    const computedBackground = computed(() => getColor(isChecked.value ? props2.color : props2.offColor));
    const { textColorComputed } = useTextColor(computedBackground);
    const computedInnerLabel = computed(() => {
      if (props2.trueInnerLabel && isChecked.value) {
        return props2.trueInnerLabel;
      }
      if (props2.falseInnerLabel && !isChecked.value) {
        return props2.falseInnerLabel;
      }
      return "";
    });
    const computedLabel = computed(() => {
      if (props2.trueLabel && isChecked.value) {
        return props2.trueLabel;
      }
      if (props2.falseLabel && !isChecked.value) {
        return props2.falseLabel;
      }
      return props2.label;
    });
    const computedClass = useBem("va-switch", () => ({
      ...pick$1(props2, ["readonly", "disabled", "leftLabel"]),
      checked: isChecked.value,
      indeterminate: isIndeterminate.value,
      small: props2.size === "small",
      large: props2.size === "large",
      error: computedError.value,
      keyboardFocus: hasKeyboardFocus.value
    }));
    const styleComputed = computed(() => ({
      lineHeight: computedErrorMessages.value.length ? 1 : 0
    }));
    const progressCircleSize = computed(() => {
      const size3 = { small: "15px", medium: "20px", large: "25px" };
      return size3[props2.size];
    });
    const trackStyle = computed(() => ({
      borderColor: computedError.value ? getColor("danger") : "",
      backgroundColor: computedBackground.value
    }));
    const labelStyle = computed(() => ({
      color: computedError.value ? getColor("danger") : ""
    }));
    const trackLabelStyle = computed(() => ({
      color: textColorComputed.value,
      "text-align": isChecked.value ? "left" : "right"
    }));
    const ariaLabelIdComputed = computed(() => `aria-label-id-${generateUniqueId()}`);
    const inputAttributesComputed = computed(() => ({
      id: props2.id || void 0,
      name: props2.name || void 0,
      disabled: props2.disabled,
      readonly: props2.readonly,
      "aria-disabled": props2.disabled,
      "aria-readonly": props2.readonly,
      "aria-checked": !!props2.modelValue,
      "aria-label": !slots.default ? props2.ariaLabel : void 0,
      "aria-labelledby": computedLabel.value || slots.default ? ariaLabelIdComputed.value : void 0,
      tabindex: props2.disabled ? -1 : 0,
      checked: isChecked.value,
      ...validationAriaAttributes.value
    }));
    const onEnterKeyPress = () => {
      var _a2;
      (_a2 = elements.input.value) == null ? void 0 : _a2.click();
    };
    return {
      onEnterKeyPress,
      toggleSelection,
      onBlur,
      onFocus,
      reset,
      focus,
      input: elements.input,
      computedErrorMessages,
      isChecked,
      computedError,
      isIndeterminate,
      keyboardFocusListeners,
      computedInnerLabel,
      computedLabel,
      computedClass,
      styleComputed,
      progressCircleSize,
      trackStyle,
      labelStyle,
      trackLabelStyle,
      ariaLabelIdComputed,
      inputAttributesComputed
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-switch/VaSwitch.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSwitch.css";
var _hoisted_146 = { class: "va-switch__inner" };
var _hoisted_222 = { class: "va-switch__checker-wrapper" };
var _hoisted_315 = { class: "va-switch__checker" };
var _hoisted_48 = { class: "va-switch__checker-circle" };
var _hoisted_57 = ["id"];
function _sfc_render77(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_progress_circle = resolveComponent("va-progress-circle");
  const _component_VaMessageListWrapper = resolveComponent("VaMessageListWrapper");
  return openBlock(), createBlock(_component_VaMessageListWrapper, {
    class: normalizeClass(["va-switch", _ctx.computedClass]),
    style: normalizeStyle(_ctx.styleComputed),
    disabled: _ctx.$props.disabled,
    success: _ctx.$props.success,
    messages: _ctx.$props.messages,
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages,
    "error-count": _ctx.$props.errorCount
  }, {
    default: withCtx(() => [
      createBaseVNode("div", {
        ref: "container",
        class: "va-switch__container",
        tabindex: "-1",
        onBlur: _cache[7] || (_cache[7] = (...args) => _ctx.onBlur && _ctx.onBlur(...args))
      }, [
        createBaseVNode("div", _hoisted_146, [
          createBaseVNode("input", mergeProps({
            ref: "input",
            type: "checkbox",
            class: "va-switch__input",
            role: "switch"
          }, _ctx.inputAttributesComputed, toHandlers(_ctx.keyboardFocusListeners, true), {
            onFocus: _cache[0] || (_cache[0] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
            onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
            onKeypress: _cache[2] || (_cache[2] = withKeys((...args) => _ctx.onEnterKeyPress && _ctx.onEnterKeyPress(...args), ["enter"])),
            onChange: _cache[3] || (_cache[3] = (...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args))
          }), null, 16),
          createBaseVNode("div", {
            class: "va-switch__track",
            "aria-hidden": "true",
            style: normalizeStyle(_ctx.trackStyle)
          }, [
            _ctx.computedInnerLabel || _ctx.$slots.innerLabel ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "va-switch__track-label",
              style: normalizeStyle(_ctx.trackLabelStyle)
            }, [
              renderSlot(_ctx.$slots, "innerLabel", {}, () => [
                createTextVNode(toDisplayString(_ctx.computedInnerLabel), 1)
              ])
            ], 4)) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_222, [
              createBaseVNode("div", _hoisted_315, [
                renderSlot(_ctx.$slots, "checker", normalizeProps(guardReactiveProps({ value: _ctx.isChecked })), () => [
                  createBaseVNode("div", _hoisted_48, [
                    _ctx.$props.loading ? (openBlock(), createBlock(_component_va_progress_circle, {
                      key: 0,
                      indeterminate: "",
                      size: _ctx.progressCircleSize,
                      color: _ctx.trackStyle.backgroundColor
                    }, null, 8, ["size", "color"])) : createCommentVNode("", true)
                  ])
                ])
              ])
            ])
          ], 4)
        ]),
        _ctx.computedLabel || _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
          key: 0,
          ref: "label",
          class: "va-switch__label",
          style: normalizeStyle(_ctx.labelStyle),
          id: _ctx.ariaLabelIdComputed,
          onBlur: _cache[4] || (_cache[4] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
          onClick: _cache[5] || (_cache[5] = (...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args)),
          onKeydown: _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args), ["stop"]), ["enter"]))
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(_ctx.computedLabel), 1)
          ])
        ], 44, _hoisted_57)) : createCommentVNode("", true)
      ], 544)
    ]),
    _: 3
  }, 8, ["class", "style", "disabled", "success", "messages", "error", "error-messages", "error-count"]);
}
var _VaSwitch = _export_sfc(_sfc_main80, [["render", _sfc_render77]]);

// node_modules/vuestic-ui/dist/es/src/components/va-switch/index.js
var VaSwitch = withConfigTransport$1(_VaSwitch);

// node_modules/vuestic-ui/dist/es/src/composables/useArrayRefs.js
var useArrayRefs = () => {
  const itemRefs = shallowRef([]);
  const setItemRef = (el) => {
    if (!el) {
      return;
    }
    itemRefs.value.push(el);
  };
  const setItemRefByIndex = (index) => (el) => {
    if (!el) {
      return;
    }
    itemRefs.value[index] = el;
  };
  onBeforeUpdate(() => {
    itemRefs.value = [];
  });
  return {
    itemRefs,
    setItemRef,
    setItemRefByIndex
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-option-list/VaOptionList.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaOptionList.css";
var _sfc_main81 = defineComponent({
  name: "VaOptionList",
  components: {
    VaRadio,
    VaCheckbox,
    VaSwitch,
    VaMessageListWrapper
  },
  emits: [...useStatefulEmits, ...useValidationEmits, "clear"],
  props: {
    ...useComponentPresetProp,
    ...useSelectableListProps,
    ...useValidationProps,
    ...useStatefulProps,
    type: {
      type: String,
      default: "checkbox",
      validator: (type) => ["radio", "checkbox", "switch"].includes(type)
    },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    defaultValue: { type: [String, Number, Boolean, Object, Array] },
    name: { type: String, default: "" },
    color: { type: String, default: "primary" },
    leftLabel: { type: Boolean, default: false },
    modelValue: { type: [String, Number, Boolean, Object, Array] }
  },
  setup(props2, { emit }) {
    const { valueComputed } = useStateful(props2, emit, "modelValue", { defaultValue: props2.defaultValue });
    const { getValue: getValue2, getText, getTrackBy, getDisabled } = useSelectableList(props2);
    const { itemRefs, setItemRef } = useArrayRefs();
    const isRadio = computed(() => props2.type === "radio");
    const selectedValue = computed({
      get() {
        const value = isRadio.value ? null : [];
        return valueComputed.value || value;
      },
      set(value) {
        if (props2.readonly) {
          return;
        }
        if (isRadio.value && !Array.isArray(value)) {
          valueComputed.value = value ? getValue2(value) : value;
        } else {
          valueComputed.value = Array.isArray(value) ? value.map(getValue2) : [value ? getValue2(value) : value];
        }
      }
    });
    const isDisabled = (option) => props2.disabled || getDisabled(option);
    const reset = () => withoutValidation(() => {
      valueComputed.value = null;
      emit("clear");
      resetValidation();
    });
    const focus = () => {
      const firstActiveEl = Array.isArray(itemRefs.value) && itemRefs.value.find((el) => !el.disabled);
      if (firstActiveEl && typeof firstActiveEl.focus === "function") {
        firstActiveEl.focus();
      }
    };
    const {
      computedError,
      computedErrorMessages,
      withoutValidation,
      resetValidation
    } = useValidation(props2, emit, { reset, focus, value: valueComputed });
    const computedProps = computed(() => pick$1(props2, ["name", "color", "readonly", "leftLabel"]));
    onMounted(() => {
      if (isDev && props2.type !== "radio" && !Array.isArray(props2.modelValue)) {
        console.warn(`Prop 'modelValue = ${props2.modelValue}' has not a proper type!
 For component property 'type = ${props2.type}' it must be of type 'array'.`);
      }
    });
    return {
      selectedValue,
      computedError,
      computedErrorMessages,
      getValue: getValue2,
      getText,
      getTrackBy,
      isDisabled,
      reset,
      focus,
      setItemRef,
      computedProps
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-option-list/VaOptionList.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaOptionList.css";
var _hoisted_147 = { class: "va-option-list__list" };
function _sfc_render78(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_radio = resolveComponent("va-radio");
  const _component_va_checkbox = resolveComponent("va-checkbox");
  const _component_va_switch = resolveComponent("va-switch");
  const _component_VaMessageListWrapper = resolveComponent("VaMessageListWrapper");
  return openBlock(), createBlock(_component_VaMessageListWrapper, {
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages,
    "error-count": _ctx.$props.errorCount
  }, {
    default: withCtx(() => [
      createBaseVNode("ul", _hoisted_147, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.options, (option) => {
          return openBlock(), createElementBlock("li", {
            key: _ctx.getTrackBy(option)
          }, [
            renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ option, selectedValue: _ctx.selectedValue, isDisabled: _ctx.isDisabled, getText: _ctx.getText, getValue: _ctx.getValue })), () => [
              _ctx.$props.type === "radio" ? (openBlock(), createBlock(_component_va_radio, mergeProps({
                key: 0,
                ref_for: true,
                ref: _ctx.setItemRef,
                modelValue: _ctx.selectedValue,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.selectedValue = $event),
                label: _ctx.getText(option),
                disabled: _ctx.isDisabled(option),
                option: _ctx.getValue(option)
              }, _ctx.computedProps), null, 16, ["modelValue", "label", "disabled", "option"])) : _ctx.$props.type === "checkbox" ? (openBlock(), createBlock(_component_va_checkbox, mergeProps({
                key: 1,
                ref_for: true,
                ref: _ctx.setItemRef,
                modelValue: _ctx.selectedValue,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.selectedValue = $event),
                label: _ctx.getText(option),
                disabled: _ctx.isDisabled(option),
                "array-value": _ctx.getValue(option)
              }, _ctx.computedProps), null, 16, ["modelValue", "label", "disabled", "array-value"])) : (openBlock(), createBlock(_component_va_switch, mergeProps({
                key: 2,
                ref_for: true,
                ref: _ctx.setItemRef,
                modelValue: _ctx.selectedValue,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.selectedValue = $event),
                label: _ctx.getText(option),
                disabled: _ctx.isDisabled(option),
                "array-value": _ctx.getValue(option)
              }, _ctx.computedProps), null, 16, ["modelValue", "label", "disabled", "array-value"]))
            ])
          ]);
        }), 128))
      ])
    ]),
    _: 3
  }, 8, ["error", "error-messages", "error-count"]);
}
var _VaOptionList = _export_sfc(_sfc_main81, [["render", _sfc_render78]]);

// node_modules/vuestic-ui/dist/es/src/components/va-option-list/index.js
var VaOptionList = withConfigTransport$1(_VaOptionList);

// node_modules/vuestic-ui/dist/es/src/components/va-pagination/setPaginationRange.js
var setPaginationRange = (currentPage = 1, visiblePages, pages, includeBoundary = false) => {
  let start = 0;
  if (pages === 0) {
    pages = 1;
  }
  if (visiblePages > pages) {
    visiblePages = pages;
  }
  if (visiblePages === 0) {
    start = 1;
    visiblePages = pages > 10 ? 10 : pages;
  } else {
    const paginationMiddlePage = visiblePages / 2;
    if (currentPage - paginationMiddlePage <= 0 || currentPage > pages) {
      start = 1;
    } else {
      start = currentPage + paginationMiddlePage > pages ? pages - visiblePages + 1 : Math.ceil(currentPage - paginationMiddlePage);
    }
  }
  const range = [];
  for (let i2 = 0; i2 < visiblePages; i2++) {
    range.push(start + i2);
  }
  if (includeBoundary && visiblePages < 7) {
    pages >= 7 && warn(
      "[va-pagination] To work in a proper way, the `boundaryNumbers` prop needs at least 7 visible pages to be set via the `visiblePages` prop (first, last, 2 boundaries, current, previous, next)."
    );
  } else if (includeBoundary) {
    start !== 1 && range.splice(0, 2, 1, "...");
    range[range.length - 1] !== pages && range.splice(-2, 2, "...", pages);
  }
  return range;
};

// node_modules/vuestic-ui/dist/es/src/components/va-pagination/VaPagination.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaPagination.css";
var _sfc_main82 = defineComponent({
  name: "VaPagination",
  components: { VaButton },
  emits: [...useStatefulEmits],
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Number, default: 1 },
    visiblePages: { type: Number, default: 0 },
    pages: { type: Number, default: 0 },
    disabled: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    size: {
      type: String,
      default: "medium",
      validator: (v2) => ["small", "medium", "large"].includes(v2)
    },
    boundaryLinks: { type: Boolean, default: true },
    boundaryNumbers: { type: Boolean, default: false },
    directionLinks: { type: Boolean, default: true },
    input: { type: Boolean, default: false },
    hideOnSinglePage: { type: Boolean, default: false },
    total: { type: Number, default: null },
    pageSize: { type: Number, default: null },
    boundaryIconLeft: { type: String, default: "va-arrow-first" },
    boundaryIconRight: { type: String, default: "va-arrow-last" },
    directionIconLeft: { type: String, default: "va-arrow-left" },
    directionIconRight: { type: String, default: "va-arrow-right" },
    gapped: { type: Boolean, default: false },
    borderColor: { type: String, default: "" },
    rounded: { type: Boolean, default: false },
    activePageColor: { type: String, default: "" },
    buttonsPreset: { type: String, default: "primary" },
    ariaLabel: { type: String, default: "$t:pagination" },
    ariaGoToTheFirstPageLabel: { type: String, default: "$t:goToTheFirstPage" },
    ariaGoToPreviousPageLabel: { type: String, default: "$t:goToPreviousPage" },
    ariaGoToSpecificPageLabel: { type: String, default: "$t:goToSpecificPage" },
    ariaGoToSpecificPageInputLabel: { type: String, default: "$t:goToSpecificPageInput" },
    ariaGoToNextPageLabel: { type: String, default: "$t:goNextPage" },
    ariaGoToLastPageLabel: { type: String, default: "$t:goLastPage" }
  },
  setup(props2, { emit }) {
    const htmlInput = shallowRef();
    const inputValue = ref("");
    const usesTotal = computed(() => !!((props2.total || props2.total === 0) && props2.pageSize));
    const { valueComputed } = useStateful(props2, emit);
    const currentValue = computed({
      get: () => usesTotal.value ? Math.ceil(valueComputed.value / props2.pageSize) || 1 : valueComputed.value,
      set: (value) => {
        valueComputed.value = value;
      }
    });
    const paginationRange = computed(() => {
      const { visiblePages, total, pageSize, boundaryNumbers, pages } = props2;
      const value = currentValue.value || 1;
      const totalPages = usesTotal.value ? Math.ceil(total / pageSize) : pages;
      return setPaginationRange(value, visiblePages, totalPages, boundaryNumbers);
    });
    const lastPage = computed(() => usesTotal.value ? Math.ceil(props2.total / props2.pageSize) || 1 : +props2.pages);
    const isLastPageNotVisible = computed(() => !!props2.visiblePages && lastPage.value > props2.visiblePages || props2.input);
    const showBoundaryLinks = computed(() => {
      const { boundaryLinks, boundaryNumbers } = props2;
      return isLastPageNotVisible.value && boundaryLinks && !boundaryNumbers;
    });
    const showDirectionLinks = computed(() => isLastPageNotVisible.value && props2.directionLinks);
    const showPagination = computed(() => lastPage.value > 1 || !props2.hideOnSinglePage && lastPage.value <= 1);
    const focusInput = () => {
      inputValue.value = String(currentValue.value);
      nextTick(() => {
        var _a2;
        return (_a2 = htmlInput.value) == null ? void 0 : _a2.setSelectionRange(0, htmlInput.value.value.length);
      });
    };
    const { setItemRefByIndex, itemRefs } = useArrayRefs();
    const onUserInput = (pageNum) => {
      var _a2;
      if (pageNum === "..." || pageNum === currentValue.value) {
        return;
      }
      const limitedPageNum = clamp$1(pageNum, 1, lastPage.value);
      currentValue.value = usesTotal.value ? (limitedPageNum - 1) * props2.pageSize + 1 : limitedPageNum;
      (_a2 = itemRefs.value[pageNum - 1]) == null ? void 0 : _a2.focus();
    };
    const resetInput = () => {
      var _a2;
      inputValue.value = "";
      (_a2 = htmlInput.value) == null ? void 0 : _a2.blur();
    };
    const changeValue = () => {
      if (+inputValue.value === currentValue.value) {
        resetInput();
      }
      if (!inputValue.value.length) {
        return;
      }
      let pageNum = Number.parseInt(inputValue.value);
      switch (true) {
        case pageNum < 1:
          pageNum = 1;
          break;
        case pageNum > lastPage.value:
          pageNum = lastPage.value;
          break;
        case isNaN(pageNum):
          pageNum = currentValue.value;
          break;
      }
      onUserInput(pageNum);
      resetInput();
    };
    const { getColor, colorToRgba: colorToRgba2 } = useColors();
    const inputBorderColorComputed = computed(() => {
      const { color, buttonsPreset } = toRefs(props2);
      if (!color.value) {
        return "transparent";
      }
      switch (buttonsPreset.value) {
        case "default":
          return getColor(color.value);
        case void 0:
        case "primary":
          return colorToRgba2(getColor(color.value), 0.1);
        default:
          return "transparent";
      }
    });
    const inputStyleComputed = computed(() => ({
      cursor: "default",
      color: getColor(props2.color),
      opacity: props2.disabled ? 0.4 : 1,
      borderColor: inputBorderColorComputed.value
    }));
    watch([usesTotal, () => props2.pages], () => {
      if (isDev && usesTotal.value && props2.pages) {
        throw new Error("Please, use either `total` and `page-size` props, or `pages`.");
      }
    });
    const inputAttributesComputed = computed(() => ({
      disabled: props2.disabled,
      placeholder: `${currentValue.value}/${lastPage.value}`
    }));
    const buttonPropsComputed = computed(() => ({
      size: props2.size,
      preset: props2.buttonsPreset,
      color: props2.color,
      borderColor: props2.borderColor,
      round: props2.rounded
    }));
    const currentPageButtonProps = computed(() => ({
      preset: props2.buttonsPreset === "default" ? "primary" : "default",
      color: props2.activePageColor || props2.color
    }));
    const getPageButtonProps = (n2) => {
      if (!isNaN(+n2) && n2 === currentValue.value) {
        return Object.assign({}, buttonPropsComputed.value, currentPageButtonProps.value);
      }
      return buttonPropsComputed.value;
    };
    const isStandAloneInput = computed(() => props2.input && !props2.boundaryLinks && !props2.directionLinks);
    const inputClassComputed = useBem("va-pagination__input", () => ({
      sm: props2.size === "small" && isStandAloneInput.value,
      md: props2.size === "medium" && isStandAloneInput.value,
      lg: props2.size === "large" && isStandAloneInput.value,
      auto: !isStandAloneInput.value
    }));
    const classComputed = useBem("va-pagination", () => ({
      ...pick$1(props2, ["gapped", "rounded", "disabled"]),
      bordered: !!props2.borderColor
    }));
    const goNextPage = () => onUserInput(currentValue.value + 1);
    const goPrevPage = () => onUserInput(currentValue.value - 1);
    return {
      ...useTranslation(),
      getPageButtonProps,
      inputClassComputed,
      classComputed,
      currentValue,
      lastPage,
      changeValue,
      inputValue,
      showPagination,
      showBoundaryLinks,
      onUserInput,
      showDirectionLinks,
      paginationRange,
      focusInput,
      inputStyleComputed,
      inputAttributesComputed,
      goNextPage,
      goPrevPage,
      buttonPropsComputed,
      htmlInput,
      setItemRefByIndex
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-pagination/VaPagination.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaPagination.css";
var _hoisted_148 = ["aria-label"];
var _hoisted_223 = ["aria-label"];
function _sfc_render79(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  return _ctx.showPagination ? (openBlock(), createElementBlock("nav", {
    key: 0,
    class: normalizeClass(["va-pagination", _ctx.classComputed]),
    "aria-label": _ctx.tp(_ctx.$props.ariaLabel),
    onKeydown: [
      _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => _ctx.goPrevPage && _ctx.goPrevPage(...args), ["stop"]), ["left"])),
      _cache[7] || (_cache[7] = withKeys(withModifiers((...args) => _ctx.goNextPage && _ctx.goNextPage(...args), ["stop"]), ["right"])),
      _cache[8] || (_cache[8] = withKeys(withModifiers((...args) => _ctx.goPrevPage && _ctx.goPrevPage(...args), ["stop"]), ["up"])),
      _cache[9] || (_cache[9] = withKeys(withModifiers((...args) => _ctx.goNextPage && _ctx.goNextPage(...args), ["stop"]), ["down"]))
    ]
  }, [
    _ctx.showBoundaryLinks ? renderSlot(_ctx.$slots, "firstPageLink", normalizeProps(mergeProps({ key: 0 }, { onClick: () => _ctx.onUserInput(1), disabled: _ctx.$props.disabled || _ctx.currentValue === 1 })), () => [
      _ctx.showBoundaryLinks ? (openBlock(), createBlock(_component_va_button, mergeProps({
        key: 0,
        "aria-label": _ctx.tp(_ctx.$props.ariaGoToTheFirstPageLabel),
        disabled: _ctx.$props.disabled || _ctx.currentValue === 1,
        icon: _ctx.$props.boundaryIconLeft
      }, _ctx.buttonPropsComputed, {
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.onUserInput(1))
      }), null, 16, ["aria-label", "disabled", "icon"])) : createCommentVNode("", true)
    ]) : createCommentVNode("", true),
    _ctx.showDirectionLinks ? renderSlot(_ctx.$slots, "prevPageLink", normalizeProps(mergeProps({ key: 1 }, { onClick: _ctx.goPrevPage, disabled: _ctx.$props.disabled || _ctx.currentValue === 1 })), () => [
      _ctx.showDirectionLinks ? (openBlock(), createBlock(_component_va_button, mergeProps({
        key: 0,
        "aria-label": _ctx.tp(_ctx.$props.ariaGoToPreviousPageLabel),
        disabled: _ctx.$props.disabled || _ctx.currentValue === 1,
        icon: _ctx.$props.directionIconLeft
      }, _ctx.buttonPropsComputed, { onClick: _ctx.goPrevPage }), null, 16, ["aria-label", "disabled", "icon", "onClick"])) : createCommentVNode("", true)
    ]) : createCommentVNode("", true),
    !_ctx.$props.input ? renderSlot(_ctx.$slots, "default", { key: 2 }, () => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.paginationRange, (n2, i2) => {
        return openBlock(), createBlock(_component_va_button, mergeProps({
          key: i2,
          ref_for: true,
          ref: _ctx.setItemRefByIndex(i2),
          class: { "va-button--ellipsis": n2 === "...", "va-button--current": n2 === _ctx.currentValue },
          "aria-label": _ctx.tp(_ctx.$props.ariaGoToSpecificPageLabel, { page: n2 }),
          "aria-current": n2 === _ctx.currentValue,
          disabled: _ctx.$props.disabled || n2 === "..."
        }, _ctx.getPageButtonProps(n2), {
          onClick: ($event) => _ctx.onUserInput(n2)
        }), {
          default: withCtx(() => [
            createTextVNode(toDisplayString(n2), 1)
          ]),
          _: 2
        }, 1040, ["class", "aria-label", "aria-current", "disabled", "onClick"]);
      }), 128))
    ]) : withDirectives((openBlock(), createElementBlock("input", mergeProps({
      key: 3,
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.inputValue = $event),
      ref: "htmlInput",
      class: ["va-pagination__input va-button", _ctx.inputClassComputed],
      "aria-label": _ctx.tp(_ctx.$props.ariaGoToSpecificPageInputLabel),
      style: _ctx.inputStyleComputed
    }, _ctx.inputAttributesComputed, {
      onKeydown: _cache[2] || (_cache[2] = withKeys((...args) => _ctx.changeValue && _ctx.changeValue(...args), ["enter"])),
      onFocus: _cache[3] || (_cache[3] = (...args) => _ctx.focusInput && _ctx.focusInput(...args)),
      onBlur: _cache[4] || (_cache[4] = (...args) => _ctx.changeValue && _ctx.changeValue(...args))
    }), null, 16, _hoisted_223)), [
      [vModelDynamic, _ctx.inputValue]
    ]),
    _ctx.showDirectionLinks ? renderSlot(_ctx.$slots, "nextPageLink", normalizeProps(mergeProps({ key: 4 }, { onClick: _ctx.goNextPage, disabled: _ctx.$props.disabled || _ctx.currentValue === _ctx.lastPage })), () => [
      _ctx.showDirectionLinks ? (openBlock(), createBlock(_component_va_button, mergeProps({
        key: 0,
        "aria-label": _ctx.tp(_ctx.$props.ariaGoToNextPageLabel),
        disabled: _ctx.$props.disabled || _ctx.currentValue === _ctx.lastPage,
        icon: _ctx.$props.directionIconRight
      }, _ctx.buttonPropsComputed, { onClick: _ctx.goNextPage }), null, 16, ["aria-label", "disabled", "icon", "onClick"])) : createCommentVNode("", true)
    ]) : createCommentVNode("", true),
    _ctx.showBoundaryLinks ? renderSlot(_ctx.$slots, "lastPageLink", normalizeProps(mergeProps({ key: 5 }, { onClick: () => _ctx.onUserInput(_ctx.lastPage), disabled: _ctx.$props.disabled || _ctx.currentValue === _ctx.lastPage })), () => [
      _ctx.showBoundaryLinks ? (openBlock(), createBlock(_component_va_button, mergeProps({
        key: 0,
        "aria-label": _ctx.tp(_ctx.$props.ariaGoToLastPageLabel),
        disabled: _ctx.$props.disabled || _ctx.currentValue === _ctx.lastPage,
        icon: _ctx.$props.boundaryIconRight
      }, _ctx.buttonPropsComputed, {
        onClick: _cache[5] || (_cache[5] = ($event) => _ctx.onUserInput(_ctx.lastPage))
      }), null, 16, ["aria-label", "disabled", "icon"])) : createCommentVNode("", true)
    ]) : createCommentVNode("", true)
  ], 42, _hoisted_148)) : createCommentVNode("", true);
}
var _VaPagination = _export_sfc(_sfc_main82, [["render", _sfc_render79]]);

// node_modules/vuestic-ui/dist/es/src/components/va-pagination/index.js
var VaPagination = withConfigTransport$1(_VaPagination);

// node_modules/vuestic-ui/dist/es/src/composables/useScrollParent.js
var useScrollParent = () => {
  const window2 = useWindow();
  const fakeWindow = new Proxy(window2.value || {}, {
    get: (target, key, rec) => {
      var _a2, _b;
      if (key === "scrollTop") {
        return (_a2 = window2.value) == null ? void 0 : _a2.scrollY;
      }
      if (key === "scrollLeft") {
        return (_b = window2.value) == null ? void 0 : _b.scrollX;
      }
      const value = Reflect.get(target, key, rec);
      if (typeof value === "function") {
        return value.bind(target);
      }
      return value;
    }
  });
  const getScrollableParent = (element) => {
    if (!element) {
      return fakeWindow;
    }
    if (element.scrollHeight > element.clientHeight) {
      return element;
    }
    return getScrollableParent(element.parentElement);
  };
  return { getScrollableParent };
};

// node_modules/vuestic-ui/dist/es/src/components/va-parallax/VaParallax.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaParallax.css";
var _sfc_main83 = defineComponent({
  name: "VaParallax",
  props: {
    ...useComponentPresetProp,
    target: { type: [Object, String] },
    src: { type: String, default: "", required: true },
    alt: { type: String, default: "parallax" },
    height: { type: Number, default: 400 },
    reversed: { type: Boolean, default: false },
    speed: {
      type: Number,
      default: 0.5,
      validator: (value) => value >= 0 && value <= 1
    }
  },
  setup(props2) {
    const rootElement = shallowRef();
    const img = shallowRef();
    const elOffsetTop = ref(0);
    const parallax = ref(0);
    const parallaxDist = ref(0);
    const percentScrolled = ref(0);
    const scrollTop = ref(0);
    const windowHeight = ref(0);
    const windowBottom = ref(0);
    const isLoaded = ref(false);
    const computedWrapperStyles = computed(() => ({ height: props2.height + "px" }));
    const computedImgStyles = computed(() => ({
      display: "block",
      transform: `translate(-50%, ${parallax.value}px)`,
      opacity: isLoaded.value ? 1 : 0,
      top: props2.reversed ? 0 : "auto"
    }));
    const { getScrollableParent } = useScrollParent();
    const targetElement = computed(() => {
      var _a2;
      if (!props2.target) {
        return getScrollableParent((_a2 = rootElement.value) == null ? void 0 : _a2.parentElement);
      }
      if (props2.target instanceof HTMLElement) {
        return props2.target;
      }
      const element = document.querySelector(props2.target);
      if (element) {
        return element;
      }
      warn("VaParallax target prop got wrong selector. Target is null");
      return null;
    });
    const imgHeight = computed(() => {
      var _a2;
      return ((_a2 = img.value) == null ? void 0 : _a2.naturalHeight) || 0;
    });
    const calcDimensions = () => {
      var _a2, _b;
      const offset2 = ((_a2 = rootElement.value) == null ? void 0 : _a2.getBoundingClientRect()) || { top: 0 };
      scrollTop.value = ((_b = targetElement.value) == null ? void 0 : _b.scrollTop) || 0;
      parallaxDist.value = imgHeight.value - props2.height;
      elOffsetTop.value = offset2.top + scrollTop.value;
      windowHeight.value = window.innerHeight;
      windowBottom.value = scrollTop.value + windowHeight.value;
    };
    const translate = () => {
      calcDimensions();
      percentScrolled.value = (windowBottom.value - elOffsetTop.value) / (props2.height + windowHeight.value);
      parallax.value = Math.round(parallaxDist.value * percentScrolled.value) * props2.speed;
      if (props2.reversed) {
        parallax.value = -parallax.value;
      }
    };
    const addEventListeners = () => {
      var _a2, _b;
      (_a2 = targetElement.value) == null ? void 0 : _a2.addEventListener("scroll", translate);
      (_b = targetElement.value) == null ? void 0 : _b.addEventListener("resize", translate);
    };
    const removeEventListeners = () => {
      var _a2, _b;
      (_a2 = targetElement.value) == null ? void 0 : _a2.removeEventListener("scroll", translate);
      (_b = targetElement.value) == null ? void 0 : _b.removeEventListener("resize", translate);
    };
    const initImage = () => {
      var _a2, _b;
      if ((_a2 = img.value) == null ? void 0 : _a2.complete) {
        translate();
        addEventListeners();
      } else {
        (_b = img.value) == null ? void 0 : _b.addEventListener("load", () => {
          translate();
          addEventListeners();
        }, false);
      }
      isLoaded.value = true;
    };
    onMounted(initImage);
    onBeforeUnmount(removeEventListeners);
    return {
      img,
      rootElement,
      computedWrapperStyles,
      computedImgStyles
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-parallax/VaParallax.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaParallax.css";
var _hoisted_149 = { class: "va-parallax__image-container" };
var _hoisted_224 = ["src", "alt"];
var _hoisted_316 = { class: "va-parallax__item-container" };
function _sfc_render80(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "rootElement",
    class: "va-parallax",
    style: normalizeStyle(_ctx.computedWrapperStyles)
  }, [
    createBaseVNode("div", _hoisted_149, [
      createBaseVNode("img", {
        ref: "img",
        class: "va-parallax__image",
        src: _ctx.$props.src,
        alt: _ctx.$props.alt,
        style: normalizeStyle(_ctx.computedImgStyles)
      }, null, 12, _hoisted_224)
    ]),
    createBaseVNode("div", _hoisted_316, [
      renderSlot(_ctx.$slots, "default")
    ])
  ], 4);
}
var _VaParallax = _export_sfc(_sfc_main83, [["render", _sfc_render80]]);

// node_modules/vuestic-ui/dist/es/src/components/va-parallax/index.js
var VaParallax = withConfigTransport$1(_VaParallax);

// node_modules/vuestic-ui/dist/es/src/components/va-popover/VaPopover.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaPopover.css";
var VaDropdownProps3 = extractComponentProps(VaDropdown, ["closeOnClickOutside"]);
var _sfc_main84 = defineComponent({
  name: "VaPopover",
  components: { VaDropdown, VaIcon },
  props: {
    ...VaDropdownProps3,
    ...useComponentPresetProp,
    trigger: { default: "hover" },
    color: { type: String, default: "#1b1a1f" },
    // TODO: Make sure add this color to pallete
    textColor: { type: String },
    icon: { type: String, default: "" },
    title: { type: String, default: "" },
    message: { type: String, default: "" },
    autoHide: { type: Boolean, default: true },
    offset: { type: [Array, Number], default: 4 }
  },
  setup(props2, { slots }) {
    const VaDropdownPropValues = filterComponentProps(VaDropdownProps3);
    const { getColor, getBoxShadowColor: getBoxShadowColor2 } = useColors();
    const { textColorComputed } = useTextColor(computed(() => getColor(props2.color)));
    const showIconComputed = computed(() => props2.icon || slots.icon);
    const showTitleComputed = computed(() => props2.title || slots.title);
    const showBodyComputed = computed(() => props2.message || slots.body);
    const showPopoverContentComputed = computed(
      () => showTitleComputed.value || showBodyComputed.value
    );
    const computedPopoverStyle = computed(() => ({
      boxShadow: `var(--va-popover-content-box-shadow) ${getBoxShadowColor2(getColor(props2.color))}`,
      backgroundColor: getColor(props2.color),
      color: textColorComputed.value
    }));
    return {
      textColorComputed,
      VaDropdownPropValues,
      showBodyComputed,
      showIconComputed,
      showTitleComputed,
      computedPopoverStyle,
      showPopoverContentComputed
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-popover/VaPopover.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaPopover.css";
var _hoisted_150 = {
  key: 0,
  "aria-hidden": "true",
  class: "va-popover__icon"
};
var _hoisted_225 = { key: 1 };
var _hoisted_317 = {
  key: 0,
  class: "va-popover__title"
};
var _hoisted_49 = {
  key: 1,
  class: "va-popover__body"
};
function _sfc_render81(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createBlock(_component_va_dropdown, mergeProps(_ctx.VaDropdownPropValues, {
    "model-value": _ctx.modelValue,
    "close-on-click-outside": _ctx.autoHide,
    offset: _ctx.$props.offset,
    class: "va-popover"
  }), {
    default: withCtx(() => [
      createBaseVNode("div", {
        style: normalizeStyle(_ctx.computedPopoverStyle),
        class: "va-popover__content",
        role: "tooltip"
      }, [
        _ctx.showIconComputed ? (openBlock(), createElementBlock("div", _hoisted_150, [
          renderSlot(_ctx.$slots, "icon", {}, () => [
            createVNode(_component_va_icon, {
              name: _ctx.$props.icon,
              color: _ctx.textColorComputed
            }, null, 8, ["name", "color"])
          ])
        ])) : createCommentVNode("", true),
        _ctx.showPopoverContentComputed ? (openBlock(), createElementBlock("div", _hoisted_225, [
          _ctx.showTitleComputed ? (openBlock(), createElementBlock("div", _hoisted_317, [
            renderSlot(_ctx.$slots, "title", {}, () => [
              createTextVNode(toDisplayString(_ctx.$props.title), 1)
            ])
          ])) : createCommentVNode("", true),
          _ctx.showBodyComputed ? (openBlock(), createElementBlock("div", _hoisted_49, [
            renderSlot(_ctx.$slots, "body", {}, () => [
              createTextVNode(toDisplayString(_ctx.$props.message), 1)
            ])
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ], 4)
    ]),
    anchor: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16, ["model-value", "close-on-click-outside", "offset"]);
}
var _VaPopover = _export_sfc(_sfc_main84, [["render", _sfc_render81]]);

// node_modules/vuestic-ui/dist/es/src/components/va-popover/index.js
var VaPopover = withConfigTransport$1(_VaPopover);

// node_modules/vuestic-ui/dist/es/src/components/va-rating/types.js
var RatingValue = ((RatingValue2) => {
  RatingValue2[RatingValue2["EMPTY"] = 0] = "EMPTY";
  RatingValue2[RatingValue2["HALF"] = 0.5] = "HALF";
  RatingValue2[RatingValue2["FULL"] = 1] = "FULL";
  return RatingValue2;
})(RatingValue || {});

// node_modules/vuestic-ui/dist/es/src/components/va-rating/hooks/useRating.js
var getContext = () => {
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("useRating hooks must be used on top of setup function");
  }
  return {
    props: instance.props,
    emit: instance.emit
  };
};
var useRatingProps = {
  ...useStatefulProps,
  modelValue: { type: Number, default: 0 },
  clearable: { type: Boolean, default: false },
  hover: { type: Boolean, default: false }
};
var useRating = (props2) => {
  const { emit } = getContext();
  const { isHovered, onMouseEnter, onMouseLeave } = useHover();
  const { valueComputed: modelValue } = useStateful(props2, emit);
  const hoveredValue = ref(0);
  const visibleValue = computed(() => !props2.disabled && !props2.readonly && props2.hover && isHovered.value ? hoveredValue.value : modelValue.value);
  const onItemValueUpdate = (itemIndex, newValue) => {
    const newModelValue = itemIndex + newValue;
    if (props2.clearable) {
      if (modelValue.value === newModelValue) {
        modelValue.value = 0;
        return;
      }
    }
    modelValue.value = newModelValue;
  };
  const onItemHoveredValueUpdate = (itemIndex, newValue) => {
    if (!props2.hover) {
      return;
    }
    hoveredValue.value = itemIndex + newValue;
  };
  const getItemValue = (itemIndex) => {
    const itemValue = visibleValue.value - itemIndex;
    return clamp$1(itemValue, RatingValue.EMPTY, RatingValue.FULL);
  };
  return {
    visibleValue,
    modelValue,
    hoveredValue,
    isHovered,
    onMouseEnter,
    onMouseLeave,
    onItemValueUpdate,
    onItemHoveredValueUpdate,
    getItemValue
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-rating/hooks/useVaRatingColors.js
var useVaRatingColorsProps = {
  unselectedColor: { type: String },
  color: { type: String, default: "primary" },
  modelValue: { type: Number }
};
var useVaRatingColors = (props2) => {
  const { getColor, getFocusColor: getFocusColor2, getTextColor } = useColors();
  const computedColor = computed(() => getColor(props2.color));
  const backgroundColor = computed(() => {
    if (props2.unselectedColor) {
      return getColor(props2.unselectedColor);
    }
    return getFocusColor2(getColor(props2.color));
  });
  const backgroundComputed = computed(() => {
    if (props2.modelValue === RatingValue.HALF) {
      return `linear-gradient(90deg, ${computedColor.value} 50%, ${backgroundColor.value} 50%`;
    }
    if (props2.modelValue === RatingValue.EMPTY) {
      return backgroundColor.value;
    }
    return computedColor.value;
  });
  const textColorComputed = computed(() => {
    if (props2.modelValue === RatingValue.FULL) {
      return getColor(getTextColor(computedColor.value));
    }
    return getColor(getTextColor(backgroundColor.value));
  });
  return {
    computedColor,
    backgroundComputed,
    textColorComputed
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-rating/components/VaRatingItem/VaRatingItem.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaRatingItem.css";
var _sfc_main85 = defineComponent({
  name: "VaRatingItem",
  components: { VaIcon },
  props: {
    modelValue: { type: Number, default: 0 },
    icon: { type: String, default: "star" },
    halfIcon: { type: String, default: "star_half" },
    emptyIcon: { type: String, default: "star_outline" },
    halves: { type: Boolean, default: false },
    hover: { type: Boolean, default: false },
    tabindex: { type: [String, Number], default: 0 },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    size: { type: [String, Number], default: "medium" },
    unselectedColor: { type: String },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "click", "hover"],
  setup(props2, { emit }) {
    const rootEl = shallowRef();
    const [modelValue] = useSyncProp("modelValue", props2, emit, RatingValue.EMPTY);
    const hoveredValue = ref(null);
    const visibleValue = computed(() => {
      if (props2.hover && !props2.disabled && !props2.readonly) {
        return hoveredValue.value || modelValue.value;
      }
      return modelValue.value;
    });
    const { getColor } = useColors();
    const computedColor = computed(() => getColor(
      props2.unselectedColor && visibleValue.value === RatingValue.EMPTY ? props2.unselectedColor : props2.color
    ));
    const onMouseMove = (ev) => {
      if (!rootEl.value) {
        return;
      }
      const { offsetX } = ev;
      const iconWidth = rootEl.value.clientWidth;
      if (props2.halves) {
        hoveredValue.value = offsetX / iconWidth <= RatingValue.HALF ? RatingValue.HALF : RatingValue.FULL;
      } else {
        hoveredValue.value = RatingValue.FULL;
      }
    };
    const onMouseLeave = () => {
      hoveredValue.value = null;
    };
    const onEnter = () => {
      modelValue.value = 1;
    };
    const onClick = () => {
      modelValue.value = hoveredValue.value || RatingValue.FULL;
      emit("click", hoveredValue.value || RatingValue.FULL);
    };
    watch(hoveredValue, () => emit("hover", hoveredValue.value || RatingValue.EMPTY));
    return {
      computedColor,
      rootEl,
      onEnter,
      onClick,
      onMouseMove,
      onMouseLeave,
      visibleValue,
      computedIconName: computed(() => {
        if (props2.halves && visibleValue.value === RatingValue.HALF) {
          return props2.halfIcon;
        }
        if (visibleValue.value === RatingValue.EMPTY) {
          return props2.emptyIcon;
        }
        return props2.icon;
      }),
      tabIndexComputed: computed(() => props2.disabled ? -1 : props2.tabindex)
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-rating/components/VaRatingItem/VaRatingItem.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaRatingItem.css";
var _hoisted_151 = ["tabindex"];
function _sfc_render82(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", {
    ref: "rootEl",
    role: "button",
    class: "va-rating-item",
    tabindex: _ctx.tabIndexComputed,
    onKeydown: [
      _cache[0] || (_cache[0] = withKeys((...args) => _ctx.onClick && _ctx.onClick(...args), ["enter"])),
      _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.onClick && _ctx.onClick(...args), ["prevent"]), ["space"]))
    ],
    onMousemove: _cache[2] || (_cache[2] = (...args) => _ctx.onMouseMove && _ctx.onMouseMove(...args)),
    onMouseleave: _cache[3] || (_cache[3] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args)),
    onClick: _cache[4] || (_cache[4] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, [
    renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ value: _ctx.visibleValue, onClick: _ctx.onClick })), () => [
      createVNode(_component_va_icon, {
        class: "va-rating-item__wrapper",
        tabindex: "-1",
        tag: "button",
        name: _ctx.computedIconName,
        size: _ctx.$props.size,
        color: _ctx.computedColor
      }, null, 8, ["name", "size", "color"])
    ])
  ], 40, _hoisted_151);
}
var _VaRatingItem = _export_sfc(_sfc_main85, [["render", _sfc_render82]]);

// node_modules/vuestic-ui/dist/es/src/components/va-rating/components/VaRatingItemNumberButton.vue_vue_type_script_lang.js
var _sfc_main86 = defineComponent({
  name: "VaRatingItemNumberButton",
  props: {
    ...useVaRatingColorsProps,
    ...useSizeProps,
    itemNumber: { type: Number, required: true },
    modelValue: { type: Number, required: true }
  },
  setup(props2) {
    const {
      textColorComputed,
      backgroundComputed
    } = useVaRatingColors(props2);
    const {
      sizeComputed,
      fontSizeComputed,
      fontSizeInRem
    } = useSize(props2, "VaRating");
    return {
      textColorComputed,
      backgroundComputed,
      sizeComputed,
      fontSizeComputed,
      fontSizeInRem
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-rating/components/VaRatingItemNumberButton.js
function _sfc_render83(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("button", {
    class: "va-rating__number-item",
    tabindex: "-1",
    "aria-hidden": "true",
    style: normalizeStyle({
      background: _ctx.backgroundComputed,
      color: _ctx.textColorComputed,
      width: _ctx.sizeComputed,
      height: _ctx.sizeComputed,
      fontSize: _ctx.fontSizeComputed,
      borderRadius: `${parseInt(_ctx.fontSizeComputed) * 0.125}rem`
    })
  }, toDisplayString(_ctx.itemNumber), 5);
}
var VaRatingItemNumberButton = _export_sfc(_sfc_main86, [["render", _sfc_render83]]);

// node_modules/vuestic-ui/dist/es/src/components/va-rating/VaRating.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaRating.css";
var VaRatingItemPropsDeclarations = extractComponentProps(_VaRatingItem, ["modelValue", "itemNumber"]);
var VaRatingItemNumberButtonPropsDeclarations = extractComponentProps(VaRatingItemNumberButton, ["modelValue", "itemNumber"]);
var _sfc_main87 = defineComponent({
  name: "VaRating",
  props: {
    ...VaRatingItemNumberButtonPropsDeclarations,
    ...useRatingProps,
    ...useVaRatingColorsProps,
    ...useFormFieldProps,
    ...VaRatingItemPropsDeclarations,
    ...useComponentPresetProp,
    modelValue: { type: Number, default: 0 },
    numbers: { type: Boolean, default: false },
    halves: { type: Boolean, default: false },
    max: { type: Number, default: 5 },
    texts: { type: Array, default: () => [] },
    ariaLabel: { type: String, default: "$t:currentRating" },
    ariaItemLabel: { type: String, default: "$t:voteRating" }
  },
  emits: ["update:modelValue"],
  components: { VaRatingItem: _VaRatingItem, VaRatingItemNumberButton },
  setup(props2) {
    const { computedClasses: rootClass } = useFormField("va-rating", props2);
    const {
      visibleValue,
      modelValue: vModel,
      hoveredValue,
      isHovered,
      onMouseEnter,
      onMouseLeave,
      onItemValueUpdate,
      onItemHoveredValueUpdate,
      getItemValue
    } = useRating(props2);
    const isInteractionsEnabled = computed(() => !props2.disabled && !props2.readonly);
    const onArrowKeyPress = (direction) => {
      const step = props2.halves ? RatingValue.HALF : RatingValue.FULL;
      const nextStep = visibleValue.value + step * direction;
      const min2 = props2.clearable ? 0 : step;
      if (nextStep >= min2 && nextStep <= props2.max) {
        onItemValueUpdate(visibleValue.value, step * direction);
      } else if (nextStep < min2) {
        onItemValueUpdate(min2, 0);
      } else {
        onItemValueUpdate(props2.max, direction === -1 ? step * direction : 0);
      }
    };
    const { tp, t: t2 } = useTranslation();
    const {
      computedColor,
      backgroundComputed,
      textColorComputed
    } = useVaRatingColors(props2);
    const tabIndexComputed = computed(() => isInteractionsEnabled.value ? 0 : void 0);
    const VaRatingItemProps = filterComponentProps(VaRatingItemPropsDeclarations);
    const VaRatingItemNumberButtonProps = filterComponentProps(VaRatingItemNumberButtonPropsDeclarations);
    return {
      tp,
      t: t2,
      visibleValue,
      vModel,
      hoveredValue,
      isHovered,
      onMouseEnter,
      onMouseLeave,
      onItemValueUpdate,
      onItemHoveredValueUpdate,
      getItemValue,
      onArrowKeyPress,
      computedColor,
      backgroundComputed,
      textColorComputed,
      rootClass,
      VaRatingItemProps,
      VaRatingItemNumberButtonProps,
      isInteractionsEnabled,
      tabIndexComputed
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-rating/VaRating.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaRating.css";
var _hoisted_152 = ["aria-label"];
function _sfc_render84(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaRatingItemNumberButton = resolveComponent("VaRatingItemNumberButton");
  const _component_va_rating_item = resolveComponent("va-rating-item");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-rating", _ctx.rootClass]),
    "aria-label": _ctx.tp(_ctx.$props.ariaLabel, { max: _ctx.$props.max, value: _ctx.$props.modelValue })
  }, [
    createBaseVNode("div", {
      class: "va-rating__item-wrapper",
      onKeyup: [
        _cache[0] || (_cache[0] = withKeys(($event) => _ctx.onArrowKeyPress(-1), ["left"])),
        _cache[1] || (_cache[1] = withKeys(($event) => _ctx.onArrowKeyPress(1), ["right"]))
      ],
      onMouseenter: _cache[2] || (_cache[2] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
      onMouseleave: _cache[3] || (_cache[3] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args))
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.max, (itemNumber) => {
        return openBlock(), createBlock(_component_va_rating_item, mergeProps({
          key: itemNumber,
          class: "va-rating__item"
        }, _ctx.VaRatingItemProps, {
          "aria-label": _ctx.tp(_ctx.$props.ariaItemLabel, { max: _ctx.$props.max, value: itemNumber }),
          "model-value": _ctx.getItemValue(itemNumber - 1),
          tabindex: _ctx.tabIndexComputed,
          disabled: _ctx.$props.disabled,
          readonly: _ctx.$props.readonly,
          onHover: ($event) => _ctx.isInteractionsEnabled && _ctx.onItemHoveredValueUpdate(itemNumber - 1, $event),
          "onUpdate:modelValue": ($event) => _ctx.isInteractionsEnabled && _ctx.onItemValueUpdate(itemNumber - 1, $event)
        }), {
          default: withCtx(({ value, onClick }) => [
            renderSlot(_ctx.$slots, "item", normalizeProps(guardReactiveProps({ value, onClick, index: itemNumber })), () => [
              _ctx.$props.numbers ? (openBlock(), createBlock(_component_VaRatingItemNumberButton, mergeProps({ key: 0 }, _ctx.VaRatingItemNumberButtonProps, {
                "model-value": value,
                "item-number": itemNumber
              }), null, 16, ["model-value", "item-number"])) : createCommentVNode("", true)
            ])
          ]),
          _: 2
        }, 1040, ["aria-label", "model-value", "tabindex", "disabled", "readonly", "onHover", "onUpdate:modelValue"]);
      }), 128))
    ], 32),
    _ctx.$props.texts && _ctx.$props.texts.length === _ctx.$props.max ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: "va-rating__text-wrapper",
      style: normalizeStyle({ color: _ctx.computedColor })
    }, toDisplayString(_ctx.$props.texts[Math.round(_ctx.visibleValue) - 1]), 5)) : createCommentVNode("", true)
  ], 10, _hoisted_152);
}
var _VaRating = _export_sfc(_sfc_main87, [["render", _sfc_render84]]);

// node_modules/vuestic-ui/dist/es/src/components/va-rating/index.js
var VaRating = withConfigTransport$1(_VaRating);

// node_modules/vuestic-ui/dist/es/src/utils/scroll-to-element.js
var getTopCoordinate = (element) => element.offsetTop;
var getBottomCoordinate = (element) => element.offsetTop + element.offsetHeight;
var getCenterCoordinate = (element) => element.offsetTop + element.offsetHeight / 2;
var getScrollTop = (element, scrollTarget, verticalAlignment) => {
  const viewHeight = scrollTarget.offsetHeight;
  const currentPosition = scrollTarget.scrollTop;
  const top = getTopCoordinate(element) - scrollTarget.offsetTop;
  const center = getCenterCoordinate(element) - scrollTarget.offsetTop;
  const bottom = getBottomCoordinate(element) - scrollTarget.offsetTop;
  if (verticalAlignment === "start") {
    return top;
  }
  if (verticalAlignment === "end") {
    return bottom - viewHeight;
  }
  if (verticalAlignment === "center") {
    return center - viewHeight / 2;
  }
  if (verticalAlignment === "any") {
    if (top - currentPosition < 0) {
      return top;
    }
    if (bottom - currentPosition > viewHeight) {
      return bottom - viewHeight;
    }
  }
};
var scrollToElement = (element, options = {
  scrollTarget: element.parentElement,
  verticalAlignment: "any",
  smooth: false
}) => {
  const scrollTarget = options.scrollTarget || element.parentElement;
  const top = getScrollTop(element, scrollTarget, options.verticalAlignment);
  if (top === void 0) {
    return;
  }
  scrollTarget.scroll({
    top,
    behavior: options.smooth ? "smooth" : "auto"
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-select/components/VaSelectOption/VaSelectOption.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSelectOption.css";
var _sfc_main88 = defineComponent({
  name: "VaSelectOption",
  components: { VaIcon },
  props: {
    ...useColorProps,
    disabled: { type: Boolean, default: false },
    option: { type: [Number, String, Boolean, Object], default: () => ({}) },
    getText: { type: Function, required: true },
    getTrackBy: { type: Function, required: true },
    currentOption: { type: [String, Number, Boolean, Object], default: null },
    getSelectedState: { type: Function, required: true },
    search: { type: String, default: "" },
    highlightMatchedText: { type: Boolean, default: true },
    inputFocused: { type: Boolean, default: false },
    minSearchChars: { type: Number, default: 0 }
  },
  setup(props2) {
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const optionIcon = computed(() => typeof props2.option === "object" ? props2.option.icon : void 0);
    const optionIconColor = computed(() => getColor(props2.color));
    const optionText = computed(() => props2.getText(props2.option));
    const optionTextSplitted = computed(() => {
      const defaultSplit = { start: optionText.value, searchedSubString: "", end: "" };
      if (!optionText.value || !props2.search || !props2.highlightMatchedText || props2.search.length < props2.minSearchChars) {
        return defaultSplit;
      }
      const substringStartIndex = optionText.value.toLowerCase().indexOf(props2.search.toLowerCase());
      if (substringStartIndex < 0) {
        return defaultSplit;
      }
      const start = optionText.value.slice(0, substringStartIndex);
      const searchedSubString = optionText.value.slice(substringStartIndex, substringStartIndex + props2.search.length);
      const end = optionText.value.slice(substringStartIndex + props2.search.length);
      return { start, searchedSubString, end };
    });
    const isSelected = computed(() => props2.getSelectedState(props2.option));
    const isFocused = computed(() => {
      if (isNilValue(props2.currentOption)) {
        return false;
      }
      if (typeof props2.option === "string") {
        return props2.option === props2.currentOption;
      }
      return props2.getTrackBy(props2.currentOption) === props2.getTrackBy(props2.option);
    });
    const optionClass = useBem("va-select-option", () => ({
      selected: isSelected.value
    }));
    const optionStyle = computed(() => ({
      color: isSelected.value ? getColor(props2.color) : "inherit",
      backgroundColor: isFocused.value ? getHoverColor2(getColor(props2.color)) : "transparent",
      cursor: props2.disabled ? "default" : void 0,
      opacity: props2.disabled ? "var(--va-select-option-list-option-disabled-opacity)" : void 0
    }));
    return {
      getColor,
      optionIcon,
      isSelected,
      optionStyle,
      optionClass,
      optionIconColor,
      optionTextSplitted
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-select/components/VaSelectOption/VaSelectOption.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSelectOption.css";
var _hoisted_153 = ["aria-selected"];
var _hoisted_226 = {
  key: 1,
  class: "va-select-option__highlighted"
};
function _sfc_render85(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", {
    role: "option",
    class: normalizeClass(["va-select-option", _ctx.optionClass]),
    style: normalizeStyle(_ctx.optionStyle),
    "aria-selected": _ctx.isSelected
  }, [
    _ctx.optionIcon ? (openBlock(), createBlock(_component_va_icon, {
      key: 0,
      size: "small",
      class: "va-select-option__icon",
      name: _ctx.optionIcon
    }, null, 8, ["name"])) : createCommentVNode("", true),
    createTextVNode(" " + toDisplayString(_ctx.optionTextSplitted.start) + " ", 1),
    _ctx.optionTextSplitted.searchedSubString ? (openBlock(), createElementBlock("span", _hoisted_226, toDisplayString(_ctx.optionTextSplitted.searchedSubString), 1)) : createCommentVNode("", true),
    createTextVNode(" " + toDisplayString(_ctx.optionTextSplitted.end) + " ", 1),
    withDirectives(createVNode(_component_va_icon, {
      class: "va-select-option__selected-icon",
      size: "small",
      name: "va-check",
      color: _ctx.optionIconColor
    }, null, 8, ["color"]), [
      [vShow, _ctx.isSelected]
    ])
  ], 14, _hoisted_153);
}
var _VaSelectOption = _export_sfc(_sfc_main88, [["render", _sfc_render85]]);

// node_modules/vuestic-ui/dist/es/src/components/va-select/components/VaSelectOption/index.js
var VaSelectOption = withConfigTransport$1(_VaSelectOption);

// node_modules/vuestic-ui/dist/es/src/composables/useObjectRefs.js
var useObjectRefs = () => {
  const itemRefs = shallowRef({});
  const setItemRef = (key) => (el) => {
    if (!el) {
      return;
    }
    itemRefs.value[key] = el;
    return String(key);
  };
  onBeforeUpdate(() => {
    itemRefs.value = {};
  });
  return { itemRefs, setItemRef };
};

// node_modules/vuestic-ui/dist/es/src/components/va-select/components/VaSelectOptionList/VaSelectOptionList.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSelectOptionList.css";
var _sfc_main89 = defineComponent({
  name: "VaSelectOptionList",
  components: { VaVirtualScroller, VaSelectOption },
  emits: [
    "select-option",
    "update:hoveredOption",
    "no-previous-option-to-hover",
    "scroll-bottom"
  ],
  props: {
    ...useColorProps,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    ...useThrottleProps,
    noOptionsText: { type: String, default: "Items not found" },
    getSelectedState: { type: Function, required: true },
    multiple: { type: Boolean, default: false },
    search: { type: String, default: "" },
    tabindex: { type: [String, Number], default: 0 },
    hoveredOption: { type: [String, Number, Boolean, Object], default: null },
    virtualScroller: { type: Boolean, default: true },
    highlightMatchedText: { type: Boolean, default: true },
    minSearchChars: { type: Number, default: 0 },
    autoSelectFirstOption: { type: Boolean, default: false },
    selectedTopShown: { type: Boolean, default: false }
  },
  setup(props2, { emit }) {
    const root2 = shallowRef();
    const focus = () => {
      var _a2;
      (_a2 = root2.value) == null ? void 0 : _a2.focus({ preventScroll: true });
    };
    const rootHeight = computed(() => {
      var _a2;
      return ((_a2 = root2.value) == null ? void 0 : _a2.clientHeight) ?? 200;
    });
    const handleScrollToBottom = () => emit("scroll-bottom");
    const onScroll = (event) => {
      const target = event.target;
      if (!target) {
        return;
      }
      if (target.scrollTop + target.clientHeight === target.scrollHeight) {
        handleScrollToBottom();
      }
    };
    const lastInteractionSource = ref("");
    const currentOptionComputed = computed(() => props2.hoveredOption ?? null);
    const updateCurrentOption = (option, source) => {
      emit("update:hoveredOption", option);
      lastInteractionSource.value = source;
    };
    const { getText, getGroupBy, getTrackBy, getDisabled } = useSelectableList(props2);
    const currentSelectedOptionText = computed(() => {
      var _a2;
      const selected = (_a2 = props2.options) == null ? void 0 : _a2.find((option) => props2.getSelectedState(option));
      return selected ? getText(selected) : "";
    });
    const isSearchedOptionSelected = computed(() => {
      var _a2;
      return currentSelectedOptionText.value.toLowerCase() === ((_a2 = props2.search) == null ? void 0 : _a2.toLowerCase());
    });
    const filteredOptions = computed(() => {
      if (!props2.search || props2.search.length < props2.minSearchChars || isSearchedOptionSelected.value) {
        return props2.options;
      }
      return props2.options.filter((option) => {
        const optionText = getText(option).toUpperCase();
        const search = props2.search.toUpperCase().trim();
        return optionText.includes(search);
      });
    });
    const optionGroups = computed(() => filteredOptions.value.reduce((groups, option) => {
      const groupBy = getGroupBy(option);
      if (!groupBy) {
        groups._noGroup.push(option);
      } else {
        if (!groups[groupBy]) {
          groups[groupBy] = [];
        }
        groups[groupBy].push(option);
      }
      return groups;
    }, { _noGroup: [] }));
    const optionGroupsThrottled = useThrottleValue(optionGroups, props2);
    const isValueExists = (value) => !isNilValue(value);
    const updateHoveredOption = (option) => {
      if (option === currentOptionComputed.value || isValueExists(option) && getDisabled(option)) {
        return;
      }
      updateCurrentOption(option ?? null, "mouse");
    };
    const updateFocusedOption = (option) => {
      updateCurrentOption(option ?? null, "keyboard");
    };
    const selectHoveredOption = () => {
      const previousOption = previousOptionComputed.value && typeof previousOptionComputed.value === "object" ? { ...previousOptionComputed.value } : previousOptionComputed.value;
      emit("select-option");
      if (props2.selectedTopShown) {
        updateHoveredOption(previousOption);
      }
    };
    const groupedOptions = computed(() => Object.values(optionGroupsThrottled.value).flat());
    const currentOptions = computed(() => filteredOptions.value.some((el) => getGroupBy(el)) ? groupedOptions.value : filteredOptions.value);
    const currentOptionIndex = computed(() => currentOptions.value.findIndex((option) => {
      return isValueExists(currentOptionComputed.value) && getTrackBy(option) === getTrackBy(currentOptionComputed.value);
    }));
    const selectOptionProps = computed(() => ({
      ...pick$1(props2, ["getSelectedState", "color", "search", "highlightMatchedText", "minSearchChars"]),
      getText,
      getTrackBy
    }));
    const findNextActiveOption = (startSearchIndex, reversedSearch = false) => {
      const searchBase = [...currentOptions.value || []];
      const searchBaseOrdered = reversedSearch ? searchBase.reverse() : searchBase;
      const startIndex = reversedSearch ? startSearchIndex * -1 - 1 : startSearchIndex;
      return searchBaseOrdered.slice(startIndex).find((option) => !getDisabled(option));
    };
    const previousOptionComputed = computed(() => {
      const previousOptionIndex = currentOptionIndex.value - 1;
      const previousOption = currentOptions.value[previousOptionIndex];
      const previousOptionCheck = isValueExists(previousOption) && !(previousOptionIndex === 0 && getDisabled(previousOption));
      if (previousOptionCheck) {
        return findNextActiveOption(currentOptionIndex.value - 1, true);
      }
      return void 0;
    });
    const selectOption = (option) => {
      updateHoveredOption(option);
      emit("select-option");
    };
    const handleMouseMove = (option) => {
      if (!props2.selectedTopShown) {
        updateHoveredOption(option);
      }
    };
    const handleMouseEnter = (option) => {
      if (props2.selectedTopShown) {
        updateHoveredOption(option);
      }
    };
    const focusPreviousOption = () => {
      if (!isValueExists(currentOptionComputed.value)) {
        updateFocusedOption(findNextActiveOption(0, true));
        return;
      }
      if (isValueExists(previousOptionComputed.value)) {
        updateFocusedOption(previousOptionComputed.value);
      } else {
        emit("no-previous-option-to-hover");
      }
    };
    const focusNextOption = () => {
      if (!isValueExists(currentOptionComputed.value)) {
        focusFirstOption();
        return;
      }
      const nextOptionIndex = currentOptionIndex.value + 1;
      const nextOption = currentOptions.value[nextOptionIndex];
      const nextOptionCheck = isValueExists(nextOption) && !(nextOptionIndex === currentOptions.value.length - 1 && getDisabled(nextOption));
      if (nextOptionCheck) {
        updateFocusedOption(findNextActiveOption(currentOptionIndex.value + 1));
      }
    };
    const focusFirstOption = () => updateFocusedOption(findNextActiveOption(0));
    const { itemRefs, setItemRef } = useObjectRefs();
    const virtualScrollerRef = shallowRef();
    const scrollToOption = (option) => {
      var _a2;
      if (!isValueExists(option)) {
        return;
      }
      const element = unwrapEl(itemRefs.value[getTrackBy(option)]);
      if (element) {
        scrollToElement(element);
      }
      if (props2.virtualScroller) {
        (_a2 = virtualScrollerRef.value) == null ? void 0 : _a2[0].virtualScrollTo(currentOptionIndex.value);
      }
    };
    watch(() => props2.hoveredOption, (newOption) => {
      (!lastInteractionSource.value || lastInteractionSource.value === "keyboard") && isValueExists(newOption) && scrollToOption(newOption);
    });
    watch(filteredOptions, () => {
      if (!props2.autoSelectFirstOption) {
        return;
      }
      focusFirstOption();
    }, { immediate: true });
    return {
      root: root2,
      virtualScrollerRef,
      rootHeight,
      optionGroups: optionGroupsThrottled,
      filteredOptions,
      selectOptionProps,
      currentOptionComputed,
      onScroll,
      getTrackBy,
      setItemRef,
      getDisabled,
      selectHoveredOption,
      handleMouseMove,
      handleMouseEnter,
      updateHoveredOption,
      handleScrollToBottom,
      selectOption,
      focusPreviousOption,
      focusNextOption,
      focusFirstOption,
      scrollToOption,
      focus
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-select/components/VaSelectOptionList/VaSelectOptionList.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSelectOptionList.css";
var _hoisted_154 = ["tabindex", "aria-multiselectable"];
var _hoisted_227 = {
  key: 0,
  class: "va-select-option-list__group-name",
  role: "presentation"
};
var _hoisted_318 = {
  key: 0,
  class: "va-select-option-list--empty"
};
function _sfc_render86(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_select_option = resolveComponent("va-select-option");
  const _component_va_virtual_scroller = resolveComponent("va-virtual-scroller");
  return openBlock(), createElementBlock("div", {
    ref: "root",
    class: "va-select-option-list",
    tabindex: _ctx.tabindex,
    onKeydown: [
      _cache[0] || (_cache[0] = withKeys(withModifiers((...args) => _ctx.focusPreviousOption && _ctx.focusPreviousOption(...args), ["stop", "prevent"]), ["up"])),
      _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.focusPreviousOption && _ctx.focusPreviousOption(...args), ["stop", "prevent"]), ["left"])),
      _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => _ctx.focusNextOption && _ctx.focusNextOption(...args), ["stop", "prevent"]), ["down"])),
      _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => _ctx.focusNextOption && _ctx.focusNextOption(...args), ["stop", "prevent"]), ["right"])),
      _cache[4] || (_cache[4] = withKeys(withModifiers((...args) => _ctx.selectHoveredOption && _ctx.selectHoveredOption(...args), ["stop", "prevent"]), ["enter"])),
      _cache[5] || (_cache[5] = withKeys(withModifiers((...args) => _ctx.selectHoveredOption && _ctx.selectHoveredOption(...args), ["stop", "prevent"]), ["space"]))
    ],
    onScrollPassive: _cache[6] || (_cache[6] = (...args) => _ctx.onScroll && _ctx.onScroll(...args)),
    role: "listbox",
    "aria-multiselectable": _ctx.$props.multiple
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.optionGroups, (options, groupName) => {
      return openBlock(), createElementBlock(Fragment, { key: groupName }, [
        groupName !== "_noGroup" ? (openBlock(), createElementBlock("span", _hoisted_227, toDisplayString(groupName), 1)) : createCommentVNode("", true),
        _ctx.$props.virtualScroller ? (openBlock(), createBlock(_component_va_virtual_scroller, {
          key: 1,
          ref_for: true,
          ref: "virtualScrollerRef",
          items: options,
          "track-by": _ctx.getTrackBy,
          "wrapper-size": _ctx.rootHeight,
          "onScroll:bottom": _ctx.handleScrollToBottom
        }, {
          default: withCtx(({ item: option, index }) => [
            renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ option, index, selectOption: _ctx.selectOption })), () => [
              createVNode(_component_va_select_option, mergeProps({
                option,
                "current-option": _ctx.currentOptionComputed,
                disabled: _ctx.getDisabled(option)
              }, _ctx.selectOptionProps, {
                onClick: withModifiers(_ctx.selectHoveredOption, ["stop"]),
                onMouseenter: ($event) => _ctx.handleMouseEnter(option),
                onMousemove: ($event) => _ctx.handleMouseMove(option)
              }), null, 16, ["option", "current-option", "disabled", "onClick", "onMouseenter", "onMousemove"])
            ])
          ]),
          _: 2
        }, 1032, ["items", "track-by", "wrapper-size", "onScroll:bottom"])) : (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList(options, (option, index) => {
          return renderSlot(_ctx.$slots, "default", normalizeProps(mergeProps({
            key: _ctx.getTrackBy(option)
          }, { option, index, selectOption: _ctx.selectOption })), () => [
            createVNode(_component_va_select_option, mergeProps({
              ref_for: true,
              ref: _ctx.setItemRef(_ctx.getTrackBy(option)),
              "current-option": _ctx.currentOptionComputed,
              option,
              disabled: _ctx.getDisabled(option)
            }, _ctx.selectOptionProps, {
              onClick: withModifiers(_ctx.selectHoveredOption, ["stop"]),
              onMouseenter: ($event) => _ctx.handleMouseEnter(option),
              onMousemove: ($event) => _ctx.handleMouseMove(option)
            }), null, 16, ["current-option", "option", "disabled", "onClick", "onMouseenter", "onMousemove"])
          ]);
        }), 128))
      ], 64);
    }), 128)),
    !_ctx.filteredOptions.length ? (openBlock(), createElementBlock("div", _hoisted_318, toDisplayString(_ctx.noOptionsText), 1)) : createCommentVNode("", true)
  ], 40, _hoisted_154);
}
var _VaSelectOptionList = _export_sfc(_sfc_main89, [["render", _sfc_render86]]);

// node_modules/vuestic-ui/dist/es/src/components/va-select/components/VaSelectOptionList/index.js
var VaSelectOptionList = withConfigTransport$1(_VaSelectOptionList);

// node_modules/vuestic-ui/dist/es/src/components/va-select/components/VaSelectContent/VaSelectContent.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSelectContent.css";
var _sfc_main90 = defineComponent({
  name: "VaSelectContent",
  components: { VaBadge, VaIcon },
  props: {
    ...useFormFieldProps,
    ariaAttributes: { type: Object },
    value: { type: Array, required: true },
    valueString: { type: String },
    placeholder: { type: String, default: "" },
    tabindex: { type: [String, Number], default: 0 },
    hiddenSelectedOptionsAmount: { type: Number, default: 0 },
    isAllOptionsShown: { type: Boolean, default: false },
    autocomplete: { type: Boolean, default: false },
    focused: { type: Boolean, default: false },
    multiple: { type: Boolean, default: false },
    getText: { type: Function, required: true },
    autocompleteInputValue: { type: String, default: "" }
  },
  emits: ["toggle-hidden", "autocomplete-input", "focus-prev", "focus-next", "select-option", "delete-last-selected"],
  setup(props2, { emit }) {
    const autocompleteInput = ref();
    const isPlaceholder = computed(() => props2.placeholder && !props2.valueString);
    const toggleHiddenOptionsState = () => emit("toggle-hidden");
    const { value, focused } = toRefs(props2);
    const autocompleteInputValueComputed = computed({
      get: () => props2.autocompleteInputValue,
      set: (v2) => emit("autocomplete-input", v2)
    });
    onMounted(() => {
      if (props2.multiple) {
        return;
      }
      if (!props2.autocomplete) {
        return;
      }
      autocompleteInputValueComputed.value = props2.valueString;
    });
    watch(focused, (newValue) => {
      var _a2, _b;
      if (!props2.autocomplete || !newValue) {
        return;
      }
      if (autocompleteInputValueComputed.value) {
        (_a2 = autocompleteInput.value) == null ? void 0 : _a2.setSelectionRange(0, autocompleteInputValueComputed.value.length);
      } else {
        (_b = autocompleteInput.value) == null ? void 0 : _b.focus();
      }
    });
    const handleBackspace = (e2) => {
      if (props2.multiple && value.value.length && e2.key === "Backspace" && !autocompleteInputValueComputed.value) {
        emit("delete-last-selected");
      }
    };
    return {
      getIcon: (option) => typeof option === "object" ? option.icon : void 0,
      isPlaceholder,
      toggleHiddenOptionsState,
      autocompleteInputValueComputed,
      autocompleteInput,
      handleBackspace
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-select/components/VaSelectContent/VaSelectContent.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSelectContent.css";
var _hoisted_155 = {
  key: 0,
  class: "va-select-content__autocomplete"
};
var _hoisted_228 = ["placeholder", "disabled", "readonly"];
var _hoisted_319 = {
  key: 1,
  class: "va-select-content__placeholder"
};
var _hoisted_410 = ["placeholder"];
function _sfc_render87(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_badge = resolveComponent("va-badge");
  return openBlock(), createElementBlock(Fragment, null, [
    _ctx.$props.autocomplete ? (openBlock(), createElementBlock("div", _hoisted_155, [
      _ctx.$props.multiple || _ctx.$slots.content ? renderSlot(_ctx.$slots, "content", normalizeProps(mergeProps({ key: 0 }, {
        value: _ctx.$props.value,
        valueString: _ctx.$props.valueString,
        tabindex: _ctx.$props.tabindex,
        ariaAttributes: _ctx.ariaAttributes
      })), () => [
        _ctx.value.length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.value, (option, index) => {
          return openBlock(), createElementBlock("span", {
            key: _ctx.$props.getText(option)
          }, [
            _ctx.getIcon(option) ? (openBlock(), createBlock(_component_va_icon, {
              key: 0,
              size: "small",
              class: "va-select-option__icon",
              name: _ctx.getIcon(option)
            }, null, 8, ["name"])) : createCommentVNode("", true),
            createTextVNode(" " + toDisplayString(`${_ctx.$props.getText(option)}${index + 1 === _ctx.value.length ? "" : ", "}`), 1)
          ]);
        }), 128)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createTextVNode(toDisplayString(_ctx.$props.valueString), 1)
        ], 64))
      ]) : createCommentVNode("", true),
      withDirectives(createBaseVNode("input", mergeProps(_ctx.ariaAttributes, {
        ref: "autocompleteInput",
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.autocompleteInputValueComputed = $event),
        placeholder: _ctx.$props.placeholder,
        disabled: _ctx.$props.disabled,
        readonly: _ctx.$props.readonly,
        autocomplete: "off",
        "aria-autocomplete": "list",
        onKeydown: [
          _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.$emit("focus-prev"), ["stop", "prevent"]), ["up"])),
          _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => _ctx.$emit("focus-next"), ["stop", "prevent"]), ["down"])),
          _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.$emit("select-option"), ["stop", "prevent"]), ["enter"])),
          _cache[4] || (_cache[4] = (...args) => _ctx.handleBackspace && _ctx.handleBackspace(...args))
        ]
      }), null, 16, _hoisted_228), [
        [vModelDynamic, _ctx.autocompleteInputValueComputed]
      ])
    ])) : _ctx.isPlaceholder ? (openBlock(), createElementBlock("span", _hoisted_319, [
      createBaseVNode("input", mergeProps(_ctx.ariaAttributes, {
        placeholder: _ctx.$props.placeholder,
        readonly: ""
      }), null, 16, _hoisted_410)
    ])) : renderSlot(_ctx.$slots, "content", normalizeProps(mergeProps({ key: 2 }, {
      valueString: _ctx.$props.valueString,
      value: _ctx.$props.value,
      tabindex: _ctx.$props.tabindex,
      ariaAttributes: _ctx.ariaAttributes
    })), () => [
      _ctx.getIcon(_ctx.value[0]) ? (openBlock(), createBlock(_component_va_icon, {
        key: 0,
        size: "small",
        class: "va-select-option__icon",
        name: _ctx.getIcon(_ctx.value[0])
      }, null, 8, ["name"])) : createCommentVNode("", true),
      createTextVNode(" " + toDisplayString(_ctx.$props.valueString), 1)
    ]),
    renderSlot(_ctx.$slots, "hiddenOptionsBadge", normalizeProps(guardReactiveProps({
      amount: _ctx.$props.hiddenSelectedOptionsAmount,
      isShown: _ctx.$props.isAllOptionsShown,
      toggle: _ctx.toggleHiddenOptionsState
    })), () => [
      _ctx.$props.hiddenSelectedOptionsAmount && !_ctx.$props.isAllOptionsShown ? (openBlock(), createBlock(_component_va_badge, {
        key: 0,
        class: "va-select-content__state-icon",
        color: "info",
        text: `+${_ctx.$props.hiddenSelectedOptionsAmount}`,
        tabindex: _ctx.$props.tabindex,
        onClick: withModifiers(_ctx.toggleHiddenOptionsState, ["stop"])
      }, null, 8, ["text", "tabindex", "onClick"])) : createCommentVNode("", true)
    ]),
    renderSlot(_ctx.$slots, "hideOptionsButton", normalizeProps(guardReactiveProps({
      isShown: _ctx.$props.isAllOptionsShown,
      toggle: _ctx.toggleHiddenOptionsState
    })), () => [
      _ctx.$props.isAllOptionsShown ? (openBlock(), createBlock(_component_va_icon, {
        key: 0,
        role: "button",
        class: "va-select-content__state-icon",
        size: "small",
        name: "reply",
        tabindex: _ctx.$props.tabindex,
        onClick: withModifiers(_ctx.toggleHiddenOptionsState, ["stop"])
      }, null, 8, ["tabindex", "onClick"])) : createCommentVNode("", true)
    ])
  ], 64);
}
var _VaSelectContent = _export_sfc(_sfc_main90, [["render", _sfc_render87]]);

// node_modules/vuestic-ui/dist/es/src/components/va-select/components/VaSelectContent/index.js
var VaSelectContent = withConfigTransport$1(_VaSelectContent);

// node_modules/vuestic-ui/dist/es/src/components/va-select/hooks/useMaxVisibleOptions.js
var useMaxVisibleOptionsProps = {
  maxVisibleOptions: { type: Number || String, default: 0 }
};
var useMaxVisibleOptions = (props2, getOptionByValue) => {
  const modelValue = toRef(props2, "modelValue");
  const isAllOptionsShown = ref(false);
  const belowLimitSelectedOptions = ref([]);
  const hiddenSelectedOptions = ref([]);
  const hiddenSelectedOptionsAmount = computed(() => hiddenSelectedOptions.value.length);
  const allSelectedOptions = computed(() => [...belowLimitSelectedOptions.value, ...hiddenSelectedOptions.value]);
  const visibleSelectedOptions = computed(() => {
    if (!props2.maxVisibleOptions || isAllOptionsShown.value) {
      return allSelectedOptions.value;
    }
    return belowLimitSelectedOptions.value;
  });
  watch(modelValue, () => {
    if (!Array.isArray(modelValue.value)) {
      belowLimitSelectedOptions.value = [getOptionByValue(modelValue.value)];
      hiddenSelectedOptions.value = [];
      return;
    }
    const value = modelValue.value.filter((v2) => !isNilValue(v2)).map(getOptionByValue);
    if (props2.maxVisibleOptions) {
      belowLimitSelectedOptions.value = value.slice(0, props2.maxVisibleOptions);
      hiddenSelectedOptions.value = value.slice(props2.maxVisibleOptions);
    } else {
      belowLimitSelectedOptions.value = [...value];
      hiddenSelectedOptions.value = [];
    }
  }, { immediate: true });
  const toggleHiddenOptionsState = () => isAllOptionsShown.value = !isAllOptionsShown.value;
  return {
    toggleHiddenOptionsState,
    isAllOptionsShown,
    visibleSelectedOptions,
    hiddenSelectedOptionsAmount,
    allSelectedOptions
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-select/hooks/useToggleIcon.js
var useToggleIconProps = {
  dropdownIcon: {
    type: [String, Object],
    default: () => ({
      open: "va-arrow-down",
      close: "va-arrow-up"
    }),
    validator: (value) => {
      if (typeof value === "string") {
        return true;
      }
      return Object.entries(value).every(([prop, propValue]) => ["open", "close"].includes(prop) && typeof propValue === "string");
    }
  }
};
var useToggleIcon = (props2, showDropdownContent) => {
  const toggleIcon = computed(() => {
    if (!props2.dropdownIcon) {
      return "";
    }
    if (typeof props2.dropdownIcon === "string") {
      return props2.dropdownIcon;
    }
    return showDropdownContent.value ? props2.dropdownIcon.close : props2.dropdownIcon.open;
  });
  const { getHoverColor: getHoverColor2, getColor } = useColors();
  const colorComputed = computed(() => getColor("secondary"));
  const toggleIconColor = computed(() => props2.readonly ? getHoverColor2(colorComputed.value) : colorComputed.value);
  return { toggleIcon, toggleIconColor };
};

// node_modules/vuestic-ui/dist/es/src/components/va-select/hooks/useStringValue.js
var useStringValueProps = {
  separator: { type: String, default: ", " }
};
var useStringValue = (props2, visibleSelectedOptions, getText) => {
  return computed(() => {
    var _a2;
    if (!((_a2 = visibleSelectedOptions.value) == null ? void 0 : _a2.length)) {
      return props2.clearValue;
    }
    return visibleSelectedOptions.value.map(getText).join(props2.separator) || props2.clearValue;
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-select/hooks/useAutocomplete.js
var useAutocompleteProps = {
  autocomplete: { type: Boolean, default: false }
};
var useAutocomplete = (autocompleteValue, props2, value, dropdownShown, getText) => {
  const getLastOptionText = (v2) => (v2 == null ? void 0 : v2.length) ? getText(v2.at(-1)) : "";
  if (props2.autocomplete && !props2.multiple) {
    autocompleteValue.value = getLastOptionText(value.value);
  }
  watch(value, (newValue, oldValue) => {
    if (!props2.autocomplete) {
      return;
    }
    const newValueStringConverted = getLastOptionText(newValue);
    const oldValueStringConverted = getLastOptionText(oldValue);
    if (newValueStringConverted !== oldValueStringConverted) {
      autocompleteValue.value = props2.multiple ? "" : newValueStringConverted;
      if (!props2.multiple) {
        dropdownShown.value = false;
      }
    }
  });
  watch(autocompleteValue, (newValue) => {
    if (!props2.autocomplete) {
      return;
    }
    if (newValue && newValue !== getLastOptionText(value.value)) {
      dropdownShown.value = true;
    }
  });
  const onDropdownClosed = () => {
    autocompleteValue.value = props2.multiple ? "" : getLastOptionText(value.value);
  };
  watch(dropdownShown, (newValue, oldValue) => {
    if (!props2.autocomplete) {
      return;
    }
    if (!newValue || oldValue) {
      onDropdownClosed();
    }
  });
  return autocompleteValue;
};

// node_modules/vuestic-ui/dist/es/src/components/va-select/hooks/useSelectAria.js
var useSelectAria = () => {
  const id = useComponentUuid();
  const popupId = `combobox-controls-${id}`;
  return {
    popupId
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useMaxSelections.js
var useMaxSelectionsProps = {
  maxSelections: {
    type: [Number, String],
    default: void 0
  }
};
function useMaxSelections(selections, maxSelections) {
  const exceedsMaxSelections = () => {
    if (maxSelections.value === void 0 || isNaN(+maxSelections.value)) {
      return false;
    }
    return selections.value.length >= Number(maxSelections.value);
  };
  const addOption = (optionToAdd) => {
    return [...selections.value, optionToAdd];
  };
  return {
    exceedsMaxSelections,
    addOption
  };
}

// node_modules/vuestic-ui/dist/es/src/components/va-select/VaSelect.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSelect.css";
var VaInputWrapperProps4 = extractComponentProps(VaInputWrapper);
var _sfc_main91 = defineComponent({
  name: "VaSelect",
  components: {
    VaSelectContent,
    VaSelectOptionList,
    VaIcon,
    VaDropdown,
    VaDropdownContent,
    VaInputWrapper
  },
  emits: [
    "update:modelValue",
    "update-search",
    "create-new",
    "scroll-bottom",
    "update:search",
    ...useDropdownableEmits,
    ...useValidationEmits,
    ...useClearableEmits
  ],
  props: {
    ...VaInputWrapperProps4,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    ...useValidationProps,
    ...useLoadingProps,
    ...useMaxSelectionsProps,
    ...useClearableProps,
    ...useFormFieldProps,
    ...useMaxVisibleOptionsProps,
    ...useToggleIconProps,
    ...useThrottleProps,
    ...useStringValueProps,
    ...useAutocompleteProps,
    ...useDropdownableProps,
    modelValue: {
      type: [String, Number, Array, Object, Boolean],
      default: ""
    },
    // Dropdown placement
    placement: {
      ...useDropdownableProps.placement,
      default: "bottom"
    },
    allowCreate: {
      type: [Boolean, String],
      default: false,
      validator: (mode) => [true, false, "unique"].includes(mode)
    },
    color: { type: String, default: "primary" },
    multiple: { type: Boolean, default: false },
    searchable: { type: Boolean, default: false },
    width: { type: String, default: "100%" },
    maxHeight: { type: String, default: "256px" },
    noOptionsText: { type: String, default: "$t:noOptions" },
    hideSelected: { type: Boolean, default: false },
    tabindex: { type: [String, Number], default: 0 },
    virtualScroller: { type: Boolean, default: false },
    selectedTopShown: { type: Boolean, default: false },
    highlightMatchedText: { type: Boolean, default: true },
    minSearchChars: { type: Number, default: 0 },
    autoSelectFirstOption: { type: Boolean, default: false },
    // Input style
    placeholder: { type: String, default: "" },
    searchPlaceholderText: { type: String, default: "$t:search" },
    ariaLabel: { type: String, default: "$t:select" },
    ariaSearchLabel: { type: String, default: "$t:optionsFilter" },
    ariaClearLabel: { type: String, default: "$t:reset" },
    search: { type: String, default: void 0 }
  },
  setup(props2, { emit, slots }) {
    const { tp, t: t2 } = useTranslation();
    const optionList = shallowRef();
    const input = shallowRef();
    const searchBar = shallowRef();
    const isInputFocused = useFocusDeep(input);
    const { getValue: getValue2, getText, getTrackBy } = useSelectableList(props2);
    const onScrollBottom = () => emit("scroll-bottom");
    const [searchVModel] = useSyncProp("search", props2, emit, "");
    const showSearchInput = computed(() => props2.searchable || props2.allowCreate && !props2.autocomplete);
    watch(searchVModel, (value) => {
      emit("update-search", value);
      if (!props2.autocomplete) {
        hoveredOption.value = null;
      }
    });
    const getOptionByValue = (value) => {
      if (isNilValue(value) || typeof value === "object") {
        return value;
      }
      const optionByValue = props2.options.find((option) => value === getValue2(option));
      if (optionByValue === void 0) {
        warn(`[VaSelect]: can not find option in options list (${JSON.stringify(props2.options)}) by provided value (${JSON.stringify(value)})!`);
        return value;
      }
      return optionByValue;
    };
    const {
      toggleHiddenOptionsState,
      isAllOptionsShown,
      visibleSelectedOptions,
      hiddenSelectedOptionsAmount,
      allSelectedOptions
    } = useMaxVisibleOptions(props2, getOptionByValue);
    const valueComputed = computed({
      get() {
        if (props2.multiple) {
          return allSelectedOptions.value;
        }
        const value = getOptionByValue(props2.modelValue);
        if (Array.isArray(value)) {
          warn("Model value should be a string, number, boolean or an object for a single Select.");
          if (value.length) {
            return value.at(-1);
          }
        }
        return value;
      },
      set(option) {
        if (Array.isArray(option)) {
          emit("update:modelValue", option.map(getValue2));
        } else {
          emit("update:modelValue", getValue2(option));
        }
      }
    });
    const valueString = useStringValue(props2, visibleSelectedOptions, getText);
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props2, valueComputed);
    const showClearIcon = computed(() => {
      if (!canBeCleared.value) {
        return false;
      }
      if (props2.multiple && Array.isArray(valueComputed.value)) {
        return !!valueComputed.value.length;
      }
      return true;
    });
    const filteredOptions = computed(() => {
      if (!props2.options) {
        return [];
      }
      if (props2.selectedTopShown) {
        return props2.options.slice().sort((a2, b2) => {
          const isASelected = checkIsOptionSelected(a2);
          const isBSelected = checkIsOptionSelected(b2);
          if (isASelected && isBSelected) {
            return 0;
          }
          if (isASelected && !isBSelected) {
            return -1;
          }
          return 1;
        });
      }
      if (props2.hideSelected) {
        return props2.options.filter((option) => !checkIsOptionSelected(option));
      }
      return props2.options;
    });
    const checkIsOptionSelected = (option) => {
      if (isNilValue(valueComputed.value)) {
        return false;
      }
      if (Array.isArray(valueComputed.value)) {
        return !isNilValue(valueComputed.value.find((valueItem) => compareOptions(valueItem, option)));
      }
      return compareOptions(valueComputed.value, option);
    };
    const compareOptions = (option1, option2) => {
      const one = getValue2(option1);
      const two = getValue2(option2);
      if (one === two) {
        return true;
      }
      if (typeof one === "string" && typeof two === "string") {
        return one === two;
      }
      if (one === null || two === null) {
        return false;
      }
      if (typeof one === "object" && typeof two === "object") {
        return getTrackBy(one) === getTrackBy(two);
      }
      return false;
    };
    const isValueComputedArray = (v2) => Array.isArray(v2.value);
    const selectOption = (option) => {
      if (hoveredOption.value === null) {
        hideAndFocus();
        return;
      }
      if (showSearchInput.value) {
        searchVModel.value = "";
      }
      if (props2.multiple && isValueComputedArray(valueComputed)) {
        const { exceedsMaxSelections, addOption } = useMaxSelections(valueComputed, ref(props2.maxSelections));
        const isSelected = checkIsOptionSelected(option);
        if (isSelected) {
          valueComputed.value = valueComputed.value.filter((optionSelected) => !compareOptions(option, optionSelected));
        } else {
          if (exceedsMaxSelections()) {
            return;
          }
          valueComputed.value = addOption(option);
        }
      } else {
        valueComputed.value = typeof option !== "object" ? option : { ...option };
        hideAndFocus();
      }
      focusAutocompleteInput();
    };
    const addNewOption = () => {
      var _a2;
      const hasAddedOption = (_a2 = props2.options) == null ? void 0 : _a2.some((option) => [searchVModel.value, autocompleteValue.value].includes(getText(option)));
      const allowedToCreateCheck = !((props2.allowCreate === "unique" || props2.autocomplete) && hasAddedOption);
      if (allowedToCreateCheck) {
        emit("create-new", searchVModel.value || autocompleteValue.value);
        searchVModel.value = "";
        autocompleteValue.value = "";
      }
    };
    const hoveredOption = ref(null);
    const selectHoveredOption = () => {
      if (isNilValue(hoveredOption.value)) {
        return;
      }
      if (!isOpenSync.value) {
        handleDropdownOpen();
        return;
      }
      selectOption(hoveredOption.value);
    };
    const selectOrAddOption = () => {
      const allowedToCreate = !!props2.allowCreate && (searchVModel.value || autocompleteValue.value);
      if (hoveredOption.value !== null) {
        selectHoveredOption();
      } else if (allowedToCreate) {
        addNewOption();
      }
    };
    const focusPreviousOption = () => {
      var _a2;
      return (_a2 = optionList.value) == null ? void 0 : _a2.focusPreviousOption();
    };
    const focusNextOption = () => {
      var _a2;
      return (_a2 = optionList.value) == null ? void 0 : _a2.focusNextOption();
    };
    const { isOpenSync, dropdownProps } = useDropdownable(props2, emit, {
      defaultCloseOnValueUpdate: computed(() => !props2.multiple)
    });
    const dropdownPropsComputed = computed(() => ({
      ...dropdownProps.value,
      closeOnContentClick: false,
      stateful: false,
      offset: [1, 0],
      keepAnchorWidth: true,
      keyboardNavigation: true,
      innerAnchorSelector: ".va-input-wrapper__field"
    }));
    const showDropdownContentComputed = computed({
      get: () => isOpenSync.value,
      set: (show) => {
        show ? handleDropdownOpen() : handleDropdownClose();
      }
    });
    const handleDropdownOpen = () => {
      if (props2.disabled || props2.readonly) {
        return;
      }
      isOpenSync.value = true;
      scrollToSelected();
      focusSearchOrOptions();
    };
    const handleDropdownClose = () => {
      isOpenSync.value = false;
      if (!props2.autocomplete) {
        searchVModel.value = "";
      }
      nextTick(() => {
        validate();
        isInputFocused.focusIfNothingIfFocused();
      });
    };
    const hideAndFocus = () => {
      handleDropdownClose();
      isInputFocused.value = true;
    };
    const focusSearchBar = () => {
      var _a2;
      (_a2 = searchBar.value) == null ? void 0 : _a2.focus();
    };
    const focusOptionList = () => {
      var _a2, _b;
      (_a2 = optionList.value) == null ? void 0 : _a2.focus();
      !props2.modelValue && ((_b = optionList.value) == null ? void 0 : _b.focusFirstOption());
    };
    const focusSearchOrOptions = async () => {
      await nextTick();
      if (showSearchInput.value) {
        focusSearchBar();
      } else {
        focusOptionList();
      }
    };
    const onInputBlur = () => {
      if (showDropdownContentComputed.value) {
        return;
      }
      onBlur();
      isInputFocused.value ? isInputFocused.value = false : validate();
    };
    const tabIndexComputed = computed(() => props2.disabled ? -1 : props2.tabindex);
    const openSelectButtonTabIndexComputed = computed(() => props2.disabled || props2.autocomplete ? -1 : 0);
    const scrollToSelected = () => {
      const selected = valueComputed.value;
      const nothingSelected = typeof selected !== "object" && Array.isArray(selected) && !selected.length;
      if (nothingSelected) {
        return;
      }
      const scrollTo = Array.isArray(selected) ? selected[selected.length - 1] : selected;
      hoveredOption.value = scrollTo;
      nextTick(() => {
        var _a2;
        return (_a2 = optionList.value) == null ? void 0 : _a2.scrollToOption(scrollTo);
      });
    };
    let hintedSearchQuery = "";
    let hintedSearchQueryTimeoutIndex;
    const navigationKeys = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Enter", " "];
    const onHintedSearch = (event) => {
      if (navigationKeys.some((key) => key === event.key)) {
        return;
      }
      const isLetter = event.key.length === 1;
      const isDeleteKey = event.key === "Backspace" || event.key === "Delete";
      clearTimeout(hintedSearchQueryTimeoutIndex);
      if (isDeleteKey) {
        hintedSearchQuery = hintedSearchQuery ? hintedSearchQuery.slice(0, -1) : "";
      } else if (isLetter) {
        hintedSearchQuery += event.key;
      }
      if (showSearchInput.value) {
        searchVModel.value = hintedSearchQuery;
        return;
      }
      if (hintedSearchQuery) {
        const appropriateOption = props2.options.find((option) => getText(option).toLowerCase().startsWith(hintedSearchQuery.toLowerCase()));
        if (appropriateOption) {
          hoveredOption.value = appropriateOption;
        }
      }
      hintedSearchQueryTimeoutIndex = setTimeout(() => {
        hintedSearchQuery = "";
      }, 1e3);
    };
    const optionsListPropsComputed = computed(() => ({
      ...pick$1(props2, ["textBy", "trackBy", "groupBy", "valueBy", "disabledBy", "color", "virtualScroller", "highlightMatchedText", "minSearchChars", "delay", "selectedTopShown"]),
      autoSelectFirstOption: props2.autoSelectFirstOption || props2.autocomplete,
      search: searchVModel.value || autocompleteValue.value,
      tabindex: tabIndexComputed.value,
      selectedValue: valueComputed.value,
      options: filteredOptions.value,
      getSelectedState: checkIsOptionSelected,
      noOptionsText: tp(props2.noOptionsText)
    }));
    const { toggleIcon, toggleIconColor } = useToggleIcon(props2, isOpenSync);
    const isFocused = computed(() => isInputFocused.value || isOpenSync.value);
    const inputWrapperClassComputed = useBem("va-select-anchor", () => ({
      nowrap: !!(props2.maxVisibleOptions && !slots.content)
    }));
    const vaInputWrapperProps = filterComponentProps(VaInputWrapperProps4);
    const inputWrapperPropsComputed = computed(() => ({
      ...vaInputWrapperProps.value,
      error: computedError.value,
      errorMessages: computedErrorMessages.value,
      focused: isFocused.value,
      "aria-label": props2.ariaLabel || (props2.modelValue ? `${t2("selectedOption")}: ${props2.modelValue}` : t2("noSelectedOption"))
    }));
    const selectContentPropsComputed = computed(() => ({
      ...pick$1(props2, ["placeholder", "autocomplete", "multiple", "disabled", "readonly"]),
      tabindex: tabIndexComputed.value,
      value: visibleSelectedOptions.value,
      valueString: valueString.value,
      hiddenSelectedOptionsAmount: hiddenSelectedOptionsAmount.value,
      isAllOptionsShown: isAllOptionsShown.value,
      focused: isInputFocused.value,
      autocompleteInputValue: autocompleteValue.value,
      getText
    }));
    const autocompleteValue = useAutocomplete(searchVModel, props2, visibleSelectedOptions, isOpenSync, getText);
    const setAutocompleteValue = (v2) => autocompleteValue.value = v2;
    const focus = () => {
      if (props2.disabled) {
        return;
      }
      focusElement(unwrapEl(input.value));
    };
    const blur = () => {
      if (showDropdownContentComputed.value) {
        showDropdownContentComputed.value = false;
      }
      nextTick(() => {
        if (props2.disabled) {
          return;
        }
        blurElement(unwrapEl(input.value));
      });
    };
    const reset = () => withoutValidation(() => {
      if (props2.multiple) {
        valueComputed.value = Array.isArray(props2.clearValue) ? props2.clearValue : [];
      } else {
        valueComputed.value = props2.clearValue;
      }
      searchVModel.value = "";
      emit("clear");
      resetValidation();
      nextTick(() => {
        isInputFocused.value = true;
      });
    });
    const focusAutocompleteInput = (e2) => {
      if (props2.autocomplete && !props2.disabled && !props2.readonly) {
        e2 == null ? void 0 : e2.stopImmediatePropagation();
        isInputFocused.value = true;
        isOpenSync.value = true;
      }
    };
    const toggleDropdown = (e2) => {
      if (props2.disabled || props2.readonly) {
        return;
      }
      const isInInput = e2.target && "tagName" in e2.target && e2.target.tagName === "INPUT";
      if (e2.code === "Space" && isInInput) {
        return;
      }
      e2.preventDefault();
      showDropdownContentComputed.value = !showDropdownContentComputed.value;
    };
    const deleteLastSelected = () => {
      if (!Array.isArray(valueComputed.value)) {
        return;
      }
      valueComputed.value = valueComputed.value.slice(0, -1);
    };
    const {
      validate,
      computedError,
      computedErrorMessages,
      withoutValidation,
      resetValidation
    } = useValidation(props2, emit, { reset, focus, value: valueComputed });
    const { popupId } = useSelectAria();
    const searchInput = searchVModel;
    const onInputFocus = onFocus;
    return {
      popupId,
      input,
      optionList,
      searchBar,
      reset,
      focus,
      blur,
      toggleDropdown,
      deleteLastSelected,
      focusAutocompleteInput,
      tp,
      t: t2,
      onInputFocus,
      onInputBlur,
      focusOptionList,
      focusSearchBar,
      searchInput,
      showSearchInput,
      hoveredOption,
      tabIndexComputed,
      valueString,
      showClearIcon,
      toggleIcon,
      selectOption,
      selectOrAddOption,
      selectHoveredOption,
      focusPreviousOption,
      focusNextOption,
      showDropdownContentComputed,
      handleDropdownOpen,
      handleDropdownClose,
      hideAndFocus,
      toggleIconColor,
      onHintedSearch,
      onScrollBottom,
      clearIconProps,
      dropdownPropsComputed,
      visibleSelectedOptions,
      optionsListPropsComputed,
      toggleHiddenOptionsState,
      setAutocompleteValue,
      inputWrapperPropsComputed,
      inputWrapperClassComputed,
      selectContentPropsComputed,
      openSelectButtonTabIndexComputed,
      // for e2e tests
      getOptionByValue,
      compareOptions,
      getText
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-select/VaSelect.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSelect.css";
function _sfc_render88(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_select_content = resolveComponent("va-select-content");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  const _component_va_select_option_list = resolveComponent("va-select-option-list");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createBlock(_component_va_dropdown, mergeProps({
    ref: "dropdown",
    modelValue: _ctx.showDropdownContentComputed,
    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.showDropdownContentComputed = $event),
    class: "va-select va-select__dropdown va-select-dropdown"
  }, _ctx.dropdownPropsComputed, {
    role: "combobox",
    "inner-anchor-selector": ".va-input-wrapper__field"
  }), {
    anchor: withCtx(() => [
      createVNode(_component_va_input_wrapper, mergeProps(_ctx.inputWrapperPropsComputed, {
        ref: "input",
        class: ["va-select__anchor va-select-anchor__input", _ctx.inputWrapperClassComputed],
        "aria-haspopup": "listbox",
        "model-value": _ctx.valueString,
        readonly: true,
        "aria-label": _ctx.$props.ariaLabel,
        "aria-controls": _ctx.popupId,
        "aria-owns": _ctx.popupId,
        onFocus: _ctx.onInputFocus,
        onBlur: _ctx.onInputBlur,
        onKeydown: [
          withKeys(_ctx.toggleDropdown, ["enter"]),
          withKeys(withModifiers(_ctx.toggleDropdown, ["stop"]), ["space"])
        ]
      }), createSlots({
        icon: withCtx(() => [
          _ctx.showClearIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 0,
            role: "button",
            "aria-label": _ctx.tp(_ctx.$props.ariaClearLabel)
          }, _ctx.clearIconProps, {
            onClick: withModifiers(_ctx.reset, ["stop"]),
            onKeydown: [
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
            ]
          }), null, 16, ["aria-label", "onClick", "onKeydown"])) : createCommentVNode("", true)
        ]),
        appendInner: withCtx(() => [
          createVNode(_component_va_icon, {
            color: _ctx.toggleIconColor,
            name: _ctx.toggleIcon,
            class: "va-select__toggle-icon",
            role: "button",
            tabindex: _ctx.openSelectButtonTabIndexComputed,
            "aria-expanded": _ctx.showDropdownContentComputed,
            onKeydown: withKeys(_ctx.toggleDropdown, ["enter"])
          }, null, 8, ["color", "name", "tabindex", "aria-expanded", "onKeydown"])
        ]),
        default: withCtx(({ ariaAttributes }) => [
          createVNode(_component_va_select_content, mergeProps(_ctx.selectContentPropsComputed, {
            ariaAttributes,
            onToggleHidden: _ctx.toggleHiddenOptionsState,
            onAutocompleteInput: _ctx.setAutocompleteValue,
            onFocusPrev: _ctx.focusPreviousOption,
            onFocusNext: _ctx.focusNextOption,
            onSelectOption: _ctx.selectOrAddOption,
            onDeleteLastSelected: _ctx.deleteLastSelected
          }), createSlots({ _: 2 }, [
            renderList(_ctx.$slots, (_2, name) => {
              return {
                name,
                fn: withCtx((slotScope) => [
                  renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
                ])
              };
            })
          ]), 1040, ["ariaAttributes", "onToggleHidden", "onAutocompleteInput", "onFocusPrev", "onFocusNext", "onSelectOption", "onDeleteLastSelected"])
        ]),
        _: 2
      }, [
        renderList(_ctx.$slots, (_2, name) => {
          return {
            name,
            fn: withCtx((slotScope) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
            ])
          };
        })
      ]), 1040, ["class", "model-value", "aria-label", "aria-controls", "aria-owns", "onFocus", "onBlur", "onKeydown"])
    ]),
    default: withCtx(() => [
      createVNode(_component_va_dropdown_content, {
        class: "va-select-dropdown__content",
        style: normalizeStyle({ width: _ctx.$props.width }),
        onKeydown: withKeys(_ctx.hideAndFocus, ["esc"]),
        role: "dialog"
      }, {
        default: withCtx(() => [
          _ctx.showSearchInput ? (openBlock(), createBlock(_component_va_input_wrapper, {
            key: 0,
            ref: "searchBar",
            class: "va-select-dropdown__content-search-input",
            modelValue: _ctx.searchInput,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.searchInput = $event),
            "aria-label": _ctx.tp(_ctx.$props.ariaSearchLabel),
            tabindex: _ctx.tabIndexComputed,
            placeholder: _ctx.tp(_ctx.$props.searchPlaceholderText),
            preset: "bordered",
            onKeydown: [
              withKeys(withModifiers(_ctx.focusPreviousOption, ["stop", "prevent"]), ["up"]),
              withKeys(withModifiers(_ctx.focusPreviousOption, ["stop", "prevent"]), ["left"]),
              withKeys(withModifiers(_ctx.focusNextOption, ["stop", "prevent"]), ["down"]),
              withKeys(withModifiers(_ctx.focusNextOption, ["stop", "prevent"]), ["right"]),
              withKeys(withModifiers(_ctx.selectOrAddOption, ["prevent"]), ["enter"])
            ],
            onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.hoveredOption = null)
          }, null, 8, ["modelValue", "aria-label", "tabindex", "placeholder", "onKeydown"])) : createCommentVNode("", true),
          createVNode(_component_va_select_option_list, mergeProps({
            ref: "optionList",
            class: "va-select-dropdown__options-wrapper",
            hoveredOption: _ctx.hoveredOption,
            "onUpdate:hoveredOption": _cache[2] || (_cache[2] = ($event) => _ctx.hoveredOption = $event),
            style: { maxHeight: _ctx.$props.maxHeight },
            id: _ctx.popupId
          }, _ctx.optionsListPropsComputed, {
            onSelectOption: _ctx.selectHoveredOption,
            onNoPreviousOptionToHover: _ctx.focusSearchBar,
            onKeydown: [
              _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.searchBar && _ctx.searchBar.focus(), ["stop", "prevent"]), ["tab"])),
              _ctx.onHintedSearch
            ],
            onScrollBottom: _ctx.onScrollBottom
          }), {
            default: withCtx((slotData) => [
              renderSlot(_ctx.$slots, "option", normalizeProps(guardReactiveProps(slotData || {})))
            ]),
            _: 3
          }, 16, ["hoveredOption", "style", "id", "onSelectOption", "onNoPreviousOptionToHover", "onKeydown", "onScrollBottom"])
        ]),
        _: 3
      }, 8, ["style", "onKeydown"])
    ]),
    _: 3
  }, 16, ["modelValue"]);
}
var _VaSelect = _export_sfc(_sfc_main91, [["render", _sfc_render88]]);

// node_modules/vuestic-ui/dist/es/src/components/va-select/index.js
var VaSelect = withConfigTransport$1(_VaSelect);

// node_modules/vuestic-ui/dist/es/src/components/va-separator/VaSeparator.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSeparator.css";
var _sfc_main92 = defineComponent({
  name: "VaSeparator"
});

// node_modules/vuestic-ui/dist/es/src/components/va-separator/VaSeparator.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSeparator.css";
var _hoisted_156 = {
  class: "va-separator",
  "aria-hidden": "true"
};
function _sfc_render89(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_156);
}
var VaSeparator = _export_sfc(_sfc_main92, [["render", _sfc_render89]]);

// node_modules/vuestic-ui/dist/es/src/components/va-skeleton/VaSkeleton.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSkeleton.css";
var _sfc_main93 = defineComponent({
  name: "VaSkeleton",
  props: {
    color: { type: String, default: "backgroundElement" },
    delay: { type: Number, default: 100 },
    tag: { type: String, default: "div" },
    animation: { type: String, default: "pulse" },
    lines: { type: [String, Number], default: 1 },
    height: { type: [String], default: "5em" },
    width: { type: [String], default: "100%" },
    lineGap: { type: String, default: "8px" },
    lastLineWidth: { type: [String], default: "75%" },
    variant: { type: String, default: "squared" },
    ariaLabel: { type: String, default: "$t:loading" }
  },
  setup(props2, { attrs }) {
    const doShow = ref(false);
    let timeoutId;
    onMounted(() => {
      clearTimeout(timeoutId);
      setTimeout(() => {
        doShow.value = true;
      }, props2.delay);
    });
    onBeforeUnmount(() => {
      clearTimeout(timeoutId);
    });
    const heightComputed = computed(() => {
      if (props2.variant === "text") {
        return `${props2.lines}em`;
      }
      return props2.height;
    });
    const widthComputed = computed(() => {
      if (props2.variant === "circle") {
        return heightComputed.value;
      }
      return props2.width;
    });
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props2.color));
    const negativeLineGap = computed(() => `-${props2.lineGap}`);
    const bem = useBem("va-skeleton", () => ({
      lines: Number(props2.lines) > 1,
      text: props2.variant === "text",
      circle: props2.variant === "circle",
      hidden: !doShow.value,
      pulse: props2.animation === "pulse",
      wave: props2.animation === "wave"
    }));
    const borderRadius = computed(() => {
      if (props2.variant === "circle") {
        return "50%";
      }
      if (props2.variant === "rounded") {
        return `var(--va-skeleton-border-radius, calc(${heightComputed.value} / 5))`;
      }
      return "0px";
    });
    return {
      ...useTranslation(),
      classes: computed(() => [
        ...Object.keys(bem),
        attrs.class
      ]),
      colorComputed,
      negativeLineGap,
      doShow,
      heightComputed,
      widthComputed,
      borderRadius
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-skeleton/VaSkeleton.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSkeleton.css";
var _hoisted_157 = {
  key: 0,
  class: "va-skeleton__wave"
};
function _sfc_render90(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
    class: normalizeClass(["va-skeleton", _ctx.classes]),
    role: "status",
    "aria-live": "polite",
    "aria-label": _ctx.tp(_ctx.$props.ariaLabel),
    "aria-atomic": "true",
    style: normalizeStyle(`--va-color-computed: ${String(_ctx.colorComputed)};--va-height-computed: ${String(_ctx.heightComputed)};--va-width-computed: ${String(_ctx.widthComputed)};--va-border-radius: ${String(_ctx.borderRadius)};--va-line-gap: ${String(_ctx.lineGap)};--va-last-line-width: ${String(_ctx.lastLineWidth)}`)
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default"),
      _ctx.animation === "wave" ? (openBlock(), createElementBlock("div", _hoisted_157)) : createCommentVNode("", true)
    ]),
    _: 3
  }, 8, ["aria-label", "class", "style"]);
}
var _VaSkeleton = _export_sfc(_sfc_main93, [["render", _sfc_render90]]);

// node_modules/vuestic-ui/dist/es/src/components/va-skeleton/components/VaSkeletonGroup.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSkeletonGroup.css";
var _sfc_main94 = defineComponent({
  name: "VaSkeletonGroup",
  components: {
    VaConfig
  },
  props: {
    color: { type: String, default: "backgroundElement" },
    delay: { type: Number, default: 100 },
    animation: { type: String, default: "pulse" },
    lines: { type: Number, default: 1 },
    lineGap: { type: String, default: "8px" },
    lastLineWidth: { type: [String], default: "75%" }
  },
  setup(props2) {
    const doShow = ref(false);
    let timeoutId;
    onMounted(() => {
      timeoutId = setTimeout(() => {
        doShow.value = true;
      }, props2.delay);
    });
    onBeforeMount(() => {
      clearTimeout(timeoutId);
    });
    const bem = useBem("va-skeleton-group", () => ({
      hidden: doShow.value === false
    }));
    return {
      doShow,
      bem,
      config: computed(() => ({ ...props2, delay: 0 }))
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-skeleton/components/VaSkeletonGroup.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSkeletonGroup.css";
function _sfc_render91(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaConfig = resolveComponent("VaConfig");
  return openBlock(), createBlock(_component_VaConfig, {
    components: { VaSkeleton: _ctx.config }
  }, {
    default: withCtx(() => [
      createBaseVNode("div", mergeProps({
        class: ["va-skeleton-group", _ctx.bem]
      }, _ctx.$attrs), [
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ], 16)
    ]),
    _: 3
  }, 8, ["components"]);
}
var _VaSkeletonGroup = _export_sfc(_sfc_main94, [["render", _sfc_render91], ["__scopeId", "data-v-5fabb1f3"]]);

// node_modules/vuestic-ui/dist/es/src/components/va-skeleton/index.js
var VaSkeleton = withConfigTransport$1(_VaSkeleton);
var VaSkeletonGroup = withConfigTransport$1(_VaSkeletonGroup);

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/hooks/useSidebar.js
var VaSidebarKey = Symbol("VaSidebar");
var useSidebar = (props2) => {
  provide(VaSidebarKey, props2);
};
var useSidebarItem = () => {
  return inject(VaSidebarKey, {
    color: "background-element"
    // activeColor: 'primary',
  });
};

// node_modules/vuestic-ui/dist/es/src/composables/useElementWidth.js
var useElementWidth = (el) => {
  const width = ref(null);
  useResizeObserver([el], () => {
    var _a2;
    width.value = ((_a2 = el.value) == null ? void 0 : _a2.clientWidth) ?? null;
  });
  watchEffect(() => {
    var _a2;
    width.value = ((_a2 = el.value) == null ? void 0 : _a2.clientWidth) ?? null;
  });
  return width;
};

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/VaSidebar.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSidebar.css";
var _sfc_main95 = defineComponent({
  name: "VaSidebar",
  props: {
    ...useComponentPresetProp,
    activeColor: { type: String, default: "primary" },
    hoverColor: { type: String, default: void 0 },
    hoverOpacity: {
      type: Number,
      default: 0.2,
      validator: (v2) => v2 >= 0 && v2 <= 1
    },
    borderColor: { type: String, default: void 0 },
    color: { type: String, default: "background-element" },
    textColor: { type: String },
    gradient: { type: Boolean, default: false },
    minimized: { type: Boolean, default: false },
    hoverable: { type: Boolean, default: false },
    width: { type: String, default: "16rem" },
    minimizedWidth: { type: String, default: "4rem" },
    modelValue: { type: Boolean, default: true },
    animated: { type: [Boolean, String], default: true },
    closeOnClickOutside: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"],
  components: { VaConfig },
  setup(props2, { emit }) {
    const { getColor } = useColors();
    useSidebar(props2);
    const isHovered = ref(false);
    const isMinimized = computed(() => props2.minimized || props2.hoverable && !isHovered.value);
    const menu = ref();
    const currentMenuWidth = useElementWidth(menu);
    const doShowMenu = computed(() => {
      if (props2.modelValue === true) {
        return true;
      }
      if (currentMenuWidth.value === null) {
        return true;
      }
      return currentMenuWidth.value > 0;
    });
    const sidebarWidth = ref();
    const getSidebarWidth = () => {
      if (!props2.modelValue) {
        return 0;
      }
      return isMinimized.value ? props2.minimizedWidth : props2.width;
    };
    const menuWidth = computed(() => isMinimized.value ? props2.minimizedWidth : props2.width);
    watchEffect(() => {
      const width = getSidebarWidth();
      setTimeout(() => {
        sidebarWidth.value = width;
      });
    });
    const backgroundColorComputed = computed(() => getColor(props2.color));
    const { textColorComputed } = useTextColor(backgroundColorComputed);
    const computedStyle = computed(() => {
      const backgroundColor = getColor(backgroundColorComputed.value);
      const color = textColorComputed.value;
      return {
        color,
        backgroundColor,
        backgroundImage: props2.gradient ? getGradientBackground(backgroundColor) : void 0,
        overflowX: currentMenuWidth.value === sidebarWidth.value ? void 0 : "hidden",
        width: sidebarWidth.value,
        minWidth: sidebarWidth.value
      };
    });
    const computedClass = useBem("va-sidebar", () => ({
      minimized: isMinimized.value,
      animated: Boolean(props2.animated),
      "animated-right": props2.animated === "right",
      "animated-left": props2.animated === "left" || props2.animated === true
    }));
    const updateHoverState = (newHoverState) => {
      isHovered.value = props2.hoverable && newHoverState;
    };
    const rootElement = shallowRef();
    useClickOutside([rootElement], () => {
      if (props2.closeOnClickOutside && props2.modelValue) {
        setTimeout(() => {
          emit("update:modelValue", false);
        }, 0);
      }
    });
    return {
      menu,
      menuWidth,
      doShowMenu,
      computedClass,
      computedStyle,
      updateHoverState,
      rootElement,
      vaSidebarItemProps: computed(() => ({
        textColor: props2.textColor,
        activeColor: props2.activeColor,
        hoverColor: props2.hoverColor,
        borderColor: props2.borderColor,
        hoverOpacity: props2.hoverOpacity
      }))
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/VaSidebar.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSidebar.css";
function _sfc_render92(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_config = resolveComponent("va-config");
  return openBlock(), createElementBlock("aside", {
    ref: "rootElement",
    class: normalizeClass(["va-sidebar", _ctx.computedClass]),
    style: normalizeStyle(_ctx.computedStyle),
    onMouseenter: _cache[0] || (_cache[0] = ($event) => _ctx.updateHoverState(true)),
    onMouseleave: _cache[1] || (_cache[1] = ($event) => _ctx.updateHoverState(false))
  }, [
    withDirectives(createBaseVNode("div", {
      class: "va-sidebar__menu",
      ref: "menu",
      style: normalizeStyle({
        width: _ctx.menuWidth,
        minWidth: _ctx.menuWidth
      })
    }, [
      createVNode(_component_va_config, {
        components: { VaSidebarItem: _ctx.vaSidebarItemProps }
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["components"])
    ], 4), [
      [vShow, _ctx.doShowMenu]
    ])
  ], 38);
}
var _VaSidebar = _export_sfc(_sfc_main95, [["render", _sfc_render92]]);

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/index.js
var VaSidebar = withConfigTransport$1(_VaSidebar);

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/VaSidebarItem/VaSidebarItem.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSidebarItem.css";
var _sfc_main96 = defineComponent({
  name: "VaSidebarItem",
  props: {
    ...useRouterLinkProps,
    ...useComponentPresetProp,
    active: { type: Boolean, default: false },
    textColor: { type: String, default: void 0 },
    activeColor: { type: String, default: "primary" },
    hoverColor: { type: String, default: void 0 },
    hoverOpacity: { type: [Number, String], default: 0.2 },
    borderColor: { type: String, default: void 0 }
  },
  setup(props2) {
    const rootElement = useElementRef();
    const sidebar = useSidebarItem();
    const { isHovered } = useHover(rootElement);
    const { getColor, getHoverColor: getHoverColor2, getFocusColor: getFocusColor2 } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const backgroundColorComputed = computed(() => {
      if (props2.active && !isHovered.value && !hasKeyboardFocus.value) {
        return getColor(props2.activeColor);
      }
      if (hasKeyboardFocus.value) {
        return getFocusColor2(getColor(props2.hoverColor || props2.activeColor));
      }
      return "#ffffff00";
    });
    const textBackground = computed(() => applyColors(getColor(sidebar == null ? void 0 : sidebar.color), backgroundColorComputed.value));
    const { textColorComputed } = useTextColor(textBackground);
    const computedStyle = computed(() => {
      const style = { color: textColorComputed.value };
      if (isHovered.value || props2.active || hasKeyboardFocus.value) {
        style.backgroundColor = backgroundColorComputed.value;
      }
      if (props2.active) {
        const mergedProps = { ...sidebar, ...props2 };
        style.borderColor = getColor(mergedProps.borderColor || mergedProps.activeColor);
      }
      if (hasKeyboardFocus.value) {
        style.backgroundColor = getFocusColor2(getColor(props2.hoverColor || props2.activeColor));
      }
      if (isHovered.value) {
        style.backgroundColor = getHoverColor2(
          getColor(props2.hoverColor || props2.activeColor),
          Number(props2.hoverOpacity)
        );
      }
      return style;
    });
    const { tagComputed, hrefComputed, linkAttributesComputed } = useRouterLink(props2);
    return {
      rootElement,
      computedStyle,
      keyboardFocusListeners,
      tagComputed,
      hrefComputed,
      isHovered,
      backgroundColorComputed,
      bg: getColor(sidebar == null ? void 0 : sidebar.color),
      textBackground,
      linkAttributesComputed
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/VaSidebarItem/VaSidebarItem.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSidebarItem.css";
function _sfc_render93(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), mergeProps({
    ref: "rootElement",
    class: ["va-sidebar__item va-sidebar-item", { "va-sidebar-item--active": _ctx.$props.active }],
    tabindex: "0",
    style: _ctx.computedStyle
  }, _ctx.linkAttributesComputed, toHandlers(_ctx.keyboardFocusListeners)), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16, ["class", "style"]);
}
var _VaSidebarItem = _export_sfc(_sfc_main96, [["render", _sfc_render93]]);

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/VaSidebarItem/VaSidebarItemContent.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSidebarItemContent.css";
var _sfc_main97 = defineComponent({
  name: "VaSidebarItemContent"
});

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/VaSidebarItem/VaSidebarItemContent.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSidebarItemContent.css";
var _hoisted_158 = { class: "va-sidebar__item__content va-sidebar-item-content" };
function _sfc_render94(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_158, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var _VaSidebarItemContent = _export_sfc(_sfc_main97, [["render", _sfc_render94]]);

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/VaSidebarItem/VaSidebarItemTitle.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSidebarItemTitle.css";
var _sfc_main98 = defineComponent({
  name: "VaSidebarItemTitle"
});

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/VaSidebarItem/VaSidebarItemTitle.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSidebarItemTitle.css";
var _hoisted_159 = { class: "va-sidebar__title va-sidebar-item-title" };
function _sfc_render95(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_159, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var _VaSidebarItemTitle = _export_sfc(_sfc_main98, [["render", _sfc_render95]]);

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/VaSidebarItem/index.js
var VaSidebarItemContent = withConfigTransport$1(_VaSidebarItemContent);
var VaSidebarItemTitle = withConfigTransport$1(_VaSidebarItemTitle);
var VaSidebarItem = withConfigTransport$1(_VaSidebarItem);

// node_modules/vuestic-ui/dist/es/src/components/va-slider/validateSlider.js
var validateSlider = (value, step, min2, max2, range) => {
  if (Array.isArray(value) && !range || !Array.isArray(value) && range) {
    warn(`The type "${Array.isArray(value) ? "array" : typeof value}" of prop "model-value" does not match prop "range = ${range}".`);
  }
  if (max2 < min2) {
    warn(`The maximum value (${max2}) can not be less than the minimum value (${min2}).`);
  }
  if ((max2 - min2) % step !== 0) {
    warn(`Step ${step} is illegal. Slider is non-divisible (Min:Max-${min2}:${max2}).`);
  }
  const inRange = (v2) => {
    if (v2 < min2) {
      warn(`The value of the slider is ${v2}, the minimum value is ${min2}, the value of this slider can not be less than the minimum value`);
    } else if (v2 > max2) {
      warn(`The value of the slider is ${v2}, the maximum value is ${max2}, the value of this slider can not be greater than the maximum value`);
    }
  };
  if (Array.isArray(value)) {
    value.map(inRange);
  } else {
    inRange(value);
  }
  return true;
};

// node_modules/vuestic-ui/dist/es/src/components/va-slider/VaSlider.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSlider.css";
var _sfc_main99 = defineComponent({
  name: "VaSlider",
  components: { VaIcon },
  emits: ["drag-start", "drag-end", "change", "update:modelValue"],
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    range: { type: Boolean, default: false },
    modelValue: { type: [Number, Array], default: 0 },
    trackLabel: { type: [Function, String] },
    color: { type: String, default: "primary" },
    trackColor: { type: String, default: "" },
    labelColor: { type: String, default: "" },
    trackLabelVisible: { type: Boolean, default: false },
    min: { type: Number, default: 0 },
    max: { type: Number, default: 100 },
    step: { type: Number, default: 1 },
    label: { type: String, default: "" },
    invertLabel: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    pins: { type: Boolean, default: false },
    iconPrepend: { type: String, default: "" },
    iconAppend: { type: String, default: "" },
    vertical: { type: Boolean, default: false },
    showTrack: { type: Boolean, default: true },
    ariaLabel: { type: String, default: "$t:sliderValue" }
  },
  setup(props2, { emit, slots }) {
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const sliderContainer = shallowRef();
    const dot = shallowRef();
    const { setItemRefByIndex, itemRefs: dots } = useArrayRefs();
    const isFocused = ref(false);
    const flag = ref(false);
    const offset2 = ref(0);
    const size3 = ref(0);
    const defaultValue = props2.range ? [0, 100] : 0;
    const { valueComputed } = useStateful(props2, emit, "modelValue", { defaultValue });
    const currentSliderDotIndex = ref(0);
    const hasMouseDown = ref(false);
    const orders = computed(() => props2.vertical ? [1, 0] : [0, 1]);
    const pinPositionStyle = computed(() => props2.vertical ? "bottom" : "left");
    const trackSizeStyle = computed(() => props2.vertical ? "height" : "width");
    const moreToLess = computed(() => Array.isArray(val.value) && val.value[1] - props2.step < val.value[0]);
    const lessToMore = computed(() => Array.isArray(val.value) && val.value[0] + props2.step > val.value[1]);
    const sliderClass = useBem("va-slider", () => ({
      ...pick$1(props2, ["disabled", "readonly", "vertical"]),
      active: isFocused.value,
      horizontal: !props2.vertical,
      grabbing: hasMouseDown.value
    }));
    const dotClass = useBem("va-slider__handler", () => ({
      onFocus: !props2.range && (flag.value || isFocused.value),
      inactive: !isFocused.value
    }));
    const labelStyles = computed(() => ({
      color: props2.labelColor ? getColor(props2.labelColor) : getColor(props2.color)
    }));
    const trackStyles = computed(() => ({
      backgroundColor: props2.trackColor ? getColor(props2.trackColor) : getHoverColor2(getColor(props2.color))
    }));
    const processedStyles = computed(() => {
      if (Array.isArray(val.value)) {
        const val0 = (val.value[0] - props2.min) / (props2.max - props2.min) * 100;
        const val1 = (val.value[1] - props2.min) / (props2.max - props2.min) * 100;
        return {
          [pinPositionStyle.value]: `${val0}%`,
          [trackSizeStyle.value]: `${val1 - val0}%`,
          backgroundColor: getColor(props2.color),
          visibility: props2.showTrack ? "visible" : "hidden"
        };
      } else {
        const val0 = (val.value - props2.min) / (props2.max - props2.min) * 100;
        return {
          [trackSizeStyle.value]: `${val0}%`,
          backgroundColor: getColor(props2.color),
          visibility: props2.showTrack ? "visible" : "hidden"
        };
      }
    });
    const dottedStyles = computed(() => {
      if (Array.isArray(val.value)) {
        const val0 = (val.value[0] - props2.min) / (props2.max - props2.min) * 100;
        const val1 = (val.value[1] - props2.min) / (props2.max - props2.min) * 100;
        return [
          {
            [pinPositionStyle.value]: `${val0}%`,
            backgroundColor: isActiveDot(0) ? getColor(props2.color) : "#ffffff",
            borderColor: getColor(props2.color)
          },
          {
            [pinPositionStyle.value]: `${val1}%`,
            backgroundColor: isActiveDot(1) ? getColor(props2.color) : "#ffffff",
            borderColor: getColor(props2.color)
          }
        ];
      } else {
        const val0 = (val.value - props2.min) / (props2.max - props2.min) * 100;
        return {
          [pinPositionStyle.value]: `${val0}%`,
          backgroundColor: isActiveDot(0) ? getColor(props2.color) : "#ffffff",
          borderColor: getColor(props2.color)
        };
      }
    });
    const getDottedStyles = (index) => props2.range ? dottedStyles.value[index] : dottedStyles.value;
    const val = computed({
      get: () => valueComputed.value,
      set: (val2) => {
        if (!flag.value) {
          emit("change", val2);
        }
        valueComputed.value = val2;
      }
    });
    const getValueByOrder = (order) => props2.range && order !== void 0 ? val.value[order] : val.value;
    const gap = computed(() => {
      const total = (props2.max - props2.min) / props2.step;
      return size3.value / total;
    });
    const multiple = computed(() => {
      const decimals = `${props2.step}`.split(".")[1];
      return decimals ? Math.pow(10, decimals.length) : 1;
    });
    const pinsCol = computed(() => (props2.max - props2.min) / props2.step - 1);
    const position = computed(() => {
      return Array.isArray(val.value) ? [(val.value[0] - props2.min) / props2.step * gap.value, (val.value[1] - props2.min) / props2.step * gap.value] : (val.value - props2.min) / props2.step * gap.value;
    });
    const limit = computed(() => [0, size3.value]);
    const valueLimit = computed(() => [props2.min, props2.max]);
    const isActiveDot = (index) => {
      if (!isFocused.value && !flag.value || props2.disabled || props2.readonly) {
        return false;
      }
      return props2.range ? currentSliderDotIndex.value === index : currentSliderDotIndex.value === 0;
    };
    const moveStart = (e2, index = currentSliderDotIndex.value) => {
      var _a2, _b;
      e2.preventDefault();
      if (!index) {
        if (!props2.range) {
          index = 0;
        } else if (Array.isArray(position.value)) {
          const touch = "touches" in e2 ? e2.touches[0] : e2;
          const pos = getPos(touch);
          index = pos > (position.value[1] - position.value[0]) / 2 + position.value[0] ? 1 : 0;
        }
      }
      if (Array.isArray(val.value)) {
        currentSliderDotIndex.value = index;
      }
      Array.isArray(val.value) ? (_a2 = dots.value[index]) == null ? void 0 : _a2.focus() : (_b = dot.value) == null ? void 0 : _b.focus();
      flag.value = true;
      emit("drag-start");
    };
    const moving = (e2) => {
      if (!hasMouseDown.value || !flag.value || props2.disabled || props2.readonly) {
        return;
      }
      e2.preventDefault();
      if ("touches" in e2) {
        setValueOnPos(getPos(e2.touches[0]));
      } else {
        setValueOnPos(getPos(e2));
      }
    };
    const moveEnd = () => {
      if (!props2.disabled && !props2.readonly) {
        if (flag.value) {
          emit("drag-end");
          emit("change", val.value);
        }
        flag.value = false;
        hasMouseDown.value = false;
      }
    };
    const clamp3 = (min2, v2, max2) => Math.max(Math.min(v2, max2), min2);
    const moveWithKeys = (event) => {
      var _a2, _b;
      if (![dots.value[0], dots.value[1], dot.value].includes(document.activeElement)) {
        return;
      }
      if (props2.disabled || props2.readonly) {
        return;
      }
      const moveDot = (where, which) => {
        if (Array.isArray(val.value)) {
          const value = val.value[which] + (where ? props2.step : -props2.step);
          const limitedValue = clamp3(props2.min, value, props2.max);
          val.value = [
            which === 0 ? limitedValue : val.value[0],
            which === 1 ? limitedValue : val.value[1]
          ];
        } else {
          const value = val.value + (where ? props2.step : -props2.step);
          const limitedValue = clamp3(props2.min, value, props2.max);
          val.value = limitedValue;
        }
      };
      if (["ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown"].includes(event.key)) {
        event.preventDefault();
      }
      const isActive = (el) => el === document.activeElement;
      if (props2.range && Array.isArray(val.value)) {
        const isVerticalDot0More = (event2) => props2.vertical && isActive(dots.value[0]) && event2.key === "ArrowUp";
        const isVerticalDot0Less = (event2) => props2.vertical && isActive(dots.value[0]) && event2.key === "ArrowDown";
        const isVerticalDot1More = (event2) => props2.vertical && isActive(dots.value[1]) && event2.key === "ArrowUp";
        const isVerticalDot1Less = (event2) => props2.vertical && isActive(dots.value[1]) && event2.key === "ArrowDown";
        const isHorizontalDot0Less = (event2) => !props2.vertical && isActive(dots.value[0]) && event2.key === "ArrowLeft";
        const isHorizontalDot0More = (event2) => !props2.vertical && isActive(dots.value[0]) && event2.key === "ArrowRight";
        const isHorizontalDot1Less = (event2) => !props2.vertical && isActive(dots.value[1]) && event2.key === "ArrowLeft";
        const isHorizontalDot1More = (event2) => !props2.vertical && isActive(dots.value[1]) && event2.key === "ArrowRight";
        switch (true) {
          case ((isVerticalDot1Less(event) || isHorizontalDot1Less(event)) && moreToLess.value && val.value[0] !== props2.min):
            (_a2 = dots.value[0]) == null ? void 0 : _a2.focus();
            moveDot(0, 0);
            break;
          case ((isVerticalDot0More(event) || isHorizontalDot0More(event)) && lessToMore.value && val.value[1] !== props2.max):
            (_b = dots.value[1]) == null ? void 0 : _b.focus();
            moveDot(1, 1);
            break;
          case ((isVerticalDot0Less(event) || isHorizontalDot0Less(event)) && val.value[0] !== props2.min):
            moveDot(0, 0);
            break;
          case ((isVerticalDot1More(event) || isHorizontalDot1More(event)) && val.value[1] !== props2.max):
            moveDot(1, 1);
            break;
          case ((isVerticalDot1Less(event) || isHorizontalDot1Less(event)) && val.value[1] !== props2.min):
            moveDot(0, 1);
            break;
          case ((isVerticalDot0More(event) || isHorizontalDot0More(event)) && val.value[0] !== props2.max):
            moveDot(1, 0);
            break;
        }
      } else {
        if (props2.vertical) {
          if (event.key === "ArrowDown") {
            moveDot(0, 0);
          }
          if (event.key === "ArrowUp") {
            moveDot(1, 0);
          }
        } else {
          if (event.key === "ArrowLeft") {
            moveDot(0, 0);
          }
          if (event.key === "ArrowRight") {
            moveDot(1, 0);
          }
        }
      }
    };
    const checkActivePin = (pin) => {
      if (Array.isArray(val.value)) {
        return pin * props2.step > val.value[0] && pin * props2.step < val.value[1];
      } else {
        return pin * props2.step < val.value;
      }
    };
    const pinPositionStep = computed(() => props2.step / (props2.max - props2.min) * 100);
    const getPinStyles = (pin) => ({
      backgroundColor: checkActivePin(pin) ? getColor(props2.color) : getHoverColor2(getColor(props2.color)),
      [pinPositionStyle.value]: `${pin * pinPositionStep.value}%`,
      transition: hasMouseDown.value ? "none" : "var(--va-slider-pin-transition)"
    });
    const getPos = (e2) => {
      getStaticData();
      return props2.vertical ? offset2.value - e2.clientY : e2.clientX - offset2.value;
    };
    const getStaticData = () => {
      if (sliderContainer.value) {
        size3.value = sliderContainer.value[props2.vertical ? "offsetHeight" : "offsetWidth"];
        offset2.value = sliderContainer.value.getBoundingClientRect()[pinPositionStyle.value];
      }
    };
    const getValueByIndex = (index) => {
      return (props2.step * multiple.value * index + props2.min * multiple.value) / multiple.value;
    };
    const getTrackLabel = (val2, order) => {
      if (!props2.trackLabel) {
        return val2;
      }
      return typeof props2.trackLabel === "function" ? props2.trackLabel(val2, order) : props2.trackLabel;
    };
    const setCurrentValue = (newValue) => {
      const slider = currentSliderDotIndex.value;
      if (Array.isArray(val.value)) {
        if (isDiff(val.value[slider], newValue)) {
          if (slider === 0) {
            val.value = [newValue, val.value[1]];
          } else {
            val.value = [val.value[0], newValue];
          }
        }
      } else {
        if (newValue < props2.min) {
          val.value = props2.min;
        } else if (newValue > props2.max) {
          val.value = props2.max;
        } else if (isDiff(val.value, newValue)) {
          val.value = newValue;
        }
      }
    };
    const setValueOnPos = (pixelPosition) => {
      const range = limit.value;
      const valueRange = valueLimit.value;
      const dotToFocus = Array.isArray(val.value) ? dots.value[currentSliderDotIndex.value] : dot.value;
      dotToFocus == null ? void 0 : dotToFocus.focus();
      if (pixelPosition >= range[0] && pixelPosition <= range[1]) {
        const v2 = getValueByIndex(Math.round(pixelPosition / gap.value));
        if (currentSliderDotIndex.value) {
          if (Array.isArray(position.value) && Array.isArray(val.value) && pixelPosition <= position.value[0]) {
            val.value = [v2, val.value[0]];
            currentSliderDotIndex.value = 0;
          } else {
            setCurrentValue(v2);
          }
        } else {
          if (Array.isArray(position.value) && Array.isArray(val.value) && pixelPosition >= position.value[1]) {
            val.value = [val.value[1], v2];
            currentSliderDotIndex.value = 1;
          } else {
            setCurrentValue(v2);
          }
        }
      } else if (pixelPosition < range[0]) {
        setCurrentValue(valueRange[0]);
      } else {
        setCurrentValue(valueRange[1]);
      }
    };
    const isDiff = (a2, b2) => JSON.stringify(a2) !== JSON.stringify(b2);
    const clickOnContainer = (e2) => {
      if (props2.disabled || props2.readonly) {
        return;
      }
      const pos = "touches" in e2 ? getPos(e2.touches[0]) : getPos(e2);
      if (Array.isArray(position.value)) {
        currentSliderDotIndex.value = pos > (position.value[1] - position.value[0]) / 2 + position.value[0] ? 1 : 0;
      }
      hasMouseDown.value = true;
      setValueOnPos(pos);
      moveStart(e2, currentSliderDotIndex.value);
    };
    const bindEvents = () => {
      document.addEventListener("mousemove", moving);
      document.addEventListener("touchmove", moving, { passive: false });
      document.addEventListener("mouseup", moveEnd);
      document.addEventListener("mouseleave", moveEnd);
      document.addEventListener("touchcancel", moveEnd);
      document.addEventListener("touchend", moveEnd);
      document.addEventListener("keydown", moveWithKeys);
    };
    const unbindEvents = () => {
      document.removeEventListener("mousemove", moving);
      document.removeEventListener("touchmove", moving);
      document.removeEventListener("mouseup", moveEnd);
      document.removeEventListener("mouseleave", moveEnd);
      document.removeEventListener("touchcancel", moveEnd);
      document.removeEventListener("touchend", moveEnd);
      document.removeEventListener("keydown", moveWithKeys);
    };
    const ariaLabelIdComputed = computed(() => `aria-label-id-${generateUniqueId()}`);
    const { tp } = useTranslation();
    const ariaAttributesComputed = computed(() => ({
      role: "slider",
      "aria-valuemin": props2.min,
      "aria-valuemax": props2.max,
      "aria-label": !slots.label && !props2.label ? tp(props2.ariaLabel, { value: String(val.value) }) : void 0,
      "aria-labelledby": slots.label || props2.label ? ariaLabelIdComputed.value : void 0,
      "aria-orientation": props2.vertical ? "vertical" : "horizontal",
      "aria-disabled": props2.disabled,
      "aria-readonly": props2.readonly,
      "aria-valuenow": !Array.isArray(val.value) ? val.value : void 0,
      "aria-valuetext": Array.isArray(val.value) ? String(val.value) : void 0
    }));
    onMounted(() => {
      if (validateSlider(val.value, props2.step, props2.min, props2.max, props2.range)) {
        getStaticData();
        bindEvents();
      }
    });
    onBeforeUnmount(unbindEvents);
    watch([
      val,
      () => props2.step,
      () => props2.min,
      () => props2.max,
      () => props2.range
    ], ([value, step, min2, max2, range]) => {
      validateSlider(value, step, min2, max2, range);
    });
    watch(hasMouseDown, (hasMouseDown2) => {
      document.documentElement.style.cursor = hasMouseDown2 ? "grabbing" : "";
    });
    return {
      getColor,
      dot,
      dots,
      setItemRefByIndex,
      orders,
      sliderContainer,
      val,
      getValueByOrder,
      sliderClass,
      dotClass,
      labelStyles,
      processedStyles,
      getPinStyles,
      dottedStyles,
      getDottedStyles,
      clickOnContainer,
      hasMouseDown,
      trackStyles,
      pinsCol,
      checkActivePin,
      isFocused,
      isActiveDot,
      getTrackLabel,
      currentSliderDotIndex,
      ariaLabelIdComputed,
      ariaAttributesComputed
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-slider/VaSlider.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSlider.css";
var _hoisted_160 = {
  key: 0,
  class: "va-slider__input-wrapper",
  "aria-hidden": "true"
};
var _hoisted_229 = ["id"];
var _hoisted_320 = {
  key: 2,
  class: "va-input__label",
  "aria-hidden": "true"
};
var _hoisted_411 = ["tabindex", "onFocus"];
var _hoisted_58 = ["tabindex"];
var _hoisted_66 = {
  key: 3,
  class: "va-input__label--inverse",
  "aria-hidden": "true"
};
var _hoisted_74 = ["id"];
var _hoisted_83 = {
  key: 5,
  class: "va-slider__input-wrapper"
};
function _sfc_render96(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", mergeProps({
    class: ["va-slider", _ctx.sliderClass]
  }, _ctx.ariaAttributesComputed), [
    (_ctx.vertical ? _ctx.$slots.append : _ctx.$slots.prepend) ? (openBlock(), createElementBlock("div", _hoisted_160, [
      renderSlot(_ctx.$slots, _ctx.vertical ? "append" : "prepend")
    ])) : createCommentVNode("", true),
    (_ctx.$slots.label || _ctx.label) && !_ctx.invertLabel ? (openBlock(), createElementBlock("span", {
      key: 1,
      class: "va-input__label",
      id: _ctx.ariaLabelIdComputed,
      style: normalizeStyle(_ctx.labelStyles)
    }, [
      renderSlot(_ctx.$slots, "label", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ], 12, _hoisted_229)) : createCommentVNode("", true),
    (_ctx.vertical ? _ctx.iconAppend : _ctx.iconPrepend) ? (openBlock(), createElementBlock("span", _hoisted_320, [
      createVNode(_component_va_icon, {
        name: _ctx.vertical ? _ctx.iconAppend : _ctx.iconPrepend,
        color: _ctx.getColor(_ctx.$props.color),
        size: 16
      }, null, 8, ["name", "color"])
    ])) : createCommentVNode("", true),
    createBaseVNode("div", {
      ref: "sliderContainer",
      class: "va-slider__container",
      onMousedown: _cache[3] || (_cache[3] = (...args) => _ctx.clickOnContainer && _ctx.clickOnContainer(...args)),
      onTouchstart: _cache[4] || (_cache[4] = (...args) => _ctx.clickOnContainer && _ctx.clickOnContainer(...args))
    }, [
      createBaseVNode("div", {
        class: "va-slider__track",
        "aria-hidden": "true",
        style: normalizeStyle(_ctx.trackStyles)
      }, null, 4),
      _ctx.pins ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.pinsCol, (pin, i2) => {
        return openBlock(), createElementBlock("div", {
          key: i2,
          class: normalizeClass(["va-slider__mark", { "va-slider__mark--active": _ctx.checkActivePin(pin) }]),
          style: normalizeStyle(_ctx.getPinStyles(pin))
        }, null, 6);
      }), 128)) : createCommentVNode("", true),
      _ctx.$props.range ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        createBaseVNode("div", {
          ref: "process",
          class: normalizeClass(["va-slider__track va-slider__track--selected", { "va-slider__track--active": _ctx.isFocused }]),
          "aria-hidden": "true",
          style: normalizeStyle(_ctx.processedStyles)
        }, null, 6),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.orders, (order) => {
          return openBlock(), createElementBlock("div", {
            key: "dot" + order,
            ref_for: true,
            ref: _ctx.setItemRefByIndex(order),
            class: normalizeClass(["va-slider__handler", _ctx.dotClass]),
            style: normalizeStyle(_ctx.getDottedStyles(order)),
            tabindex: _ctx.disabled || _ctx.readonly ? void 0 : 0,
            onFocus: ($event) => (_ctx.isFocused = true, _ctx.currentSliderDotIndex = order),
            onBlur: _cache[0] || (_cache[0] = ($event) => _ctx.isFocused = false)
          }, [
            _ctx.isActiveDot(order) ? (openBlock(), createElementBlock("div", {
              key: 0,
              style: normalizeStyle({ backgroundColor: _ctx.getColor(_ctx.$props.color) }),
              class: "va-slider__handler__dot--focus"
            }, null, 4)) : createCommentVNode("", true),
            _ctx.trackLabelVisible ? (openBlock(), createElementBlock("div", {
              key: 1,
              style: normalizeStyle(_ctx.labelStyles),
              class: "va-slider__handler__dot--value"
            }, [
              renderSlot(_ctx.$slots, "trackLabel", normalizeProps(guardReactiveProps({ value: _ctx.getValueByOrder(order), order })), () => [
                createTextVNode(toDisplayString(_ctx.getTrackLabel(_ctx.getValueByOrder(order), order)), 1)
              ])
            ], 4)) : createCommentVNode("", true)
          ], 46, _hoisted_411);
        }), 128))
      ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
        createBaseVNode("div", {
          ref: "process",
          "aria-hidden": "true",
          class: normalizeClass(["va-slider__track va-slider__track--selected", { "va-slider__track--active": _ctx.isFocused }]),
          style: normalizeStyle(_ctx.processedStyles)
        }, null, 6),
        createBaseVNode("div", {
          ref: "dot",
          class: normalizeClass(["va-slider__handler", _ctx.dotClass]),
          style: normalizeStyle(_ctx.dottedStyles),
          tabindex: _ctx.$props.disabled || _ctx.$props.readonly ? void 0 : 0,
          onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.isFocused = true),
          onBlur: _cache[2] || (_cache[2] = ($event) => _ctx.isFocused = false)
        }, [
          _ctx.isActiveDot(0) ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "va-slider__handler__dot--focus",
            style: normalizeStyle({ backgroundColor: _ctx.getColor(_ctx.$props.color) })
          }, null, 4)) : createCommentVNode("", true),
          _ctx.trackLabelVisible ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: "va-slider__handler__dot--value",
            style: normalizeStyle(_ctx.labelStyles)
          }, [
            renderSlot(_ctx.$slots, "trackLabel", normalizeProps(guardReactiveProps({ value: _ctx.getValueByOrder() })), () => [
              createTextVNode(toDisplayString(_ctx.getTrackLabel(_ctx.getValueByOrder())), 1)
            ])
          ], 4)) : createCommentVNode("", true)
        ], 46, _hoisted_58)
      ], 64))
    ], 544),
    (_ctx.vertical ? _ctx.iconPrepend : _ctx.iconAppend) ? (openBlock(), createElementBlock("span", _hoisted_66, [
      createVNode(_component_va_icon, {
        name: _ctx.vertical ? _ctx.iconPrepend : _ctx.iconAppend,
        color: _ctx.getColor(_ctx.$props.color),
        size: 16
      }, null, 8, ["name", "color"])
    ])) : createCommentVNode("", true),
    (_ctx.$slots.label || _ctx.label) && _ctx.invertLabel ? (openBlock(), createElementBlock("span", {
      key: 4,
      class: "va-input__label va-input__label--inverse",
      style: normalizeStyle(_ctx.labelStyles),
      id: _ctx.ariaLabelIdComputed
    }, [
      renderSlot(_ctx.$slots, "label", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ], 12, _hoisted_74)) : createCommentVNode("", true),
    (_ctx.vertical ? _ctx.$slots.prepend : _ctx.$slots.append) ? (openBlock(), createElementBlock("div", _hoisted_83, [
      renderSlot(_ctx.$slots, _ctx.vertical ? "prepend" : "append")
    ])) : createCommentVNode("", true)
  ], 16);
}
var _VaSlider = _export_sfc(_sfc_main99, [["render", _sfc_render96]]);

// node_modules/vuestic-ui/dist/es/src/components/va-slider/index.js
var VaSlider = withConfigTransport$1(_VaSlider);

// node_modules/vuestic-ui/dist/es/src/components/va-spacer/VaSpacer.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSpacer.css";
var _sfc_main100 = defineComponent({
  name: "VaSpacer"
});

// node_modules/vuestic-ui/dist/es/src/components/va-spacer/VaSpacer.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSpacer.css";
var _hoisted_161 = {
  class: "va-spacer",
  "aria-hidden": "true"
};
function _sfc_render97(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_161);
}
var VaSpacer = _export_sfc(_sfc_main100, [["render", _sfc_render97]]);

// node_modules/vuestic-ui/dist/es/src/components/va-split/useSplitDragger.js
var useSplitDraggerProps = {
  vertical: { type: Boolean, default: false },
  disabled: { type: Boolean, default: false }
};
var useSplitDragger = (containerSizeComputed, splitterPositionComputed, props2) => {
  const isDragging = ref(false);
  const dragStartPosition = ref(0);
  const dragStartSplitterPosition = ref(0);
  const currentSplitterPosition = ref(0);
  const getEventPosition = (e2, eventName) => {
    const event = e2.type === eventName ? e2 : e2.changedTouches[0];
    return props2.vertical ? event.pageY : event.pageX;
  };
  const startDragging = (e2) => {
    if (props2.disabled || !containerSizeComputed.value) {
      return;
    }
    isDragging.value = true;
    dragStartPosition.value = getEventPosition(e2, "mousedown");
    dragStartSplitterPosition.value = splitterPositionComputed.value;
  };
  const processDragging = (e2) => {
    if (!isDragging.value) {
      return;
    }
    const currentPosition = getEventPosition(e2, "mousemove");
    const distance = currentPosition - dragStartPosition.value;
    currentSplitterPosition.value = dragStartSplitterPosition.value + Math.floor(distance / containerSizeComputed.value * 100);
  };
  const stopDragging = () => {
    isDragging.value = false;
  };
  useEvent(["mousemove", "touchmove"], processDragging);
  useEvent(["mouseup", "touchcancel"], stopDragging);
  return { isDragging, startDragging, currentSplitterPosition };
};

// node_modules/vuestic-ui/dist/es/src/components/va-split/VaSplit.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSplit.css";
var _sfc_main101 = defineComponent({
  name: "VaSplit",
  components: { VaDivider },
  props: {
    ...useComponentPresetProp,
    ...useSplitDraggerProps,
    ...useStatefulProps,
    modelValue: {
      type: Number,
      default: 50,
      validator: (v2) => v2 <= 100
    },
    maximization: { type: Boolean, default: false },
    maximizeStart: { type: Boolean, default: false },
    limits: {
      type: Array,
      default: () => [0, 0]
    },
    snapping: {
      type: Array,
      default: void 0
    },
    snappingRange: { type: [Number, String], default: 4 },
    ariaLabel: { type: String, default: "$t:splitPanels" }
  },
  emits: [...useStatefulEmits],
  setup: (props2, { emit }) => {
    const splitPanelsContainer = shallowRef();
    const { valueComputed } = useStateful(props2, emit);
    const containerSize = ref();
    const bodyFontSize = ref(16);
    const handleContainerResize = () => {
      var _a2;
      const { width, height } = ((_a2 = splitPanelsContainer.value) == null ? void 0 : _a2.getBoundingClientRect()) || { width: 0, height: 0 };
      containerSize.value = props2.vertical ? height : width;
      bodyFontSize.value = parseFloat(getComputedStyle(document.documentElement).fontSize);
    };
    onMounted(handleContainerResize);
    useResizeObserver([splitPanelsContainer], handleContainerResize);
    const convertToPercents = (v2, type) => {
      let numberValue = "";
      let measureValue = "";
      if (isNumber$1(v2)) {
        return v2;
      }
      v2.split("").filter((char) => char && char !== " ").forEach((char) => {
        !isNaN(+char) ? numberValue += char : measureValue += char;
      });
      switch (measureValue) {
        case "%":
          return +numberValue;
        case "px":
          return +numberValue / containerSize.value * 100;
        case "rem":
          return +numberValue * bodyFontSize.value / containerSize.value * 100;
        case "any":
          return ["min", "snapping"].includes(type) ? 0 : 100;
        case "":
          return 100;
        default:
          warn("Invalid limits measure!");
          return 0;
      }
    };
    const getPanelMinMax = (v2) => {
      if (v2 === "undefined" || !containerSize.value) {
        return;
      }
      let minPercents = 0;
      let maxPercents = 100;
      if (isString$1(v2) || isNumber$1(v2)) {
        minPercents = convertToPercents(v2, "min");
      }
      if (Array.isArray(v2)) {
        minPercents = convertToPercents(v2[0], "min");
        maxPercents = convertToPercents(v2[1], "max");
      }
      if (minPercents > maxPercents) {
        warn(`Min panels size can not be larger than max one! Passed limit: ${v2}.`);
        maxPercents = minPercents;
      }
      return { min: minPercents ?? 0, max: maxPercents ?? 100 };
    };
    const startPanelMinMax = computed(() => getPanelMinMax(props2.limits[0]) ?? { min: 0, max: 100 });
    const endPanelMinMax = computed(() => getPanelMinMax(props2.limits[1]) ?? { min: 0, max: 100 });
    const endPanelMinChecked = computed(() => {
      const passedCheck = !(startPanelMinMax.value.min + endPanelMinMax.value.min > 100);
      if (!passedCheck) {
        warn("The sum of different panels min sizes should be lesser or equal to 100% of the container size!");
      }
      return !passedCheck ? 100 - startPanelMinMax.value.min : endPanelMinMax.value.min;
    });
    const panelsMinMax = computed(() => {
      if (Math.ceil(endPanelMinMax.value.max + startPanelMinMax.value.max) < 100) {
        warn("The sum of different panels max sizes should be equal to 100% of the container size!");
      }
      return {
        start: {
          min: startPanelMinMax.value.min,
          max: Math.min(startPanelMinMax.value.max, 100 - endPanelMinChecked.value)
        },
        end: {
          min: endPanelMinChecked.value,
          max: Math.min(endPanelMinMax.value.max, 100 - startPanelMinMax.value.min)
        }
      };
    });
    const checkSnappingLimitsCondition = (el) => el >= panelsMinMax.value.start.min && el >= panelsMinMax.value.end.min && el <= panelsMinMax.value.start.max && el <= panelsMinMax.value.end.max;
    const snappingMarksPosition = computed(() => {
      if (!Array.isArray(props2.snapping) || !containerSize.value) {
        return;
      }
      let result = props2.snapping.map((el) => convertToPercents(el, "snapping"));
      if (!result.every(checkSnappingLimitsCondition)) {
        const filteredMarks = result.filter(checkSnappingLimitsCondition);
        warn(`Some of the snapping marks (${result}) are not in allowed range (${Object.values(panelsMinMax.value.start).join("-")} / ${Object.values(panelsMinMax.value.end).join("-")}) and will be removed (${filteredMarks})!`);
        result = filteredMarks;
      }
      const checkSnappingRange = () => {
        return result.every((el, index, array) => {
          if (!array[index + 1]) {
            return true;
          }
          return Math.abs(el - array[index + 1]) > Number(props2.snappingRange);
        });
      };
      if (!checkSnappingRange()) {
        warn("Distance between some snapping marks is lesser than snapping range!");
      }
      return result;
    });
    const snappingRangeParsed = computed(() => convertToPercents(props2.snappingRange, "snapping"));
    const splitterPosition = ref(valueComputed.value);
    const splitterPositionComputed = computed(() => {
      if (snappingMarksPosition.value) {
        const nearestSnappingMark = snappingMarksPosition.value.find((el) => {
          return splitterPosition.value + snappingRangeParsed.value > el && splitterPosition.value - snappingRangeParsed.value < el;
        });
        if (nearestSnappingMark) {
          return nearestSnappingMark;
        }
      }
      return clamp$1(
        splitterPosition.value,
        Math.max(panelsMinMax.value.start.min, 100 - panelsMinMax.value.end.max),
        Math.min(panelsMinMax.value.start.max, 100 - panelsMinMax.value.end.min)
      );
    });
    const {
      isDragging,
      startDragging,
      currentSplitterPosition
    } = useSplitDragger(containerSize, splitterPositionComputed, props2);
    const maximizePanel = () => {
      if (!props2.maximization || props2.disabled) {
        return;
      }
      splitterPosition.value = props2.maximizeStart ? panelsMinMax.value.start.max : 100 - panelsMinMax.value.end.max;
    };
    watch(valueComputed, (v2) => {
      if (v2 < panelsMinMax.value.start.min || v2 > 100 - panelsMinMax.value.end.min) {
        warn("Incorrect `modelValue`. Check current `limits` prop value.");
      }
      splitterPosition.value = v2;
    }, { immediate: true });
    watch(currentSplitterPosition, (v2) => {
      splitterPosition.value = v2;
    });
    watch(isDragging, (v2) => {
      if (!v2) {
        valueComputed.value = splitterPositionComputed.value;
      }
      document.documentElement.style.cursor = v2 ? "var(--va-split-dragging-cursor)" : "";
    });
    const sizePropertyComputed = computed(() => props2.vertical ? "height" : "width");
    const getPanelStyle = (position) => {
      let sizeValue = position === "start" ? splitterPositionComputed.value : 100 - splitterPositionComputed.value;
      if (sizeValue < 0) {
        sizeValue = 0;
      }
      if (sizeValue > 100) {
        sizeValue = 100;
      }
      return { [sizePropertyComputed.value]: `${sizeValue}%` };
    };
    const draggerStyleComputed = computed(() => {
      if (props2.disabled) {
        return {};
      }
      if (isDragging.value) {
        return { cursor: "var(--va-split-dragging-cursor)" };
      }
      return { cursor: props2.vertical ? "var(--va-split-vertical-dragger-cursor)" : "var(--va-split-horizontal-dragger-cursor)" };
    });
    const classComputed = useBem("va-split", () => ({
      horizontal: !props2.vertical,
      vertical: props2.vertical,
      dragging: isDragging.value
    }));
    return {
      ...useTranslation(),
      splitPanelsContainer,
      containerSize,
      startDragging,
      getPanelStyle,
      maximizePanel,
      classComputed,
      draggerStyleComputed
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-split/VaSplit.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaSplit.css";
var _hoisted_162 = ["aria-label"];
var _hoisted_230 = { class: "va-split__dragger" };
function _sfc_render98(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_divider = resolveComponent("va-divider");
  return openBlock(), createElementBlock("section", {
    ref: "splitPanelsContainer",
    class: normalizeClass(["va-split", _ctx.classComputed]),
    "aria-label": _ctx.tp(_ctx.$props.ariaLabel)
  }, [
    createBaseVNode("div", {
      class: "va-split__panel",
      style: normalizeStyle(_ctx.getPanelStyle("start"))
    }, [
      renderSlot(_ctx.$slots, "start", normalizeProps(guardReactiveProps({ containerSize: _ctx.containerSize })))
    ], 4),
    createBaseVNode("div", _hoisted_230, [
      createBaseVNode("div", {
        class: "va-split__dragger__overlay",
        style: normalizeStyle(_ctx.draggerStyleComputed),
        onMousedown: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.startDragging && _ctx.startDragging(...args), ["prevent"])),
        onTouchstart: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.startDragging && _ctx.startDragging(...args), ["prevent"])),
        onDblclick: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.maximizePanel && _ctx.maximizePanel(...args), ["prevent"])),
        onContextmenu: _cache[3] || (_cache[3] = withModifiers(() => {
        }, ["prevent"])),
        onDragstart: _cache[4] || (_cache[4] = withModifiers(() => {
        }, ["prevent"]))
      }, [
        renderSlot(_ctx.$slots, "grabber", {}, () => [
          createVNode(_component_va_divider, {
            class: "va-split__dragger__default",
            vertical: !_ctx.$props.vertical
          }, null, 8, ["vertical"])
        ])
      ], 36)
    ]),
    createBaseVNode("div", {
      class: "va-split__panel",
      style: normalizeStyle(_ctx.getPanelStyle("end"))
    }, [
      renderSlot(_ctx.$slots, "end", normalizeProps(guardReactiveProps({ containerSize: _ctx.containerSize })))
    ], 4)
  ], 10, _hoisted_162);
}
var _VaSplit = _export_sfc(_sfc_main101, [["render", _sfc_render98]]);

// node_modules/vuestic-ui/dist/es/src/components/va-split/index.js
var VaSplit = withConfigTransport$1(_VaSplit);

// node_modules/vuestic-ui/dist/es/src/components/va-tabs/types.js
var TabsViewKey = Symbol("TabsView");

// node_modules/vuestic-ui/dist/es/src/components/va-tabs/VaTabs.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaTabs.css";
var getClientWidth = (element) => (element == null ? void 0 : element.clientWidth) || 0;
var _sfc_main102 = defineComponent({
  name: "VaTabs",
  components: { VaButton, VaConfig },
  emits: ["update:modelValue", "click:next", "click:prev"],
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: [String, Number], default: null },
    left: { type: Boolean, default: true },
    right: { type: Boolean, default: false },
    center: { type: Boolean, default: false },
    grow: { type: Boolean, default: false },
    hidePagination: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    hideSlider: { type: Boolean, default: false },
    vertical: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    prevIcon: { type: String, default: "va-arrow-left" },
    nextIcon: { type: String, default: "va-arrow-right" },
    ariaMoveRightLabel: { type: String, default: "$t:movePaginationLeft" },
    ariaMoveLeftLabel: { type: String, default: "$t:movePaginationRight" }
  },
  setup: (props2, { emit }) => {
    const wrapper = shallowRef();
    const container = shallowRef();
    const tabs = shallowRef();
    const tabsList = ref([]);
    const sliderHeight = ref(null);
    const sliderWidth = ref(null);
    const sliderOffsetX = ref(0);
    const sliderOffsetY = ref(0);
    const showPagination = ref(false);
    const tabsContentOffset = ref(0);
    const startingXPoint = ref(0);
    const animationIncluded = ref(false);
    const { valueComputed: tabSelected } = useStateful(props2, emit);
    const tabConfig = reactive({
      VaTab: {
        color: props2.color
      }
    });
    const computedClass = computed(() => {
      const { left, right, center, grow, disabled } = props2;
      return {
        "va-tabs__container--left": left && !right && !center && !grow,
        "va-tabs__container--right": right,
        "va-tabs__container--center": center,
        "va-tabs__container--grow": grow,
        "va-tabs__container--disabled": disabled
      };
    });
    const computedTabsClass = computed(() => ({ "va-tabs--vertical": props2.vertical }));
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props2.color));
    const sliderStyles = computed(() => {
      if (props2.hideSlider) {
        return { display: "none" };
      }
      return {
        backgroundColor: colorComputed.value,
        height: props2.vertical ? `${sliderHeight.value}px` : "",
        width: props2.vertical ? "" : `${sliderWidth.value}px`,
        transform: `translateY(-${sliderOffsetY.value}px) translateX(${sliderOffsetX.value}px)`,
        transition: animationIncluded.value ? "var(--va-tabs-slider-wrapper-transition)" : ""
      };
    });
    const paginationControlledStyles = computed(() => {
      if (props2.vertical) {
        return {
          transform: "translateX(0px)"
        };
      }
      return {
        transform: `translateX(${startingXPoint.value - tabsContentOffset.value}px)`,
        transition: animationIncluded.value ? "var(--va-tabs-slider-transition)" : "",
        position: props2.hidePagination ? "unset" : "absolute"
      };
    });
    const disablePaginationLeft = computed(() => tabsContentOffset.value === 0);
    const disablePaginationRight = computed(() => {
      const lastTab = tabsList.value[tabsList.value.length - 1];
      const leftSidePosition = unref(lastTab.leftSidePosition);
      const rightSidePosition = unref(lastTab.rightSidePosition);
      const containerClientWidth = getClientWidth(container.value);
      return rightSidePosition <= tabsContentOffset.value + containerClientWidth || leftSidePosition <= tabsContentOffset.value;
    });
    const resetSliderSizes = () => {
      sliderWidth.value = 0;
      sliderHeight.value = 0;
    };
    const moveToTab = (tab) => {
      const containerClientWidth = getClientWidth(container.value);
      const leftSidePosition = unref(tab.leftSidePosition);
      const rightSidePosition = unref(tab.rightSidePosition);
      if (!showPagination.value) {
        tabsContentOffset.value = 0;
        return;
      }
      if (leftSidePosition - tabsContentOffset.value >= 0 && rightSidePosition - tabsContentOffset.value <= containerClientWidth) {
        return;
      }
      if (leftSidePosition - tabsContentOffset.value < 0) {
        tabsContentOffset.value = leftSidePosition;
        return;
      }
      if (rightSidePosition - tabsContentOffset.value > containerClientWidth) {
        tabsContentOffset.value = rightSidePosition - containerClientWidth;
        return;
      }
      tabsContentOffset.value = 0;
    };
    const updateStartingXPoint = () => {
      startingXPoint.value = 0;
      if (!showPagination.value) {
        return;
      }
      const containerClientWidth = getClientWidth(container.value);
      const tabsClientWidth = getClientWidth(tabs.value);
      if (props2.right) {
        startingXPoint.value = tabsClientWidth - containerClientWidth;
      } else if (props2.center) {
        startingXPoint.value = Math.floor((tabsClientWidth - containerClientWidth) / 2);
      }
    };
    const updateTabsState = () => {
      resetSliderSizes();
      tabsList.value.forEach((tab) => {
        var _a2;
        tab.updateSidePositions();
        const isTabSelected = (((_a2 = tab.name) == null ? void 0 : _a2.value) || tab.id) === tabSelected.value;
        tab.isActive = tab.isActiveRouterLink || isTabSelected;
        if (tab.isActive) {
          moveToTab(tab);
          updateSlider(tab);
        }
      });
      updateStartingXPoint();
    };
    const updatePagination = () => {
      const tabsClientWidth = getClientWidth(tabs.value);
      const wrapperClientWidth = getClientWidth(wrapper.value);
      requestAnimationFrame(() => {
        showPagination.value = !!(tabs.value && wrapper.value && tabsClientWidth > wrapperClientWidth);
      });
    };
    const movePaginationLeft = () => {
      var _a2, _b;
      const containerClientWidth = getClientWidth(container.value);
      let offsetToSet = tabsContentOffset.value - containerClientWidth;
      for (let i2 = 0; i2 < tabsList.value.length - 1; i2++) {
        const currentTabLeftSidePosition = unref((_a2 = tabsList.value[i2]) == null ? void 0 : _a2.leftSidePosition);
        const nextTabLeftSidePosition = unref((_b = tabsList.value[i2 + 1]) == null ? void 0 : _b.leftSidePosition);
        if (currentTabLeftSidePosition > offsetToSet && currentTabLeftSidePosition < tabsContentOffset.value || nextTabLeftSidePosition >= tabsContentOffset.value) {
          offsetToSet = currentTabLeftSidePosition;
          break;
        }
      }
      tabsContentOffset.value = Math.max(0, offsetToSet);
      emit("click:prev");
    };
    const movePaginationRight = () => {
      var _a2;
      const containerClientWidth = getClientWidth(container.value);
      const containerRightSide = tabsContentOffset.value + containerClientWidth;
      let offsetToSet = containerRightSide;
      for (let i2 = 0; i2 < tabsList.value.length - 1; i2++) {
        const rightSidePosition2 = unref(tabsList.value[i2].rightSidePosition);
        if (rightSidePosition2 > containerRightSide) {
          offsetToSet = unref(tabsList.value[i2].leftSidePosition);
          if (tabsContentOffset.value < offsetToSet) {
            break;
          }
        }
      }
      const rightSidePosition = unref((_a2 = tabsList.value[tabsList.value.length - 1]) == null ? void 0 : _a2.rightSidePosition);
      const maxOffset = rightSidePosition - containerClientWidth;
      offsetToSet = Math.min(maxOffset, offsetToSet);
      tabsContentOffset.value = Math.max(0, offsetToSet);
      emit("click:next");
    };
    const updateSlider = (tab) => {
      var _a2;
      const tabElement = unref(tab.tabElement);
      const tabOffsetTop = (tabElement == null ? void 0 : tabElement.offsetTop) || 0;
      const tabOffsetLeft = (tabElement == null ? void 0 : tabElement.offsetLeft) || 0;
      const tabClientHeight = (tabElement == null ? void 0 : tabElement.clientHeight) || 0;
      const tabClientWidth = (tabElement == null ? void 0 : tabElement.clientWidth) || 0;
      if (props2.vertical) {
        const containerClientHeight = ((_a2 = container.value) == null ? void 0 : _a2.clientHeight) || 0;
        const calculatedSliderOffsetY = containerClientHeight - tabOffsetTop - tabClientHeight;
        sliderOffsetY.value = Math.max(calculatedSliderOffsetY, 0);
        sliderHeight.value = tabClientHeight;
        sliderOffsetX.value = 0;
        sliderWidth.value = 0;
      } else {
        sliderOffsetX.value = tabOffsetLeft;
        sliderWidth.value = tabClientWidth;
        sliderOffsetY.value = 0;
        sliderHeight.value = 0;
      }
    };
    const includeAnimation = () => {
      if (!animationIncluded.value) {
        requestAnimationFrame(() => {
          animationIncluded.value = true;
        });
      }
    };
    const selectTab = (tab) => {
      var _a2;
      if (!tab) {
        return;
      }
      tabSelected.value = ((_a2 = tab.name) == null ? void 0 : _a2.value) || tab.id;
      if (props2.stateful) {
        updateTabsState();
      }
    };
    const registerTab = (tab) => {
      var _a2;
      const idx = tabsList.value.push(tab) - 1;
      tab.id = ((_a2 = tab.name) == null ? void 0 : _a2.value) || idx;
    };
    const unregisterTab = (tab) => {
      tabsList.value = tabsList.value.filter((filteredTab) => filteredTab.id !== tab.id);
      tabsList.value.forEach((tabListItem, idx) => {
        var _a2;
        tabListItem.id = ((_a2 = tabListItem.name) == null ? void 0 : _a2.value) || idx;
      });
    };
    provide(TabsViewKey, {
      parentDisabled: props2.disabled,
      selectTab,
      moveToTab,
      registerTab,
      unregisterTab
    });
    watch(() => props2.modelValue, updateTabsState);
    useResizeObserver([wrapper], updatePagination);
    useResizeObserver([container], updateTabsState);
    onMounted(() => {
      requestAnimationFrame(() => {
        includeAnimation();
      });
    });
    return {
      ...useTranslation(),
      wrapper,
      container,
      tabs,
      tabsList,
      sliderHeight,
      sliderWidth,
      sliderOffsetX,
      sliderOffsetY,
      showPagination,
      tabsContentOffset,
      startingXPoint,
      animationIncluded,
      colorComputed,
      tabConfig,
      computedClass,
      computedTabsClass,
      tabSelected,
      sliderStyles,
      paginationControlledStyles,
      disablePaginationLeft,
      disablePaginationRight,
      resetSliderSizes,
      moveToTab,
      updateStartingXPoint,
      updateTabsState,
      updatePagination,
      movePaginationLeft,
      movePaginationRight,
      updateSlider,
      includeAnimation,
      selectTab
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-tabs/VaTabs.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaTabs.css";
var _hoisted_163 = ["aria-disabled"];
var _hoisted_231 = createBaseVNode("div", { class: "va-tabs__slider" }, null, -1);
var _hoisted_321 = [
  _hoisted_231
];
var _hoisted_412 = { class: "va-tabs__tabs-items" };
var _hoisted_59 = { class: "va-tabs__content" };
function _sfc_render99(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_config = resolveComponent("va-config");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-tabs", _ctx.computedTabsClass])
  }, [
    createBaseVNode("div", {
      ref: "wrapper",
      class: "va-tabs__wrapper",
      role: "tablist",
      "aria-disabled": _ctx.$props.disabled
    }, [
      _ctx.showPagination && !_ctx.$props.hidePagination ? (openBlock(), createBlock(_component_va_button, {
        key: 0,
        class: "va-tabs__pagination",
        "aria-label": _ctx.tp(_ctx.$props.ariaMoveLeftLabel),
        size: "medium",
        disabled: _ctx.disablePaginationLeft,
        color: _ctx.color,
        preset: "secondary",
        icon: _ctx.$props.prevIcon,
        onClick: _ctx.movePaginationLeft
      }, null, 8, ["aria-label", "disabled", "color", "icon", "onClick"])) : createCommentVNode("", true),
      createBaseVNode("div", {
        ref: "container",
        class: normalizeClass(["va-tabs__container", _ctx.computedClass])
      }, [
        createBaseVNode("div", {
          ref: "tabs",
          class: "va-tabs__tabs",
          style: normalizeStyle(_ctx.paginationControlledStyles)
        }, [
          createBaseVNode("div", {
            class: "va-tabs__slider-wrapper",
            "aria-hidden": "true",
            style: normalizeStyle(_ctx.sliderStyles)
          }, _hoisted_321, 4),
          createVNode(_component_va_config, { components: _ctx.tabConfig }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_412, [
                renderSlot(_ctx.$slots, "tabs")
              ])
            ]),
            _: 3
          }, 8, ["components"])
        ], 4)
      ], 2),
      _ctx.showPagination && !_ctx.$props.hidePagination ? (openBlock(), createBlock(_component_va_button, {
        key: 1,
        class: "va-tabs__pagination",
        "aria-label": _ctx.tp(_ctx.$props.ariaMoveRightLabel),
        size: "medium",
        color: _ctx.color,
        disabled: _ctx.disablePaginationRight,
        preset: "secondary",
        icon: _ctx.$props.nextIcon,
        onClick: _ctx.movePaginationRight
      }, null, 8, ["aria-label", "color", "disabled", "icon", "onClick"])) : createCommentVNode("", true)
    ], 8, _hoisted_163),
    createBaseVNode("div", _hoisted_59, [
      renderSlot(_ctx.$slots, "default")
    ])
  ], 2);
}
var _VaTabs = _export_sfc(_sfc_main102, [["render", _sfc_render99]]);

// node_modules/vuestic-ui/dist/es/src/components/va-tabs/index.js
var VaTabs = withConfigTransport$1(_VaTabs);

// node_modules/vuestic-ui/dist/es/src/components/va-tabs/components/VaTab/VaTab.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaTab.css";
var _sfc_main103 = defineComponent({
  name: "VaTab",
  components: { VaIcon },
  emits: ["click", "keydown-enter", "focus"],
  props: {
    ...useRouterLinkProps,
    ...useComponentPresetProp,
    selected: { type: Boolean, default: false },
    color: { type: String, default: "" },
    icon: { type: String, default: "" },
    label: { type: String, default: "" },
    disabled: { type: Boolean },
    name: { type: [String, Number] },
    tag: { type: String, default: "div" }
  },
  setup: (props2, { emit }) => {
    const tabElement = shallowRef();
    const isActive = ref(false);
    const hoverState = ref(false);
    const rightSidePosition = ref(0);
    const leftSidePosition = ref(0);
    const { keyboardFocusListeners, hasKeyboardFocus } = useKeyboardOnlyFocus();
    const { tagComputed, hrefComputed, isActiveRouterLink } = useRouterLink(props2);
    const classComputed = computed(() => ({ "va-tab--disabled": props2.disabled }));
    const {
      parentDisabled,
      selectTab,
      moveToTab,
      registerTab,
      unregisterTab
    } = inject(TabsViewKey, {
      parentDisabled: false,
      tabsList: [],
      selectTab: (tab) => tab,
      moveToTab: (tab) => tab,
      registerTab: (tab) => tab,
      unregisterTab: (tab) => tab
    });
    const tabIndexComputed = computed(() => props2.disabled || parentDisabled ? -1 : 0);
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props2.color));
    const computedStyle = computed(() => ({
      color: hoverState.value || isActive.value ? colorComputed.value : "inherit"
    }));
    const updateHoverState = (isHover) => {
      hoverState.value = isHover;
    };
    const updateSidePositions = () => {
      var _a2, _b;
      const componentOffsetLeft = ((_a2 = tabElement.value) == null ? void 0 : _a2.offsetLeft) || 0;
      const componentOffsetWidth = ((_b = tabElement.value) == null ? void 0 : _b.offsetWidth) || 0;
      rightSidePosition.value = componentOffsetLeft + componentOffsetWidth;
      leftSidePosition.value = componentOffsetLeft;
    };
    const onTabClick = () => {
      selectTab(tabComponent);
      emit("click");
    };
    const onTabKeydown = () => {
      selectTab(tabComponent);
      emit("keydown-enter");
    };
    const onFocus = () => {
      if (hasKeyboardFocus.value) {
        moveToTab(tabComponent);
      }
      emit("focus");
    };
    const tabComponent = {
      name: computed(() => props2.name),
      id: null,
      tabElement,
      isActive,
      tabIndexComputed,
      isActiveRouterLink,
      rightSidePosition,
      leftSidePosition,
      onTabClick,
      onTabKeydown,
      onFocus,
      updateSidePositions
    };
    onMounted(() => {
      registerTab(tabComponent);
    });
    onBeforeUnmount(() => {
      unregisterTab(tabComponent);
    });
    return {
      tabElement,
      parentDisabled,
      isActive,
      hoverState,
      tagComputed,
      hrefComputed,
      isActiveRouterLink,
      colorComputed,
      classComputed,
      computedStyle,
      tabIndexComputed,
      rightSidePosition,
      leftSidePosition,
      updateHoverState,
      updateSidePositions,
      onTabClick,
      onTabKeydown,
      onFocus,
      keyboardFocusListeners
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-tabs/components/VaTab/VaTab.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaTab.css";
var _hoisted_164 = ["tabindex"];
var _hoisted_232 = ["textContent"];
function _sfc_render100(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
    ref: "tabElement",
    class: normalizeClass(["va-tab", _ctx.classComputed]),
    role: "tab",
    "aria-selected": _ctx.isActive,
    "aria-disabled": _ctx.$props.disabled || _ctx.parentDisabled,
    href: _ctx.hrefComputed,
    target: _ctx.target,
    to: _ctx.to,
    replace: _ctx.replace,
    exact: _ctx.exact,
    "active-class": _ctx.activeClass,
    "exact-active-class": _ctx.exactActiveClass,
    style: normalizeStyle(_ctx.computedStyle),
    onMouseenter: _cache[3] || (_cache[3] = ($event) => _ctx.updateHoverState(true)),
    onMouseleave: _cache[4] || (_cache[4] = ($event) => _ctx.updateHoverState(false))
  }, {
    default: withCtx(() => [
      createBaseVNode("div", mergeProps({
        class: "va-tab__content",
        tabindex: _ctx.tabIndexComputed,
        onFocus: _cache[0] || (_cache[0] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
        onClick: _cache[1] || (_cache[1] = (...args) => _ctx.onTabClick && _ctx.onTabClick(...args)),
        onKeydown: _cache[2] || (_cache[2] = withKeys((...args) => _ctx.onTabKeydown && _ctx.onTabKeydown(...args), ["enter"]))
      }, toHandlers(_ctx.keyboardFocusListeners, true)), [
        renderSlot(_ctx.$slots, "default", {}, () => [
          _ctx.icon ? (openBlock(), createBlock(_component_va_icon, {
            key: 0,
            class: "va-tab__icon",
            size: "small",
            name: _ctx.icon
          }, null, 8, ["name"])) : createCommentVNode("", true),
          createBaseVNode("span", {
            class: "va-tab__label",
            textContent: toDisplayString(_ctx.label)
          }, null, 8, _hoisted_232)
        ])
      ], 16, _hoisted_164)
    ]),
    _: 3
  }, 40, ["aria-selected", "aria-disabled", "href", "target", "to", "replace", "exact", "active-class", "exact-active-class", "class", "style"]);
}
var _VaTab = _export_sfc(_sfc_main103, [["render", _sfc_render100]]);

// node_modules/vuestic-ui/dist/es/src/components/va-tabs/components/VaTab/index.js
var VaTab = withConfigTransport$1(_VaTab);

// node_modules/vuestic-ui/dist/es/src/components/va-stepper/VaStepperControls.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaStepperControls.css";
var _sfc_main104 = defineComponent({
  name: "VaStepperControls",
  components: { VaButton },
  props: {
    modelValue: { type: Number, required: true },
    steps: {
      type: Array,
      required: true
    },
    nextDisabled: { type: Boolean, required: true },
    stepControls: { type: Object, required: true },
    finishButtonHidden: { type: Boolean, default: false }
  },
  setup(props2) {
    const { t: t2 } = useTranslation();
    const isLastStep = computed(() => {
      const lastEnabledStepIndex = props2.steps.length - 1;
      return props2.modelValue >= lastEnabledStepIndex;
    });
    return {
      t: t2,
      isLastStep
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-stepper/VaStepperControls.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaStepperControls.css";
var _hoisted_165 = { class: "va-stepper__default-controls" };
function _sfc_render101(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  return openBlock(), createElementBlock("div", _hoisted_165, [
    createVNode(_component_va_button, {
      preset: "primary",
      disabled: _ctx.$props.modelValue <= 0,
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$props.stepControls.prevStep())
    }, {
      default: withCtx(() => [
        createTextVNode(toDisplayString(_ctx.t("back")), 1)
      ]),
      _: 1
    }, 8, ["disabled"]),
    !_ctx.isLastStep ? (openBlock(), createBlock(_component_va_button, {
      key: 0,
      onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$props.stepControls.nextStep()),
      disabled: _ctx.$props.nextDisabled
    }, {
      default: withCtx(() => [
        createTextVNode(toDisplayString(_ctx.t("next")), 1)
      ]),
      _: 1
    }, 8, ["disabled"])) : !_ctx.$props.finishButtonHidden ? (openBlock(), createBlock(_component_va_button, {
      key: 1,
      onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("finish"))
    }, {
      default: withCtx(() => [
        createTextVNode(toDisplayString(_ctx.t("finish")), 1)
      ]),
      _: 1
    })) : createCommentVNode("", true)
  ]);
}
var VaStepperControls = _export_sfc(_sfc_main104, [["render", _sfc_render101]]);

// node_modules/vuestic-ui/dist/es/src/utils/un-function.js
var unFunction = (fn, ...args) => {
  if (typeof fn === "function") {
    return fn(...args);
  }
  return fn;
};

// node_modules/vuestic-ui/dist/es/src/components/va-stepper/VaStepperStepButton.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaStepperStepButton.css";
var _sfc_main105 = defineComponent({
  name: "VaStepperStepButton",
  components: { VaIcon },
  props: {
    modelValue: { type: Number, required: true },
    step: {
      type: Object,
      required: true
    },
    color: { type: String, required: true },
    stepIndex: { type: Number, required: true },
    navigationDisabled: { type: Boolean, required: true },
    nextDisabled: { type: Boolean, required: true },
    focus: { type: Object, required: true },
    stepControls: { type: Object, required: true }
  },
  emits: ["update:modelValue"],
  setup(props2) {
    const stepElement = shallowRef();
    const hasError = computed(() => props2.step.hasError);
    const { getColor } = useColors();
    const stepperColor = computed(() => getColor(hasError.value ? "danger" : props2.color));
    const isNextStepDisabled = (index) => props2.nextDisabled && index > props2.modelValue;
    const { t: t2 } = useTranslation();
    const computedClass = useBem("va-stepper__step-button", () => ({
      active: props2.modelValue >= props2.stepIndex,
      disabled: props2.step.disabled || isNextStepDisabled(props2.stepIndex),
      "navigation-disabled": props2.navigationDisabled,
      error: unFunction(hasError.value, props2.step) || false
    }));
    watch(() => props2.focus, () => {
      if (props2.focus.trigger) {
        nextTick(() => {
          var _a2;
          return (_a2 = stepElement.value) == null ? void 0 : _a2.focus();
        });
      }
    }, { deep: true });
    return {
      stepElement,
      isNextStepDisabled,
      stepperColor,
      getColor,
      computedClass,
      ariaAttributesComputed: computed(() => ({
        tabindex: props2.focus.stepIndex === props2.stepIndex && !props2.navigationDisabled ? 0 : void 0,
        "aria-disabled": props2.step.disabled || isNextStepDisabled(props2.stepIndex) ? true : void 0,
        "aria-current": props2.modelValue === props2.stepIndex ? t2("step") : void 0
      }))
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-stepper/VaStepperStepButton.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaStepperStepButton.css";
var _hoisted_166 = { class: "va-stepper__step-button__icon" };
function _sfc_render102(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("li", mergeProps({
    ref: "stepElement",
    class: ["va-stepper__step-button", _ctx.computedClass],
    onClick: _cache[0] || (_cache[0] = ($event) => !_ctx.$props.navigationDisabled && _ctx.$props.stepControls.setStep(_ctx.$props.stepIndex)),
    onKeyup: [
      _cache[1] || (_cache[1] = withKeys(($event) => !_ctx.$props.navigationDisabled && _ctx.$props.stepControls.setStep(_ctx.$props.stepIndex), ["enter"])),
      _cache[2] || (_cache[2] = withKeys(($event) => !_ctx.$props.navigationDisabled && _ctx.$props.stepControls.setStep(_ctx.$props.stepIndex), ["space"]))
    ]
  }, _ctx.ariaAttributesComputed, {
    style: `--va-stepper-color: ${String(_ctx.stepperColor)}`
  }), [
    createBaseVNode("div", _hoisted_166, [
      _ctx.step.icon ? (openBlock(), createBlock(_component_va_icon, {
        key: 0,
        name: _ctx.step.icon,
        size: "1.3rem"
      }, null, 8, ["name"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        createTextVNode(toDisplayString(_ctx.$props.stepIndex + 1), 1)
      ], 64))
    ]),
    createTextVNode(" " + toDisplayString(_ctx.step.label), 1)
  ], 16);
}
var VaStepperStepButton = _export_sfc(_sfc_main105, [["render", _sfc_render102]]);

// node_modules/vuestic-ui/dist/es/src/components/va-stepper/VaStepper.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaStepper.css";
var _sfc_main106 = defineComponent({
  name: "VaStepper",
  components: { VaStepperControls, VaStepperStepButton },
  props: {
    ...useStatefulProps,
    modelValue: { type: Number, default: 0 },
    steps: {
      type: Array,
      default: () => [],
      required: true
    },
    color: { type: String, default: "primary" },
    vertical: { type: Boolean, default: false },
    navigationDisabled: { type: Boolean, default: false },
    controlsHidden: { type: Boolean, default: false },
    nextDisabled: { type: Boolean, default: false },
    finishButtonHidden: { type: Boolean, default: false },
    ariaLabel: { type: String, default: "$t:progress" },
    linear: { type: Boolean, default: false }
  },
  emits: ["update:modelValue", "finish", "update:steps"],
  setup(props2, { emit }) {
    const stepperNavigation = shallowRef();
    const { valueComputed: modelValue } = useStateful(props2, emit, "modelValue");
    const focusedStep = ref({ trigger: false, stepIndex: props2.navigationDisabled ? -1 : props2.modelValue });
    const { getColor } = useColors();
    const isNextStepDisabled = (index) => props2.nextDisabled && index > modelValue.value;
    const findFirstNonDisabled = (from, direction) => {
      while (from >= 0 && from < props2.steps.length) {
        from += direction;
        const step = props2.steps[from];
        if (!step) {
          return;
        }
        if (!step.disabled) {
          return step;
        }
      }
    };
    const findFirstWithErrorIndex = (from, direction) => {
      while (from >= 0 && from < props2.steps.length) {
        from += direction;
        const step = props2.steps[from];
        if (!step) {
          return;
        }
        if (step.hasError === true) {
          return from;
        }
      }
    };
    const validateMovingToStep = (stepIndex) => {
      var _a2;
      const newStep = props2.steps[stepIndex];
      const currentStep = props2.steps[modelValue.value];
      const beforeNewStep = findFirstNonDisabled(stepIndex, -1);
      if (newStep.disabled) {
        return false;
      }
      if (props2.linear && stepIndex < modelValue.value) {
        return true;
      }
      const nextNonError = findFirstWithErrorIndex(modelValue.value, 1);
      if (props2.linear && nextNonError !== void 0 && nextNonError < stepIndex) {
        return false;
      }
      if (((_a2 = currentStep.beforeLeave) == null ? void 0 : _a2.call(currentStep, currentStep, newStep)) === false) {
        return false;
      }
      if (currentStep.completed === void 0) {
        currentStep.completed = true;
      }
      if (props2.linear && beforeNewStep && !beforeNewStep.completed) {
        return false;
      }
      if (props2.linear && unFunction(currentStep.hasError, currentStep)) {
        return false;
      }
      return true;
    };
    const setStep = (index) => {
      if (!validateMovingToStep(index)) {
        return;
      }
      emit("update:modelValue", index);
    };
    const setFocus = (direction) => {
      if (props2.navigationDisabled) {
        return;
      }
      if (direction === "next") {
        setFocusNextStep(1);
      } else {
        setFocusPrevStep(1);
      }
    };
    const setFocusNextStep = (idx) => {
      const newValue = focusedStep.value.stepIndex + idx;
      if (isNextStepDisabled(newValue)) {
        return;
      }
      if (newValue < props2.steps.length) {
        if (props2.steps[newValue].disabled) {
          setFocusNextStep(idx + 1);
          return;
        }
        focusedStep.value.stepIndex = newValue;
        focusedStep.value.trigger = true;
      } else {
        for (let availableIdx = 0; availableIdx < props2.steps.length; availableIdx++) {
          if (!props2.steps[availableIdx].disabled) {
            focusedStep.value.stepIndex = availableIdx;
            focusedStep.value.trigger = true;
            break;
          }
        }
      }
    };
    const setFocusPrevStep = (idx) => {
      const newValue = focusedStep.value.stepIndex - idx;
      if (newValue >= 0) {
        if (props2.steps[newValue].disabled) {
          setFocusPrevStep(idx + 1);
          return;
        }
        focusedStep.value.stepIndex = newValue;
        focusedStep.value.trigger = true;
      } else {
        for (let availableIdx = props2.steps.length - 1; availableIdx >= 0; availableIdx--) {
          if (!props2.steps[availableIdx].disabled && !isNextStepDisabled(availableIdx)) {
            focusedStep.value.stepIndex = availableIdx;
            focusedStep.value.trigger = true;
            break;
          }
        }
      }
    };
    const resetFocus = () => {
      requestAnimationFrame(() => {
        var _a2;
        if (!((_a2 = stepperNavigation.value) == null ? void 0 : _a2.contains(document.activeElement))) {
          focusedStep.value.stepIndex = props2.modelValue;
          focusedStep.value.trigger = false;
        }
      });
    };
    watch(() => props2.modelValue, () => {
      focusedStep.value.stepIndex = props2.modelValue;
      focusedStep.value.trigger = false;
    });
    const nextStep = (stepsToSkip = 0) => {
      const targetIndex = modelValue.value + 1 + stepsToSkip;
      if (!props2.steps[targetIndex]) {
        return;
      }
      if (props2.steps[targetIndex].disabled) {
        nextStep(stepsToSkip + 1);
      }
      setStep(targetIndex);
    };
    const prevStep = (stepsToSkip = 0) => {
      const targetIndex = modelValue.value - 1 - stepsToSkip;
      if (!props2.steps[targetIndex]) {
        return;
      }
      if (props2.steps[targetIndex].disabled) {
        prevStep(stepsToSkip + 1);
      }
      setStep(targetIndex);
    };
    const stepControls = { setStep, nextStep, prevStep };
    const getIterableSlotData = (step, index) => ({
      ...stepControls,
      focus: focusedStep,
      isActive: props2.modelValue === index,
      isCompleted: props2.modelValue > index,
      isLastStep: props2.steps.length - 1 === index,
      isNextStepDisabled: isNextStepDisabled(index),
      index,
      step
    });
    const { tp } = useTranslation();
    return {
      stepperNavigation,
      resetFocus,
      focusedStep,
      isNextStepDisabled,
      getColor,
      stepControls,
      getIterableSlotData,
      onArrowKeyPress: (direction) => {
        setFocus(direction);
      },
      onValueChange: () => {
        focusedStep.value.stepIndex = props2.modelValue;
        focusedStep.value.trigger = true;
      },
      ariaAttributesComputed: computed(() => ({
        role: "group",
        "aria-label": tp(props2.ariaLabel),
        "aria-orientation": props2.vertical ? "vertical" : "horizontal"
      })),
      getStepperButtonColor(index) {
        var _a2;
        return ((_a2 = props2.steps[index]) == null ? void 0 : _a2.hasError) ? "danger" : getColor(props2.color);
      },
      completeStep: (shouldCompleteStep) => {
        const steps = { ...props2.steps };
        if (shouldCompleteStep === true) {
          steps[props2.modelValue].hasError = false;
        }
        steps[props2.modelValue].completed = shouldCompleteStep ?? true;
        emit("update:steps", steps);
      },
      setError: (shouldSetError) => {
        const steps = { ...props2.steps };
        steps[props2.modelValue].hasError = shouldSetError ?? true;
        steps[props2.modelValue].completed = !shouldSetError;
        emit("update:steps", steps);
      }
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-stepper/VaStepper.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaStepper.css";
var _hoisted_167 = {
  key: 0,
  class: "va-stepper__step-content"
};
var _hoisted_233 = { class: "va-stepper__controls" };
function _sfc_render103(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_stepper_step_button = resolveComponent("va-stepper-step-button");
  const _component_va_stepper_controls = resolveComponent("va-stepper-controls");
  return openBlock(), createElementBlock("div", mergeProps({
    class: ["va-stepper", { "va-stepper--vertical": _ctx.$props.vertical }]
  }, _ctx.ariaAttributesComputed), [
    createBaseVNode("ol", {
      class: normalizeClass(["va-stepper__navigation", { "va-stepper__navigation--vertical": _ctx.$props.vertical }]),
      ref: "stepperNavigation",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onValueChange && _ctx.onValueChange(...args)),
      onKeyup: [
        _cache[1] || (_cache[1] = withKeys((...args) => _ctx.onValueChange && _ctx.onValueChange(...args), ["enter"])),
        _cache[2] || (_cache[2] = withKeys((...args) => _ctx.onValueChange && _ctx.onValueChange(...args), ["space"])),
        _cache[3] || (_cache[3] = withKeys(($event) => _ctx.onArrowKeyPress("prev"), ["left"])),
        _cache[4] || (_cache[4] = withKeys(($event) => _ctx.onArrowKeyPress("next"), ["right"]))
      ],
      onFocusout: _cache[5] || (_cache[5] = (...args) => _ctx.resetFocus && _ctx.resetFocus(...args))
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.steps, (step, i2) => {
        return openBlock(), createElementBlock(Fragment, {
          key: i2 + step.label
        }, [
          i2 > 0 ? renderSlot(_ctx.$slots, "divider", normalizeProps(mergeProps({ key: 0 }, _ctx.getIterableSlotData(step, i2))), () => [
            createBaseVNode("span", {
              class: normalizeClass(["va-stepper__divider", { "va-stepper__divider--vertical": _ctx.$props.vertical }]),
              "aria-hidden": "true"
            }, null, 2)
          ]) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, `step-button-${i2}`, normalizeProps(guardReactiveProps(_ctx.getIterableSlotData(step, i2))), () => [
            createVNode(_component_va_stepper_step_button, {
              stepIndex: i2,
              color: _ctx.getStepperButtonColor(i2),
              modelValue: _ctx.modelValue,
              nextDisabled: _ctx.nextDisabled,
              step,
              stepControls: _ctx.stepControls,
              navigationDisabled: _ctx.navigationDisabled,
              focus: _ctx.focusedStep
            }, null, 8, ["stepIndex", "color", "modelValue", "nextDisabled", "step", "stepControls", "navigationDisabled", "focus"])
          ])
        ], 64);
      }), 128))
    ], 34),
    createBaseVNode("div", {
      class: normalizeClass(["va-stepper__step-content-wrapper", { "va-stepper__step-content-wrapper--vertical": _ctx.$props.vertical }])
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.steps, (step, i2) => {
        return openBlock(), createElementBlock(Fragment, { key: i2 }, [
          _ctx.$slots[`step-content-${i2}`] && _ctx.modelValue === i2 ? (openBlock(), createElementBlock("div", _hoisted_167, [
            renderSlot(_ctx.$slots, `step-content-${i2}`, normalizeProps(guardReactiveProps(_ctx.getIterableSlotData(step, i2))))
          ])) : createCommentVNode("", true)
        ], 64);
      }), 128)),
      createBaseVNode("div", _hoisted_233, [
        !_ctx.controlsHidden ? (openBlock(), createBlock(_component_va_stepper_controls, {
          key: 0,
          modelValue: _ctx.modelValue,
          nextDisabled: _ctx.nextDisabled,
          steps: _ctx.steps,
          stepControls: _ctx.stepControls,
          finishButtonHidden: _ctx.finishButtonHidden,
          onFinish: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("finish"))
        }, null, 8, ["modelValue", "nextDisabled", "steps", "stepControls", "finishButtonHidden"])) : createCommentVNode("", true),
        renderSlot(_ctx.$slots, "controls", normalizeProps(guardReactiveProps(_ctx.getIterableSlotData(_ctx.steps[_ctx.modelValue], _ctx.modelValue))))
      ])
    ], 2)
  ], 16);
}
var _VaStepper = _export_sfc(_sfc_main106, [["render", _sfc_render103]]);

// node_modules/vuestic-ui/dist/es/src/components/va-stepper/index.js
var VaStepper = withConfigTransport$1(_VaStepper);
var defineVaStepperSteps = (steps) => steps;

// node_modules/vuestic-ui/dist/es/src/components/va-time-input/hooks/time-text-parser.js
var parse = (text) => {
  const m2 = text.match(/[0-9]{1,2}/g);
  if (!m2) {
    return [];
  }
  return m2.map((s2) => Number(s2));
};
var parsePeriod = (text) => {
  const m2 = text.match(/pm|am/i);
  if (!m2) {
    return null;
  }
  return Number(m2[0].toLowerCase() === "pm");
};
var defaultParseDateFunction2 = (text) => {
  const d2 = /* @__PURE__ */ new Date();
  const [h3, m2, s2] = parse(text);
  const period = parsePeriod(text);
  if (!h3) {
    return null;
  }
  const is12format = period !== null && h3 <= 12;
  const isPM = is12format && !!period;
  const fh = is12format ? h3 === 12 ? 0 : h3 : h3;
  d2.setHours(Math.min(fh || 0, is12format ? 12 : 24) + (isPM ? 12 : 0));
  d2.setMinutes(Math.min(m2 || 0, 60));
  d2.setSeconds(Math.min(s2 || 0, 60));
  return d2;
};
var useTimeParser = (props2) => {
  const getParseDateFn = () => props2.parse || defaultParseDateFunction2;
  const isValid = ref(true);
  const parseDate = (text) => {
    const parse3 = getParseDateFn();
    const result = parse3(text);
    if (!result) {
      isValid.value = false;
    }
    return result;
  };
  const parse2 = (text) => {
    isValid.value = true;
    return parseDate(text);
  };
  return {
    parse: parse2,
    isValid
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-time-input/hooks/time-text-formatter.js
var useTimeFormatter = (props2) => {
  const formatDate = (date) => {
    if (!date) {
      return "";
    }
    if (props2.ampm) {
      return date.toLocaleTimeString("en-US");
    }
    return date.toLocaleTimeString("en-GB");
  };
  const sliceTime = (time, start, end) => time.split(":").slice(start, end).join(":");
  const formatWithView = (date) => {
    if (props2.view === "seconds") {
      return formatDate(date);
    }
    const [time, period] = formatDate(date).split(" ");
    if (props2.view === "minutes") {
      if (!period) {
        return sliceTime(time, 0, 2);
      }
      return [sliceTime(time, 0, 2), period].join(" ");
    }
    if (props2.view === "hours") {
      if (!period) {
        return sliceTime(time, 0, 1);
      }
      return [sliceTime(time, 0, 1), period].join(" ");
    }
    return "";
  };
  return {
    format: (date) => props2.format ? props2.format(date) : formatWithView(date)
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-time-picker/hooks/useTimePicker.js
var safeModelValue = (m2) => m2.value ? m2.value : new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
var createNumbersArray = (length) => Array.from(Array(length).keys());
var from24to12 = (h3) => (h3 === 0 ? 12 : h3) - Number(h3 > 12) * 12;
var from12to24 = (h3, isAM = false) => (h3 === 12 ? 0 : h3) + Number(isAM) * 12;
var createHoursColumn = (props2, modelValue, isPM) => {
  const computedSize = computed(() => props2.ampm ? 12 : 24);
  const items2 = computed(() => {
    let array = createNumbersArray(computedSize.value);
    if (props2.hoursFilter) {
      array = array.filter((i2) => props2.hoursFilter(props2.ampm ? i2 + 12 * Number(isPM.value) : i2));
    }
    return array.map((n2) => {
      return props2.ampm ? from24to12(n2) : n2;
    });
  });
  const activeItem = computed({
    get: () => {
      if (!modelValue.value) {
        return -1;
      }
      if (props2.ampm) {
        const h22 = from24to12(modelValue.value.getHours() - 12 * Number(isPM.value));
        return items2.value.findIndex((i2) => i2 === h22);
      }
      const h3 = modelValue.value.getHours();
      return items2.value.findIndex((i2) => i2 === h3);
    },
    set: (newIndex) => {
      if (props2.readonly) {
        return;
      }
      const hours = props2.ampm ? from12to24(items2.value[newIndex], isPM.value) : items2.value[newIndex];
      modelValue.value = new Date(safeModelValue(modelValue).setHours(hours));
    }
  });
  return computed(() => ({
    items: items2.value,
    activeItem
  }));
};
var createMinutesColumn = (props2, modelValue) => {
  const items2 = computed(() => {
    const array = createNumbersArray(60);
    if (!props2.minutesFilter) {
      return array;
    }
    return array.filter(props2.minutesFilter);
  });
  const activeItem = computed({
    get: () => {
      if (!modelValue.value) {
        return -1;
      }
      const m2 = modelValue.value.getMinutes();
      return items2.value.findIndex((i2) => i2 === m2);
    },
    set: (newIndex) => {
      if (props2.readonly) {
        return;
      }
      const v2 = items2.value[newIndex];
      modelValue.value = new Date(safeModelValue(modelValue).setMinutes(v2));
    }
  });
  return computed(() => ({
    items: items2.value,
    activeItem
  }));
};
var createSecondsColumn = (props2, modelValue) => {
  const items2 = computed(() => {
    const array = createNumbersArray(60);
    if (!props2.secondsFilter) {
      return array;
    }
    return array.filter(props2.secondsFilter);
  });
  const activeItem = computed({
    get: () => {
      if (!modelValue.value) {
        return -1;
      }
      const s2 = modelValue.value.getSeconds();
      return items2.value.findIndex((i2) => i2 === s2);
    },
    set: (newIndex) => {
      if (props2.readonly) {
        return;
      }
      const v2 = items2.value[newIndex];
      modelValue.value = new Date(safeModelValue(modelValue).setSeconds(v2));
    }
  });
  return computed(() => ({
    items: items2.value,
    activeItem
  }));
};
var createPeriodColumn = (props2, modelValue, isPM) => {
  return computed(() => ({
    items: ["AM", "PM"],
    activeItem: computed({
      get: () => {
        if (!modelValue.value) {
          return -1;
        }
        return Number(isPM.value);
      },
      set: (val) => {
        isPM.value = Boolean(val);
        const h3 = safeModelValue(modelValue).getHours();
        let h24 = isPM.value ? h3 + 12 : h3;
        if (isPM.value && h3 <= 12) {
          h24 = h3 + 12;
        }
        if (!isPM.value && h3 >= 12) {
          h24 = h3 - 12;
        }
        const isValidFilteredHour = !props2.hoursFilter || props2.hoursFilter(h24);
        if (props2.periodUpdatesModelValue && isValidFilteredHour) {
          modelValue.value = new Date(safeModelValue(modelValue).setHours(h24));
        }
      }
    })
  }));
};
var useTimePicker = (props2, modelValue) => {
  const { view } = toRefs(props2);
  const isPM = ref(false);
  watch(modelValue, () => {
    isPM.value = safeModelValue(modelValue).getHours() >= 12;
  }, { immediate: true });
  const hoursColumn = createHoursColumn(props2, modelValue, isPM);
  const minutesColumn = createMinutesColumn(props2, modelValue);
  const secondsColumn = createSecondsColumn(props2, modelValue);
  const periodColumn = createPeriodColumn(props2, modelValue, isPM);
  const columns = computed(() => {
    const array = [];
    if (view.value === "hours") {
      array.push(hoursColumn.value);
    } else if (view.value === "minutes") {
      array.push(hoursColumn.value, minutesColumn.value);
    } else if (view.value === "seconds") {
      array.push(hoursColumn.value, minutesColumn.value, secondsColumn.value);
    }
    if (props2.ampm && !props2.hidePeriodSwitch) {
      array.push(periodColumn.value);
    }
    return array;
  });
  return {
    columns,
    isPM
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-time-picker/components/VaTimePickerColumnCell.vue_vue_type_script_lang.js
var _sfc_main107 = defineComponent({
  name: "VaTimePickerColumnCell",
  setup() {
    const { isHovered, onMouseEnter, onMouseLeave } = useHover();
    const { getTextColor, getColor } = useColors();
    const styleComputed = computed(() => isHovered.value ? {
      color: getColor(getTextColor(getColor("background-secondary"))),
      background: getColor("background-secondary")
    } : void 0);
    return {
      onMouseEnter,
      onMouseLeave,
      styleComputed
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-time-picker/components/VaTimePickerColumnCell.js
function _sfc_render104(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
    onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args)),
    style: normalizeStyle(_ctx.styleComputed)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 36);
}
var VaTimePickerColumnCell = _export_sfc(_sfc_main107, [["render", _sfc_render104]]);

// node_modules/vuestic-ui/dist/es/src/components/va-time-picker/components/VaTimePickerColumn/VaTimePickerColumn.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaTimePickerColumn.css";
var _sfc_main108 = defineComponent({
  name: "VaTimePickerColumn",
  components: { VaTimePickerColumnCell },
  props: {
    items: { type: Array, default: () => [] },
    activeItemIndex: { type: Number, default: 0 },
    cellHeight: { type: Number, default: 30 }
  },
  emits: ["item-selected", "update:activeItemIndex", ...useFocusEmits],
  setup(props2, { emit }) {
    const rootElement = shallowRef();
    const { focus, blur } = useFocus(rootElement, emit);
    const [syncActiveItemIndex] = useSyncProp("activeItemIndex", props2, emit);
    watch(syncActiveItemIndex, (newVal) => {
      scrollTo(newVal);
    });
    onMounted(() => scrollTo(syncActiveItemIndex.value, false));
    const scrollTo = (index, animated = true) => {
      nextTick(() => {
        var _a2, _b;
        (_b = (_a2 = rootElement.value) == null ? void 0 : _a2.scrollTo) == null ? void 0 : _b.call(_a2, {
          behavior: animated ? "smooth" : "auto",
          top: index * props2.cellHeight
        });
      });
    };
    const makeActiveByIndex = (index) => {
      syncActiveItemIndex.value = index;
      nextTick(() => scrollTo(syncActiveItemIndex.value));
    };
    const makeActiveNext = (times) => {
      syncActiveItemIndex.value = (syncActiveItemIndex.value + (times || 1)) % props2.items.length;
      nextTick(() => scrollTo(syncActiveItemIndex.value));
    };
    const makeActivePrev = (times) => {
      syncActiveItemIndex.value = (syncActiveItemIndex.value - (times || 1) + props2.items.length) % props2.items.length;
      nextTick(() => scrollTo(syncActiveItemIndex.value));
    };
    const onCellClick = (index) => {
      syncActiveItemIndex.value = index;
    };
    const formatCell = (n2) => {
      if (!Number.isInteger(n2)) {
        return n2;
      }
      return Number(n2) < 10 ? `0${n2}` : `${n2}`;
    };
    const getIndex = () => {
      const scrollTop = rootElement.value.scrollTop;
      const calculatedIndex = Math.max(
        (scrollTop - scrollTop % props2.cellHeight) / props2.cellHeight,
        scrollTop / props2.cellHeight
      );
      if (calculatedIndex >= props2.items.length) {
        return props2.items.length - 1;
      }
      if (calculatedIndex < 0) {
        return 0;
      }
      if (syncActiveItemIndex.value * props2.cellHeight < scrollTop) {
        return Math.ceil(calculatedIndex);
      } else if (syncActiveItemIndex.value * props2.cellHeight > scrollTop) {
        return Math.floor(calculatedIndex);
      } else {
        return Math.round(calculatedIndex);
      }
    };
    const onScroll = debounce$2(() => {
      if (rootElement.value && syncActiveItemIndex.value !== -1) {
        syncActiveItemIndex.value = getIndex();
      }
    }, 200);
    return {
      syncActiveItemIndex,
      rootElement,
      makeActiveNext,
      makeActivePrev,
      makeActiveByIndex,
      onScroll,
      onCellClick,
      formatCell,
      focus,
      blur
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-time-picker/components/VaTimePickerColumn/VaTimePickerColumn.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaTimePickerColumn.css";
var _hoisted_168 = ["onClick"];
function _sfc_render105(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaTimePickerColumnCell = resolveComponent("VaTimePickerColumnCell");
  return openBlock(), createElementBlock("div", {
    ref: "rootElement",
    tabindex: "0",
    class: "va-time-picker-column",
    onKeydown: [
      _cache[0] || (_cache[0] = withKeys(withModifiers(($event) => _ctx.makeActiveNext(), ["stop", "prevent"]), ["down"])),
      _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.makeActiveNext(5), ["stop", "prevent"]), ["space"])),
      _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => _ctx.makeActivePrev(), ["stop", "prevent"]), ["up"]))
    ]
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.items, (item, index) => {
      return openBlock(), createBlock(_component_VaTimePickerColumnCell, {
        key: item,
        onScrollPassive: _ctx.onScroll,
        onTouchmovePassive: _ctx.onScroll,
        onMousewheelPassive: _ctx.onScroll
      }, {
        default: withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass(["va-time-picker-cell", { "va-time-picker-cell--active": index === _ctx.$props.activeItemIndex }]),
            onClick: ($event) => _ctx.onCellClick(index)
          }, [
            renderSlot(_ctx.$slots, "cell", normalizeProps(guardReactiveProps({ item, index, activeItemIndex: _ctx.activeItemIndex, items: _ctx.items, formattedItem: _ctx.formatCell(item) })), () => [
              createTextVNode(toDisplayString(_ctx.formatCell(item)), 1)
            ])
          ], 10, _hoisted_168)
        ]),
        _: 2
      }, 1032, ["onScrollPassive", "onTouchmovePassive", "onMousewheelPassive"]);
    }), 128))
  ], 544);
}
var _VaTimePickerColumn = _export_sfc(_sfc_main108, [["render", _sfc_render105]]);

// node_modules/vuestic-ui/dist/es/src/components/va-time-picker/components/VaTimePickerColumn/index.js
var VaTimePickerColumn = withConfigTransport$1(_VaTimePickerColumn);

// node_modules/vuestic-ui/dist/es/src/composables/useCSSVariables.js
var useCSSVariables = (prefix2, cb) => {
  return computed(() => Object.entries(cb()).reduce((acc, [key, value]) => {
    acc[`--${prefix2}-${kebabCase$1(key)}`] = value;
    return acc;
  }, {}));
};

// node_modules/vuestic-ui/dist/es/src/components/va-time-picker/VaTimePicker.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaTimePicker.css";
var _sfc_main109 = defineComponent({
  name: "VaTimePicker",
  components: { VaTimePickerColumn },
  props: {
    ...useStatefulProps,
    ...useFormFieldProps,
    ...useComponentPresetProp,
    modelValue: { type: Date, required: false },
    ampm: { type: Boolean, default: false },
    hidePeriodSwitch: { type: Boolean, default: false },
    periodUpdatesModelValue: { type: Boolean, default: true },
    // Update model value when switching period automatically
    view: { type: String, default: "minutes" },
    hoursFilter: { type: Function },
    minutesFilter: { type: Function },
    secondsFilter: { type: Function },
    framed: { type: Boolean, default: false },
    cellHeight: { type: Number, default: 30 },
    visibleCellsCount: { type: Number, default: 7 }
  },
  emits: [...useStatefulEmits],
  setup(props2, { emit }) {
    const { valueComputed } = useStateful(props2, emit);
    const { columns, isPM } = useTimePicker(props2, valueComputed);
    const { setItemRef, itemRefs: pickers } = useArrayRefs();
    const activeColumnIndex = ref();
    const focus = (idx = 0) => {
      var _a2;
      (_a2 = pickers.value[idx]) == null ? void 0 : _a2.focus();
    };
    const blur = (idx) => {
      var _a2;
      idx ? (_a2 = pickers.value[idx]) == null ? void 0 : _a2.blur() : pickers.value.forEach((el) => el == null ? void 0 : el.blur());
    };
    const { computedClasses: computedFormClasses } = useFormField("va-time-picker", props2);
    const focusNext = () => {
      const nextIndex = ((activeColumnIndex == null ? void 0 : activeColumnIndex.value) || 0) + 1;
      activeColumnIndex.value = nextIndex % columns.value.length;
      focus(activeColumnIndex.value);
    };
    const focusPrev = () => {
      const nextIndex = ((activeColumnIndex == null ? void 0 : activeColumnIndex.value) || 0) - 1 + columns.value.length;
      activeColumnIndex.value = nextIndex % columns.value.length;
      focus(activeColumnIndex.value);
    };
    const computedClasses = computed(() => ({
      ...computedFormClasses,
      "va-time-picker--framed": props2.framed
    }));
    const computedStyles = useCSSVariables("va-time-picker", () => {
      const gapHeight = (props2.visibleCellsCount - 1) / 2 * props2.cellHeight;
      return {
        height: `${props2.cellHeight * props2.visibleCellsCount}px`,
        "cell-height": `${props2.cellHeight}px`,
        "column-gap-height": `${gapHeight}px`
      };
    });
    return {
      columns,
      computedStyles,
      computedClasses,
      isPM,
      pickers,
      setItemRef,
      focusNext,
      focusPrev,
      activeColumnIndex,
      focus,
      blur
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-time-picker/VaTimePicker.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaTimePicker.css";
function _sfc_render106(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaTimePickerColumn = resolveComponent("VaTimePickerColumn");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-time-picker", _ctx.computedClasses]),
    style: normalizeStyle(_ctx.computedStyles)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.columns, (column, idx) => {
      return openBlock(), createBlock(_component_VaTimePickerColumn, {
        key: idx,
        ref_for: true,
        ref: _ctx.setItemRef,
        items: column.items,
        tabindex: _ctx.disabled ? -1 : 0,
        "cell-height": _ctx.$props.cellHeight,
        activeItemIndex: column.activeItem.value,
        "onUpdate:activeItemIndex": ($event) => column.activeItem.value = $event,
        onKeydown: [
          _cache[0] || (_cache[0] = withKeys(withModifiers(($event) => _ctx.focusNext(), ["stop", "prevent"]), ["right"])),
          _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.focusNext(), ["exact", "stop", "prevent"]), ["tab"])),
          _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => _ctx.focusPrev(), ["stop", "prevent"]), ["left"])),
          _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.focusPrev(), ["shift", "stop", "prevent"]), ["tab"]))
        ],
        onFocus: ($event) => _ctx.activeColumnIndex = idx
      }, null, 8, ["items", "tabindex", "cell-height", "activeItemIndex", "onUpdate:activeItemIndex", "onFocus"]);
    }), 128))
  ], 6);
}
var _VaTimePicker = _export_sfc(_sfc_main109, [["render", _sfc_render106]]);

// node_modules/vuestic-ui/dist/es/src/composables/useLongPresKey.js
function useLongPressKey(el, options) {
  let timeoutId = -1;
  let intervalId = -1;
  const handleMouseDown = (e2) => {
    var _a2;
    (_a2 = options.onStart) == null ? void 0 : _a2.call(options, e2);
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      intervalId = setInterval(() => {
        var _a22;
        return (_a22 = options.onUpdate) == null ? void 0 : _a22.call(options, e2);
      }, options.interval || 100);
    }, unref(options.delay) || 500);
  };
  const handleMouseUp = (e2) => {
    var _a2;
    clearTimeout(timeoutId);
    clearInterval(intervalId);
    (_a2 = options.onEnd) == null ? void 0 : _a2.call(options, e2);
  };
  const htmlElement = useHTMLElement(el);
  useEvent(["keydown"], handleMouseDown, htmlElement);
  useEvent([
    "keyup",
    "blur"
  ], handleMouseUp, true);
}

// node_modules/vuestic-ui/dist/es/src/components/va-time-input/VaTimeInput.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaTimeInput.css";
var VaInputWrapperProps5 = extractComponentProps(VaInputWrapper, ["focused", "maxLength", "counterValue"]);
var _sfc_main110 = defineComponent({
  name: "VaTimeInput",
  components: { VaDropdown, VaDropdownContent, VaTimePicker: _VaTimePicker, VaIcon, VaInputWrapper },
  emits: [
    ...useFocusEmits,
    ...useValidationEmits,
    ...useClearableEmits,
    ...useStatefulEmits,
    ...useDropdownableEmits,
    "update:modelValue"
  ],
  props: {
    ...VaInputWrapperProps5,
    ...useDropdownableProps,
    ...useComponentPresetProp,
    ...useClearableProps,
    ...extractComponentProps(_VaTimePicker),
    ...useValidationProps,
    ...useStatefulProps,
    closeOnContentClick: { type: Boolean, default: false },
    offset: { ...useDropdownableProps.offset, default: () => [2, 0] },
    placement: { ...useDropdownableProps.placement, default: "bottom-end" },
    modelValue: { type: Date, default: void 0 },
    clearValue: { type: Date, default: void 0 },
    format: { type: Function },
    parse: { type: Function },
    manualInput: { type: Boolean, default: false },
    leftIcon: { type: Boolean, default: false },
    icon: { type: String, default: "schedule" },
    ariaLabel: { type: String, default: "$t:selectedTime" },
    ariaResetLabel: { type: String, default: "$t:resetTime" },
    ariaToggleDropdownLabel: { type: String, default: "$t:toggleDropdown" }
  },
  inheritAttrs: false,
  setup(props2, { emit, slots, attrs }) {
    const input = shallowRef();
    const timePicker = shallowRef();
    const { isOpenSync, dropdownProps } = useDropdownable(props2, emit, {
      defaultCloseOnValueUpdate: computed(() => Array.isArray(props2.view) && props2.view.length === 1)
    });
    const { valueComputed } = useStateful(props2, emit);
    const { parse: parse2, isValid } = useTimeParser(props2);
    const { format } = useTimeFormatter(props2);
    const valueText = computed(() => format(valueComputed.value || props2.clearValue));
    const doShowDropdown = computed({
      get() {
        if (props2.disabled || props2.readonly) {
          return false;
        }
        return isOpenSync.value;
      },
      set(v2) {
        isOpenSync.value = v2;
        if (v2) {
          nextTick(() => {
            var _a2;
            return (_a2 = timePicker.value) == null ? void 0 : _a2.focus();
          });
        } else {
          nextTick(() => {
            var _a2;
            return (_a2 = input.value) == null ? void 0 : _a2.focus();
          });
        }
      }
    });
    const { isFocused, focus, blur, onFocus: focusListener, onBlur: blurListener } = useFocus(input);
    const onInputTextChanged = (e2) => {
      var _a2;
      if (props2.disabled) {
        return;
      }
      const val = (_a2 = e2.target) == null ? void 0 : _a2.value;
      if (!val) {
        return reset();
      }
      const v2 = parse2(val);
      if (isValid.value && v2) {
        valueComputed.value = v2;
      } else {
        valueComputed.value = void 0;
        isValid.value = true;
      }
    };
    const reset = () => withoutValidation(() => {
      emit("update:modelValue", props2.clearValue);
      emit("clear");
      resetValidation();
      hideDropdown();
    });
    const {
      computedError,
      computedErrorMessages,
      listeners,
      validationAriaAttributes,
      withoutValidation,
      resetValidation
    } = useValidation(props2, emit, { reset, focus, value: valueComputed });
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props2, valueText);
    const canBeClearedComputed = computed(() => canBeCleared.value && valueText.value !== format(props2.clearValue));
    const filteredWrapperProps = filterComponentProps(VaInputWrapperProps5);
    const computedInputWrapperProps = computed(() => ({
      ...filteredWrapperProps.value,
      focused: isFocused.value,
      error: computedError.value,
      errorMessages: computedErrorMessages.value,
      readonly: props2.readonly || !props2.manualInput
    }));
    const viewToNumber = {
      seconds: 1e3,
      minutes: 1e3 * 60,
      hours: 1e3 * 60 * 60
    };
    const onKeyPress = (e2) => {
      if (!("key" in e2)) {
        return;
      }
      if (e2.key === "ArrowDown") {
        valueComputed.value = new Date(Number(valueComputed.value) - viewToNumber[props2.view]);
        e2.preventDefault();
      }
      if (e2.key === "ArrowUp") {
        valueComputed.value = new Date(Number(valueComputed.value) + viewToNumber[props2.view]);
        e2.preventDefault();
      }
    };
    useLongPressKey(input, {
      onStart: onKeyPress,
      onUpdate: onKeyPress
    });
    const computedInputListeners = {
      focus: () => {
        if (props2.disabled) {
          return;
        }
        focusListener();
        if (props2.readonly) {
          return;
        }
        onFocus();
        listeners.onFocus();
      },
      blur: () => {
        if (props2.disabled) {
          return;
        }
        blurListener();
        if (props2.readonly) {
          return;
        }
        onBlur();
        listeners.onBlur();
      }
    };
    const filteredSlots = computed(() => {
      const slotsWithIcons = [
        props2.leftIcon && "prependInner",
        (!props2.leftIcon || props2.clearable) && "icon"
      ];
      return Object.keys(slots).filter((slot) => !slotsWithIcons.includes(slot));
    });
    const hideDropdown = () => {
      doShowDropdown.value = false;
    };
    const showDropdown = (event, cancel, prevent) => {
      doShowDropdown.value = true;
    };
    const checkProhibitedDropdownOpening = (e2) => {
      if (isOpenSync.value) {
        return false;
      }
      if (props2.disabled || props2.readonly) {
        return true;
      }
      return props2.manualInput && (e2 == null ? void 0 : e2.code) !== "Space";
    };
    const toggleDropdown = (event) => {
      if (checkProhibitedDropdownOpening(event instanceof KeyboardEvent ? event : void 0)) {
        return;
      }
      doShowDropdown.value = !doShowDropdown.value;
    };
    const cursorStyleComputed = computed(() => {
      if (props2.disabled) {
        return {};
      }
      if (props2.manualInput) {
        return { cursor: "text" };
      }
      return { cursor: "pointer" };
    });
    const iconTabindexComputed = computed(() => {
      if (!props2.manualInput) {
        return -1;
      }
      return props2.disabled || props2.readonly ? -1 : 0;
    });
    const iconProps = computed(() => ({
      role: "button",
      "aria-hidden": false,
      name: props2.icon,
      color: "secondary",
      tabindex: iconTabindexComputed.value
    }));
    const { tp } = useTranslation();
    const inputAttributesComputed = computed(() => ({
      readonly: props2.readonly || !props2.manualInput,
      disabled: props2.disabled,
      tabindex: props2.disabled ? -1 : 0,
      value: valueText.value,
      "aria-label": props2.label || tp(props2.ariaLabel),
      "aria-required": props2.requiredMark,
      "aria-disabled": props2.disabled,
      "aria-readonly": props2.readonly,
      ...validationAriaAttributes.value,
      ...omit$1(attrs, ["class", "style"])
    }));
    const dropdownPropsComputed = computed(() => ({
      ...dropdownProps.value,
      keyboardNavigation: true,
      innerAnchorSelector: ".va-input-wrapper__field",
      trigger: "none"
    }));
    return {
      tp,
      input,
      timePicker,
      timePickerProps: filterComponentProps(extractComponentProps(_VaTimePicker)),
      dropdownPropsComputed,
      computedInputWrapperProps,
      computedInputListeners,
      isOpenSync,
      doShowDropdown,
      valueComputed,
      valueText,
      onInputTextChanged,
      canBeClearedComputed,
      iconProps,
      clearIconProps,
      filteredSlots,
      inputAttributesComputed,
      cursorStyleComputed,
      hideDropdown,
      showDropdown,
      toggleDropdown,
      reset,
      focus,
      blur
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-time-input/VaTimeInput.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaTimeInput.css";
function _sfc_render107(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  const _component_va_time_picker = resolveComponent("va-time-picker");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createBlock(_component_va_dropdown, mergeProps({
    modelValue: _ctx.doShowDropdown,
    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.doShowDropdown = $event),
    class: ["va-time-input", _ctx.$attrs.class],
    style: _ctx.$attrs.style
  }, _ctx.dropdownPropsComputed), {
    anchor: withCtx(() => [
      createVNode(_component_va_input_wrapper, mergeProps({
        class: "va-time-input__anchor",
        style: _ctx.cursorStyleComputed
      }, _ctx.computedInputWrapperProps, {
        onClick: withModifiers(_ctx.toggleDropdown, ["stop"])
      }), createSlots({
        default: withCtx(() => [
          createBaseVNode("input", mergeProps({
            ref: "input",
            class: "va-time-input__input"
          }, _ctx.inputAttributesComputed, toHandlers(_ctx.computedInputListeners, true), {
            onChange: _cache[0] || (_cache[0] = (...args) => _ctx.onInputTextChanged && _ctx.onInputTextChanged(...args))
          }), null, 16)
        ]),
        icon: withCtx(() => [
          _ctx.canBeClearedComputed ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 0,
            class: "va-time-input__clear-button"
          }, { ..._ctx.iconProps, ..._ctx.clearIconProps }, {
            "aria-label": _ctx.tp(_ctx.$props.ariaResetLabel),
            onClick: withModifiers(_ctx.reset, ["stop"]),
            onKeydown: [
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
            ]
          }), null, 16, ["aria-label", "onClick", "onKeydown"])) : createCommentVNode("", true),
          !_ctx.$props.leftIcon && _ctx.$props.icon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 1,
            class: "va-time-input__right-button va-time-input__side-button",
            "aria-label": _ctx.tp(_ctx.$props.ariaToggleDropdownLabel)
          }, _ctx.iconProps), null, 16, ["aria-label"])) : createCommentVNode("", true)
        ]),
        _: 2
      }, [
        renderList(_ctx.filteredSlots, (name) => {
          return {
            name,
            fn: withCtx((slotScope) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps({ ...slotScope, toggleDropdown: _ctx.toggleDropdown, showDropdown: _ctx.showDropdown, hideDropdown: _ctx.hideDropdown, isOpen: _ctx.isOpenSync, focus: _ctx.focus })))
            ])
          };
        }),
        _ctx.$slots.prependInner || _ctx.$props.leftIcon ? {
          name: "prependInner",
          fn: withCtx((slotScope) => [
            renderSlot(_ctx.$slots, "prependInner", normalizeProps(guardReactiveProps({ ...slotScope, toggleDropdown: _ctx.toggleDropdown, showDropdown: _ctx.showDropdown, hideDropdown: _ctx.hideDropdown, isOpen: _ctx.isOpenSync, focus: _ctx.focus }))),
            _ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
              key: 0,
              class: "va-time-input__left-button va-time-input__side-button",
              "aria-label": _ctx.tp(_ctx.$props.ariaToggleDropdownLabel)
            }, _ctx.iconProps), null, 16, ["aria-label"])) : createCommentVNode("", true)
          ]),
          key: "0"
        } : void 0
      ]), 1040, ["style", "onClick"])
    ]),
    default: withCtx(() => [
      createVNode(_component_va_dropdown_content, {
        "no-padding": "",
        onKeydown: [
          withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["esc"]),
          withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["enter"])
        ]
      }, {
        default: withCtx(() => [
          createVNode(_component_va_time_picker, mergeProps({ ref: "timePicker" }, _ctx.timePickerProps, {
            modelValue: _ctx.valueComputed,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.valueComputed = $event)
          }), null, 16, ["modelValue"])
        ]),
        _: 1
      }, 8, ["onKeydown"])
    ]),
    _: 3
  }, 16, ["modelValue", "class", "style"]);
}
var _VaTimeInput = _export_sfc(_sfc_main110, [["render", _sfc_render107]]);

// node_modules/vuestic-ui/dist/es/src/components/va-time-input/index.js
var VaTimeInput = withConfigTransport$1(_VaTimeInput);

// node_modules/vuestic-ui/dist/es/src/components/va-timeline/VaTimeline.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaTimeline.css";
var getPropsData = (slot) => slot == null ? void 0 : slot.props;
var getIsActive = (slot) => {
  var _a2;
  return !!((_a2 = slot == null ? void 0 : slot.props) == null ? void 0 : _a2.active) || false;
};
var isVueFragment = (slot) => slot.type === Fragment;
var isEmptyArray = (arr) => arr && arr.length === 0;
function getSlots(slots) {
  var _a2;
  const defaultSlots = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
  if (!defaultSlots || isEmptyArray(defaultSlots)) {
    return [];
  }
  if (isVueFragment(defaultSlots[0])) {
    return defaultSlots[0].children;
  }
  return defaultSlots;
}
var processSlots = (context) => {
  const slots = getSlots(context.slots);
  slots.forEach((slot, index) => {
    if (!getPropsData(slot)) {
      slot.props = {};
    }
    const propsData = getPropsData(slot);
    propsData.vertical = context.props.vertical;
    if (context.props.centered) {
      propsData.inverted = !!(index % 2);
    }
    if (index === 0) {
      propsData.isFirst = true;
    }
    if (index === slots.length - 1) {
      propsData.isLast = true;
    }
    const currentSlotActive = propsData.active;
    if (!currentSlotActive) {
      return;
    }
    if (index === 0) {
      propsData.activePrevious = currentSlotActive;
    }
    if (index === slots.length - 1) {
      propsData.activeNext = currentSlotActive;
    }
    const previousSlotActive = getIsActive(slots[index - 1]);
    if (previousSlotActive) {
      propsData.activePrevious = true;
    }
    const nextSlotActive = getIsActive(slots[index + 1]);
    if (nextSlotActive) {
      propsData.activeNext = true;
    }
  });
  return slots;
};
var COMPONENT_NAME = "va-timeline";
var _sfc_main111 = {
  name: COMPONENT_NAME,
  props: {
    ...useComponentPresetProp,
    vertical: { type: Boolean },
    centered: { type: Boolean },
    alignTop: { type: Boolean }
  },
  setup(props2, { slots }) {
    return () => h(
      "div",
      {
        class: {
          [COMPONENT_NAME]: true,
          [`${COMPONENT_NAME}--vertical`]: props2.vertical,
          [`${COMPONENT_NAME}--align-top`]: props2.alignTop
        }
      },
      processSlots({ props: props2, slots })
    );
  }
};

// node_modules/vuestic-ui/dist/es/src/components/va-timeline/index.js
var VaTimeline = withConfigTransport$1(_sfc_main111);

// node_modules/vuestic-ui/dist/es/src/components/va-timeline/VaTimelineSeparator/VaTimelineSeparator.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaTimelineSeparator.css";
var componentName = "va-timeline-separator";
var _sfc_main112 = defineComponent({
  name: componentName,
  props: {
    ...useComponentPresetProp,
    color: { type: String, default: "primary" },
    vertical: { type: Boolean },
    active: { type: Boolean },
    activePrevious: { type: Boolean },
    activeNext: { type: Boolean }
  },
  setup(props2) {
    const { getColor } = useColors();
    return () => h(
      "div",
      {
        class: {
          [componentName]: true,
          [`${componentName}--vertical`]: props2.vertical
        }
      },
      [
        h("div", {
          class: {
            [`${componentName}__line`]: true,
            [`${componentName}__line--active`]: props2.activePrevious
          },
          style: {
            backgroundColor: getColor(props2.activePrevious ? props2.color : "divider")
          }
        }),
        h("div", {
          class: {
            [`${componentName}__center`]: true,
            [`${componentName}__center--active`]: props2.active
          },
          style: {
            backgroundColor: getColor(props2.active ? props2.color : "divider")
          }
        }),
        h("div", {
          class: {
            [`${componentName}__line`]: true,
            [`${componentName}__line--active`]: props2.activeNext
          },
          style: {
            backgroundColor: getColor(props2.activeNext ? props2.color : "divider")
          }
        })
      ]
    );
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-timeline/VaTimelineSeparator/index.js
var VaTimelineSeparator = withConfigTransport$1(_sfc_main112);

// node_modules/vuestic-ui/dist/es/src/components/va-timeline/VaTimelineItem/VaTimelineItem.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaTimelineItem.css";
var COMPONENT_NAME2 = "va-timeline-item";
var VaTimelineSeparatorProps = extractComponentProps(VaTimelineSeparator);
var _sfc_main113 = defineComponent({
  name: COMPONENT_NAME2,
  props: {
    ...useComponentPresetProp,
    ...VaTimelineSeparatorProps,
    color: { type: String, default: "primary" },
    isFirst: { type: Boolean },
    isLast: { type: Boolean },
    inverted: { type: Boolean }
  },
  setup(props2, { slots }) {
    const children = [
      h(
        VaTimelineSeparator,
        { ...filterComponentProps(VaTimelineSeparatorProps).value }
      )
    ];
    const before = props2.inverted ? slots.after : slots.before;
    if (before) {
      children.unshift(
        h(
          "div",
          { class: `${COMPONENT_NAME2}__before` },
          before()
        )
      );
    }
    const after = props2.inverted ? slots.before : slots.after;
    if (after) {
      children.push(
        h(
          "div",
          { class: `${COMPONENT_NAME2}__after` },
          after()
        )
      );
    }
    return () => h(
      "div",
      {
        class: [
          { [COMPONENT_NAME2]: true },
          { [`${COMPONENT_NAME2}--vertical`]: props2.vertical },
          { [`${COMPONENT_NAME2}--is-first`]: props2.isFirst },
          { [`${COMPONENT_NAME2}--is-last`]: props2.isLast }
        ]
      },
      children
    );
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-timeline/VaTimelineItem/index.js
var VaTimelineItem = withConfigTransport$1(_sfc_main113);

// node_modules/vuestic-ui/dist/es/src/components/va-time-picker/index.js
var VaTimePicker = withConfigTransport$1(_VaTimePicker);

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/hooks/useTreeHelpers.js
var useTreeViewProps = {
  nodes: {
    type: Array,
    default: []
  },
  stateful: {
    type: Boolean,
    default: true
  },
  selectable: {
    type: Boolean,
    default: false
  },
  selectionType: {
    type: String,
    default: "leaf",
    validator: (v2) => ["leaf", "independent"].includes(v2)
  },
  valueBy: {
    type: [String, Function],
    default: "id"
  },
  textBy: {
    type: [String, Function],
    default: "label"
  },
  trackBy: {
    type: [String, Function],
    default: "id"
  },
  iconBy: {
    type: [String, Function],
    default: "icon"
  },
  disabledBy: {
    type: [String, Function],
    default: "disabled"
  },
  expandedBy: {
    type: [String, Function],
    default: "expanded"
  },
  checkedBy: {
    type: [String, Function],
    default: "checked"
  },
  childrenBy: {
    type: [String, Function],
    default: "children"
  },
  expandAll: {
    type: Boolean,
    default: false
  },
  expanded: {
    type: Array,
    default: []
  },
  expandNodeBy: {
    type: String,
    default: "leaf"
  },
  filter: {
    type: String,
    default: ""
  },
  filterMethod: {
    type: Function,
    default: void 0
  },
  checked: {
    type: Array,
    default: []
  },
  color: {
    type: String,
    default: "primary"
  }
};
var useTreeViewEmits = ["update:modelValue", "update:checked", "update:expanded", "update:selected"];
var useTreeHelpers = (props2) => {
  const isStringOrNumber = (node) => {
    const typeOfNode = typeof node;
    return typeOfNode === "string" || typeOfNode === "number";
  };
  const getNodeProperty = (node, key) => !key || isStringOrNumber(node) ? node : getValueByKey(node, key);
  const getValue2 = (node) => getNodeProperty(node, props2.valueBy);
  const getNodeByValue = (value) => {
    if (!props2.valueBy) {
      return value;
    }
    return props2.nodes.find((node) => value === getValue2(node)) || value;
  };
  const getText = (node) => getNodeProperty(node, props2.textBy);
  const getChecked = (node) => getNodeProperty(node, props2.checkedBy);
  const getDisabled = (node) => getNodeProperty(node, props2.disabledBy);
  const getExpanded = (node) => getNodeProperty(node, props2.expandedBy);
  const getTrackBy = (node) => getNodeProperty(node, props2.trackBy);
  const getChildren = (node) => getNodeProperty(node, props2.childrenBy) ?? [];
  const iterateNodes = (nodes, cb) => {
    nodes.forEach((node) => {
      const children = node.children || [];
      if (children.length) {
        iterateNodes(children, cb);
      }
      cb(node);
    });
  };
  return {
    getText,
    getValue: getValue2,
    getChecked,
    getTrackBy,
    getChildren,
    getDisabled,
    getExpanded,
    iterateNodes,
    getNodeByValue,
    getNodeProperty
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/types.js
var TreeViewKey = Symbol("TreeView");

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/hooks/useTreeKeyboardNavigation.js
var useTreeKeyboardNavigation = (props2, methods) => {
  const { emit, toggleNode, toggleCheckbox } = methods;
  const isElementExpanded = (currentElement) => (currentElement == null ? void 0 : currentElement.getAttribute("aria-expanded")) === "true";
  const getParentElement = (currentElement) => {
    var _a2;
    return ((_a2 = currentElement == null ? void 0 : currentElement.parentElement) == null ? void 0 : _a2.closest(".va-tree-node")) || null;
  };
  const getPreviousElement = (currentElement) => currentElement == null ? void 0 : currentElement.previousElementSibling;
  const findPreviousElement = (currentElement) => {
    if (!currentElement) {
      return null;
    }
    let previousElement = getPreviousElement(currentElement);
    let lastChildElement = isElementExpanded(previousElement) && getLastChildElement(previousElement);
    if (lastChildElement) {
      do {
        if (isElementExpanded(lastChildElement)) {
          lastChildElement = getLastChildElement(lastChildElement);
          if (lastChildElement) {
            continue;
          } else {
            break;
          }
        } else {
          previousElement = lastChildElement;
          break;
        }
      } while (true);
    }
    if (!previousElement) {
      return getParentElement(currentElement);
    }
    return previousElement;
  };
  const getNextElement = (currentElement) => currentElement == null ? void 0 : currentElement.nextElementSibling;
  const findNextElement = (currentElement) => {
    if (!currentElement) {
      return null;
    }
    let nextElement = getNextElement(currentElement);
    const isCurrentExpanded = isElementExpanded(currentElement);
    if (!nextElement) {
      let parentElement = getParentElement(currentElement);
      do {
        if (!getNextElement(parentElement)) {
          parentElement = getParentElement(parentElement);
          if (!parentElement) {
            break;
          } else {
            continue;
          }
        } else {
          nextElement = getNextElement(parentElement);
          break;
        }
      } while (true);
    }
    if (isCurrentExpanded) {
      return getFirstChildElement(currentElement);
    }
    return nextElement;
  };
  const getFirstChildElement = (currentElement) => {
    var _a2;
    return ((_a2 = currentElement == null ? void 0 : currentElement.querySelector(".va-tree-node-children")) == null ? void 0 : _a2.firstElementChild) || null;
  };
  const getLastChildElement = (currentElement) => {
    var _a2;
    return ((_a2 = currentElement == null ? void 0 : currentElement.querySelector(".va-tree-node-children")) == null ? void 0 : _a2.lastElementChild) || null;
  };
  const onHorizontalMove = (currentElement, dir, node) => {
    var _a2, _b;
    const isCurrentElementExpanded = isElementExpanded(currentElement);
    if (dir === "left") {
      if (isCurrentElementExpanded) {
        toggleNode(node);
      } else {
        (_a2 = getParentElement(currentElement)) == null ? void 0 : _a2.focus();
      }
    } else {
      if (!isCurrentElementExpanded) {
        toggleNode(node);
      } else {
        (_b = getFirstChildElement(currentElement)) == null ? void 0 : _b.focus();
      }
    }
  };
  const onVerticalMove = (currentElement, dir) => {
    var _a2, _b;
    if (dir === "up") {
      (_a2 = findPreviousElement(currentElement)) == null ? void 0 : _a2.focus();
    } else {
      (_b = findNextElement(currentElement)) == null ? void 0 : _b.focus();
    }
  };
  const handleKeyboardNavigation = (event, node) => {
    const currentElement = event.target;
    switch (event.code) {
      case "ArrowUp":
        onVerticalMove(currentElement, "up");
        break;
      case "ArrowRight":
        onHorizontalMove(currentElement, "right", node);
        break;
      case "ArrowDown":
        onVerticalMove(currentElement, "down");
        break;
      case "ArrowLeft":
        onHorizontalMove(currentElement, "left", node);
        break;
      case "Space":
        if (props2.selectable) {
          const state = typeof node.checked !== "undefined" ? !node.checked : null;
          toggleCheckbox(node, state);
        } else {
          emit("update:selected", node);
        }
        break;
      case "Escape":
        if (!props2.selectable) {
          emit("update:selected", null);
        }
        currentElement.blur();
        break;
      default:
        currentElement.blur();
    }
  };
  return { handleKeyboardNavigation };
};
var useTreeKeyboardNavigation$1 = useTreeKeyboardNavigation;

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/hooks/useTreeView.js
var useTreeView = (props2, emit) => {
  const { getColor } = useColors();
  const colorComputed = computed(() => getColor(props2.color));
  const isLeafSelectionComputed = computed(() => props2.selectionType === "leaf");
  const {
    getText,
    getValue: getValue2,
    getChecked,
    getTrackBy,
    getChildren,
    getDisabled,
    getExpanded,
    iterateNodes,
    getNodeProperty
  } = useTreeHelpers(props2);
  const { nodes, expandAll, filter, filterMethod, textBy } = toRefs(props2);
  const { valueComputed: expandedList } = useStateful(props2, emit, "expanded");
  const { valueComputed: checkedList } = useStateful(props2, emit, "checked");
  const selectedNode = ref();
  const selectedNodeComputed = computed({
    get: () => selectedNode.value,
    set: (node) => {
      const value = getValue2(node);
      if (selectedNode.value !== value) {
        selectedNode.value = value;
        emit("update:selected", node);
      }
    }
  });
  const updateModel = (model, values, state) => {
    if (state) {
      model.value = model.value.concat(values).filter((value, idx, self2) => self2.indexOf(value) === idx);
    } else {
      model.value = model.value.filter((v2) => !values.includes(v2));
    }
  };
  const toggleCheckbox = (node, state) => {
    let stateValue = state === null ? true : state;
    if (state && node.indeterminate) {
      stateValue = false;
    }
    const values = [getValue2(node)];
    if (isLeafSelectionComputed.value && node.hasChildren) {
      const toggleChildren = (nodes2) => {
        nodes2.forEach((node2) => {
          if (node2.disabled) {
            return;
          }
          const children = getChildren(node2);
          if (children.length) {
            toggleChildren(children);
          }
          values.push(getValue2(node2));
        });
      };
      toggleChildren(getChildren(node));
    }
    updateModel(checkedList, values, stateValue);
  };
  const toggleNode = (node) => {
    if (node.hasChildren) {
      updateModel(expandedList, [getValue2(node)], !node.expanded);
    }
  };
  const createNode = ({ node, level, children = [], computedFilterMethod: computedFilterMethod2 }) => {
    var _a2;
    const valueBy = getValue2(node);
    let matchesFilter = true;
    const hasChildren = !!children.length;
    const disabled = getDisabled(node) || false;
    let indeterminate = false;
    let checked = checkedList.value.includes(valueBy) || false;
    if (isLeafSelectionComputed.value && hasChildren) {
      const isAllChildrenChecked = children.every((c2) => c2.checked);
      checked = isAllChildrenChecked;
      indeterminate = !isAllChildrenChecked && children.some((c2) => c2.indeterminate || c2.checked);
      if (indeterminate) {
        checked = null;
      }
    }
    if (filter.value) {
      matchesFilter = (children == null ? void 0 : children.some((c2) => c2.matchesFilter)) || ((_a2 = computedFilterMethod2.value) == null ? void 0 : _a2.call(computedFilterMethod2, node, filter.value, textBy.value));
    }
    return {
      ...node,
      level,
      checked,
      children,
      disabled,
      expanded: expandedList.value.includes(valueBy) || false,
      hasChildren,
      matchesFilter,
      indeterminate
    };
  };
  const computedFilterMethod = computed(() => {
    if (filterMethod == null ? void 0 : filterMethod.value) {
      return filterMethod.value;
    }
    return (node, filter2) => getText(node).toLowerCase().includes(filter2.toLowerCase());
  });
  const buildTree = (nodes2, level = 0) => nodes2.map((node) => {
    const treeItemChildren = getChildren(node);
    if (treeItemChildren.length) {
      const children = buildTree(treeItemChildren, level + 1);
      return createNode({ node, level, children, computedFilterMethod });
    }
    return createNode({ node, level, computedFilterMethod });
  });
  const getFilteredNodes = (nodes2) => nodes2.filter((node) => {
    if (node.children) {
      node.children = getFilteredNodes(node.children);
    }
    if (node.children.length === 0) {
      node.hasChildren = false;
    }
    return node.matchesFilter;
  });
  const { handleKeyboardNavigation } = useTreeKeyboardNavigation$1(props2, { emit, toggleCheckbox, toggleNode });
  provide(TreeViewKey, {
    selectedNodeComputed,
    colorComputed,
    iconBy: props2.iconBy,
    selectable: props2.selectable,
    expandNodeBy: props2.expandNodeBy,
    getText,
    getValue: getValue2,
    getTrackBy,
    toggleNode,
    toggleCheckbox,
    getNodeProperty,
    handleKeyboardNavigation
  });
  const treeItems = computed(() => buildTree(nodes.value));
  const checkForInitialValues = () => {
    const expandedValues = [];
    const checkedValues = [];
    iterateNodes(nodes.value, (node) => {
      if (expandAll.value) {
        expandedValues.push(getValue2(node));
      } else {
        getExpanded(node) && expandedValues.push(getValue2(node));
      }
      if (getChecked(node)) {
        checkedValues.push(getValue2(node));
      }
    });
    if (expandedValues.length) {
      updateModel(expandedList, expandedValues, true);
    }
    if (checkedValues.length) {
      updateModel(checkedList, checkedValues, true);
    }
  };
  checkForInitialValues();
  return {
    treeItems: computed(() => getFilteredNodes(treeItems.value)),
    getText,
    getTrackBy,
    toggleCheckbox
  };
};
var useTreeView$1 = useTreeView;

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/components/VaTreeNode/VaTreeNode.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaTreeNode.css";
var INJECTION_ERROR_MESSAGE5 = "The VaTreeNode component should be used in the context of VaTreeView component";
var _sfc_main114 = defineComponent({
  name: "VaTreeNode",
  props: {
    node: {
      type: Object,
      required: true
    }
  },
  components: { VaCheckbox, VaIcon },
  setup: (props2) => {
    const {
      iconBy,
      selectable,
      expandNodeBy,
      colorComputed,
      selectedNodeComputed,
      getText,
      getTrackBy,
      toggleNode,
      toggleCheckbox,
      getNodeProperty,
      handleKeyboardNavigation
    } = useStrictInject(TreeViewKey, INJECTION_ERROR_MESSAGE5);
    const labelComputed = computed(() => getText(props2.node) || "");
    const isExpandedComputed = computed(() => props2.node.hasChildren ? !!props2.node.expanded : void 0);
    const iconComputed = computed(() => getNodeProperty(props2.node, iconBy));
    const roleComputed = computed(() => props2.node.hasChildren ? "group" : "treeitem");
    const treeNodeClassComputed = useBem("va-tree-node", () => ({
      disabled: Boolean(props2.node.disabled),
      checked: Boolean(props2.node.checked),
      hasChildren: Boolean(props2.node.hasChildren),
      [`level-${props2.node.level}`]: true,
      [`expand-by-${expandNodeBy}`]: true
    }));
    const expandedClassComputed = useBem("va-tree-node-children", () => ({
      expanded: !!isExpandedComputed.value
    }));
    const indentClassComputed = useBem("va-tree-node-content", () => ({
      indent: props2.node.hasChildren === false
    }));
    const cursorClassComputed = useBem("va-tree-node-content", () => ({
      clickable: props2.node.hasChildren === true && expandNodeBy === "node"
    }));
    const tabIndexComputed = computed(() => props2.node.disabled ? -1 : 0);
    const onNodeClick = (type) => {
      const nodeType = expandNodeBy === "node" && type === "leaf" ? "node" : type;
      if (expandNodeBy === nodeType) {
        toggleNode(props2.node);
      }
      selectedNodeComputed.value = props2.node;
    };
    return {
      selectable,
      expandNodeBy,
      getText,
      getTrackBy,
      toggleNode,
      onNodeClick,
      handleKeyboardNavigation,
      toggleCheckbox,
      roleComputed,
      iconComputed,
      labelComputed,
      colorComputed,
      tabIndexComputed,
      indentClassComputed,
      isExpandedComputed,
      expandedClassComputed,
      treeNodeClassComputed,
      cursorClassComputed
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/components/VaTreeNode/VaTreeNode.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaTreeNode.css";
var _hoisted_169 = ["role", "aria-expanded", "aria-disabled", "aria-checked", "tabindex"];
var _hoisted_234 = { class: "va-tree-node-root" };
var _hoisted_322 = {
  key: 2,
  class: "va-tree-node-content__item"
};
var _hoisted_413 = ["aria-hidden"];
function _sfc_render108(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_checkbox = resolveComponent("va-checkbox");
  const _component_va_tree_node = resolveComponent("va-tree-node", true);
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-tree-node", _ctx.treeNodeClassComputed]),
    role: _ctx.roleComputed,
    "aria-expanded": _ctx.isExpandedComputed,
    "aria-disabled": _ctx.$props.node.disabled,
    "aria-checked": !!_ctx.$props.node.checked,
    tabindex: _ctx.tabIndexComputed,
    onKeydown: [
      _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.handleKeyboardNavigation($event, _ctx.$props.node), ["stop", "prevent"]), ["up"])),
      _cache[5] || (_cache[5] = withKeys(withModifiers(($event) => _ctx.handleKeyboardNavigation($event, _ctx.$props.node), ["stop", "prevent"]), ["right"])),
      _cache[6] || (_cache[6] = withKeys(withModifiers(($event) => _ctx.handleKeyboardNavigation($event, _ctx.$props.node), ["stop", "prevent"]), ["down"])),
      _cache[7] || (_cache[7] = withKeys(withModifiers(($event) => _ctx.handleKeyboardNavigation($event, _ctx.$props.node), ["stop", "prevent"]), ["left"])),
      _cache[8] || (_cache[8] = withKeys(withModifiers(($event) => _ctx.handleKeyboardNavigation($event, _ctx.$props.node), ["stop", "prevent"]), ["space"])),
      _cache[9] || (_cache[9] = withKeys(withModifiers(($event) => _ctx.handleKeyboardNavigation($event, _ctx.$props.node), ["stop", "prevent"]), ["esc"]))
    ]
  }, [
    createBaseVNode("div", _hoisted_234, [
      createBaseVNode("div", {
        class: normalizeClass(["va-tree-node-content", _ctx.indentClassComputed]),
        onClick: _cache[3] || (_cache[3] = ($event) => _ctx.onNodeClick("node"))
      }, [
        _ctx.$props.node.hasChildren ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "va-tree-node-content__item va-tree-node-content__item--leaf",
          onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.onNodeClick("leaf"), ["stop"]))
        }, [
          renderSlot(_ctx.$slots, "icon-toggle", normalizeProps(guardReactiveProps(_ctx.$props.node)), () => [
            createVNode(_component_va_icon, {
              name: _ctx.isExpandedComputed ? "keyboard_arrow_down" : "keyboard_arrow_right",
              size: "20px"
            }, null, 8, ["name"])
          ])
        ])) : createCommentVNode("", true),
        _ctx.selectable ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: "va-tree-node-content__item",
          onClick: _cache[2] || (_cache[2] = withModifiers(() => {
          }, ["stop"]))
        }, [
          renderSlot(_ctx.$slots, "checkbox", normalizeProps(guardReactiveProps(_ctx.$props.node)), () => [
            createVNode(_component_va_checkbox, {
              "model-value": _ctx.$props.node.checked,
              color: _ctx.colorComputed,
              indeterminate: "",
              "onUpdate:modelValue": _cache[1] || (_cache[1] = (v2) => _ctx.toggleCheckbox(_ctx.$props.node, v2)),
              class: "va-tree-node__checkbox"
            }, null, 8, ["model-value", "color"])
          ])
        ])) : createCommentVNode("", true),
        _ctx.iconComputed ? (openBlock(), createElementBlock("div", _hoisted_322, [
          renderSlot(_ctx.$slots, "icon", normalizeProps(guardReactiveProps(_ctx.$props.node)), () => [
            createVNode(_component_va_icon, {
              name: _ctx.iconComputed,
              size: "small"
            }, null, 8, ["name"])
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass(["va-tree-node-content__body", _ctx.cursorClassComputed])
        }, [
          renderSlot(_ctx.$slots, "content", normalizeProps(guardReactiveProps(_ctx.$props.node)), () => [
            createTextVNode(toDisplayString(_ctx.labelComputed), 1)
          ])
        ], 2)
      ], 2)
    ]),
    withDirectives(createBaseVNode("div", {
      "aria-hidden": !_ctx.$props.node.expanded,
      class: normalizeClass(["va-tree-node-children", _ctx.expandedClassComputed])
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.node.children, (childNode) => {
        return openBlock(), createBlock(_component_va_tree_node, {
          key: _ctx.getTrackBy(childNode),
          node: childNode
        }, createSlots({ _: 2 }, [
          renderList(_ctx.$slots, (_2, name) => {
            return {
              name,
              fn: withCtx((slotScope) => [
                renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
              ])
            };
          })
        ]), 1032, ["node"]);
      }), 128))
    ], 10, _hoisted_413), [
      [vShow, _ctx.$props.node.hasChildren]
    ])
  ], 42, _hoisted_169);
}
var _VaTreeNode = _export_sfc(_sfc_main114, [["render", _sfc_render108]]);

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/components/VaTreeNode/index.js
var VaTreeNode = withConfigTransport$1(_VaTreeNode);

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/VaTreeView.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaTreeView.css";
var _sfc_main115 = defineComponent({
  name: "VaTreeView",
  props: { ...useTreeViewProps },
  emits: [...useTreeViewEmits],
  components: { VaTreeNode },
  setup: (props2, { emit }) => {
    const { treeItems, getTrackBy } = useTreeView$1(props2, emit);
    return { treeItems, getTrackBy };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/VaTreeView.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaTreeView.css";
var _hoisted_170 = {
  class: "va-tree-view",
  role: "tree"
};
function _sfc_render109(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_tree_node = resolveComponent("va-tree-node");
  return openBlock(), createElementBlock("div", _hoisted_170, [
    _ctx.$props.filter && !_ctx.treeItems.length ? renderSlot(_ctx.$slots, "not-found", { key: 0 }, () => [
      createTextVNode("No matching nodes found")
    ]) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.treeItems, (nodeItem) => {
      return openBlock(), createBlock(_component_va_tree_node, {
        key: _ctx.getTrackBy(nodeItem),
        node: nodeItem
      }, createSlots({ _: 2 }, [
        renderList(_ctx.$slots, (_2, name) => {
          return {
            name,
            fn: withCtx((slotScope) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
            ])
          };
        })
      ]), 1032, ["node"]);
    }), 128))
  ]);
}
var _VaTreeView = _export_sfc(_sfc_main115, [["render", _sfc_render109]]);

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/index.js
var VaTreeView = withConfigTransport$1(_VaTreeView);

// node_modules/vuestic-ui/dist/es/src/components/va-scroll-container/VaScrollContainer.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaScrollContainer.css";
var _sfc_main116 = defineComponent({
  name: "VaScrollContainer",
  props: {
    ...useSizeProps,
    vertical: { type: Boolean, default: false },
    horizontal: { type: Boolean, default: false },
    color: { type: String, default: "secondary" },
    rtl: { type: Boolean, default: false },
    gradient: { type: Boolean, default: false },
    sizesConfig: {
      type: Object,
      default: () => ({
        defaultSize: 4,
        sizes: { small: 4, medium: 6, large: 8 }
      })
    },
    size: {
      type: String,
      default: "small",
      validator: (v2) => ["small", "medium", "large"].includes(v2)
    }
  },
  setup(props2) {
    const { getColor } = useColors();
    const { sizeComputed } = useSize(props2);
    return {
      overflowX: computed(() => props2.horizontal ? "auto" : "hidden"),
      overflowY: computed(() => props2.vertical ? "auto" : "hidden"),
      scrollColor: computed(() => {
        const color = getColor(props2.color);
        return props2.gradient ? `linear-gradient(0deg, var(--va-scroll-container-scrollbar-gradient-to) 0%, ${color} 100%)` : color;
      }),
      scrollbarSize: computed(() => sizeComputed.value),
      scrollbarPosition: computed(() => props2.rtl ? "rtl" : "ltr")
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-scroll-container/VaScrollContainer.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaScrollContainer.css";
var _hoisted_171 = { class: "va-scroll-container__content" };
function _sfc_render110(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "va-scroll-container",
    style: normalizeStyle(`--va-scroll-color: ${String(_ctx.scrollColor)};--va-scrollbar-size: ${String(_ctx.scrollbarSize)};--va-overflow-x: ${String(_ctx.overflowX)};--va-overflow-y: ${String(_ctx.overflowY)};--va-scrollbar-position: ${String(_ctx.scrollbarPosition)}`)
  }, [
    createBaseVNode("div", _hoisted_171, [
      renderSlot(_ctx.$slots, "default")
    ])
  ], 4);
}
var _VaScrollContainer = _export_sfc(_sfc_main116, [["render", _sfc_render110]]);

// node_modules/vuestic-ui/dist/es/src/components/va-scroll-container/index.js
var VaScrollContainer = withConfigTransport$1(_VaScrollContainer);

// node_modules/vuestic-ui/dist/es/src/components/va-viewer/VaViewer.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaViewer.css";
var _sfc_main117 = defineComponent({
  name: "VaViewer",
  inheritAttrs: false,
  components: { VaIcon },
  setup(_2, { slots }) {
    const content = ref();
    const controls = ref();
    const isMounted = useIsMounted();
    const isClosed = ref(true);
    const isOpened = computed(() => isMounted.value && !isClosed.value);
    const openViewer = () => isClosed.value = false;
    const closeViewer = () => isClosed.value = true;
    const handleAnchorClick = () => {
      if (!slots.anchor) {
        openViewer();
      }
    };
    useClickOutside([content, controls], closeViewer);
    const document2 = useDocument();
    const teleportTarget = computed(() => {
      var _a2;
      return (_a2 = document2.value) == null ? void 0 : _a2.body;
    });
    return {
      content,
      controls,
      teleportTarget,
      isOpened,
      openViewer,
      closeViewer,
      handleAnchorClick
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-viewer/VaViewer.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaViewer.css";
var _hoisted_172 = { class: "va-viewer-content" };
var _hoisted_235 = {
  ref: "content",
  class: "va-viewer-content__main-area"
};
var _hoisted_323 = {
  ref: "controls",
  class: "va-viewer-content__controls-panel"
};
function _sfc_render111(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock(Fragment, null, [
    createBaseVNode("div", mergeProps({ class: "va-viewer" }, _ctx.$attrs, {
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleAnchorClick && _ctx.handleAnchorClick(...args))
    }), [
      renderSlot(_ctx.$slots, "anchor", normalizeProps(guardReactiveProps({ openViewer: _ctx.openViewer }))),
      !_ctx.$slots.anchor ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("", true)
    ], 16),
    _ctx.isOpened ? (openBlock(), createBlock(Teleport, {
      key: 0,
      to: _ctx.teleportTarget
    }, [
      createBaseVNode("div", _hoisted_172, [
        createBaseVNode("div", _hoisted_235, [
          !_ctx.$slots.image ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "image")
        ], 512),
        createBaseVNode("div", _hoisted_323, [
          renderSlot(_ctx.$slots, "controls"),
          renderSlot(_ctx.$slots, "close", normalizeProps(guardReactiveProps({ close: _ctx.closeViewer })), () => [
            createBaseVNode("button", {
              class: "va-viewer-content__close-button",
              onClick: _cache[1] || (_cache[1] = (...args) => _ctx.closeViewer && _ctx.closeViewer(...args))
            }, [
              createVNode(_component_va_icon, {
                name: "close",
                color: "backgroundPrimary"
              })
            ])
          ])
        ], 512)
      ])
    ], 8, ["to"])) : createCommentVNode("", true)
  ], 64);
}
var _VaViewer = _export_sfc(_sfc_main117, [["render", _sfc_render111]]);

// node_modules/vuestic-ui/dist/es/src/components/va-viewer/index.js
var VaViewer = withConfigTransport$1(_VaViewer);

// node_modules/vuestic-ui/dist/es/src/components/va-value/VaValue.vue_vue_type_script_lang.js
var _sfc_main118 = defineComponent({
  name: "VaValue",
  props: {
    defaultValue: { type: null, required: false, default: false }
  },
  setup(props2, { slots }) {
    const value = ref(props2.defaultValue);
    const slotBind = new Proxy(value, {
      get(target, prop) {
        if (prop === "value") {
          return target.value;
        }
        return target[prop];
      },
      set(target, prop, value2) {
        if (prop === "value") {
          target.value = value2;
        }
        return true;
      }
    });
    return () => {
      return h(Fragment, [renderSlotNodes(slots.default, slotBind)]);
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-value/index.js
var VaValue = withConfigTransport$1(_sfc_main118);

// node_modules/vuestic-ui/dist/es/src/components/va-textarea/VaTextarea.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaTextarea.css";
var positiveNumberValidator = (val) => {
  if (val > 0 && (val | 0) === val) {
    return true;
  }
  throw new Error(`\`minRows|maxRows\` must be a positive integer greater than 0, but ${val} is provided`);
};
var { createEmits: createEmits2, createListeners: createListeners2 } = useEmitProxy([
  "input",
  "change",
  "click",
  "update:modelValue"
]);
var VaInputWrapperProps6 = extractComponentProps(VaInputWrapper);
var _sfc_main119 = defineComponent({
  name: "VaTextarea",
  components: { VaInputWrapper },
  props: {
    ...useFormFieldProps,
    ...VaInputWrapperProps6,
    ...useStatefulProps,
    ...useValidationProps,
    modelValue: { type: [String, Number], default: "" },
    placeholder: { type: String },
    autosize: { type: Boolean, default: false },
    minRows: {
      type: Number,
      default: 1,
      validator: positiveNumberValidator
    },
    maxRows: {
      type: Number,
      validator: positiveNumberValidator
    },
    resize: {
      type: Boolean,
      default: true
    },
    clearValue: {
      type: [String],
      default: ""
    }
  },
  emits: [...createEmits2(), ...useValidationEmits],
  setup(props2, { emit }) {
    const textarea = shallowRef();
    const { valueComputed } = useStateful(props2, emit, "modelValue", {
      defaultValue: ""
    });
    const focus = () => {
      focusElement(textarea.value);
    };
    const blur = () => {
      blurElement(textarea.value);
    };
    const reset = () => withoutValidation(() => {
      emit("update:modelValue", props2.clearValue);
      emit("clear");
      resetValidation();
    });
    const {
      computedError,
      computedErrorMessages,
      listeners: validationListeners,
      validationAriaAttributes,
      isLoading,
      resetValidation,
      withoutValidation
    } = useValidation(props2, emit, {
      value: valueComputed,
      focus,
      reset
    });
    const isResizable = computed(() => {
      return props2.resize && !props2.autosize;
    });
    const computedRowsCount = computed(() => {
      if (!props2.autosize) {
        return void 0;
      }
      const rows = valueComputed.value ? valueComputed.value.toString().split("\n").length : 1;
      if (!props2.maxRows) {
        return rows;
      }
      return Math.max(props2.minRows, Math.min(rows, props2.maxRows));
    });
    const computedStyle = computed(() => ({
      resize: isResizable.value ? void 0 : "none"
    }));
    const computedProps = computed(() => ({
      ...pick$1(props2, ["disabled", "readonly", "placeholder", "ariaLabel"])
    }));
    return {
      isResizable,
      validationListeners,
      validationAriaAttributes,
      computedError,
      computedErrorMessages,
      isLoading,
      computedRowsCount,
      valueComputed,
      vaInputWrapperProps: filterComponentProps(VaInputWrapperProps6),
      textarea,
      computedStyle,
      listeners: createListeners2(emit),
      computedProps,
      focus,
      blur
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-textarea/VaTextarea.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaTextarea.css";
var _hoisted_173 = ["rows", "loading", "ariaLabel"];
function _sfc_render112(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaInputWrapper = resolveComponent("VaInputWrapper");
  return openBlock(), createBlock(_component_VaInputWrapper, mergeProps({ class: "va-textarea" }, _ctx.vaInputWrapperProps, {
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages
  }), {
    default: withCtx(() => [
      createBaseVNode("div", {
        class: normalizeClass(["va-textarea__resize-wrapper", {
          "va-textarea__resize-wrapper--resizable": _ctx.isResizable
        }])
      }, [
        withDirectives(createBaseVNode("textarea", mergeProps({
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.valueComputed = $event)
        }, { ..._ctx.computedProps, ..._ctx.listeners, ..._ctx.validationAriaAttributes }, {
          style: _ctx.computedStyle,
          rows: _ctx.computedRowsCount,
          loading: _ctx.isLoading,
          ref: "textarea",
          ariaLabel: _ctx.$props.label,
          class: "va-textarea__textarea",
          onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.validationListeners.onFocus && _ctx.validationListeners.onFocus(...args)),
          onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.validationListeners.onBlur && _ctx.validationListeners.onBlur(...args))
        }), null, 16, _hoisted_173), [
          [vModelText, _ctx.valueComputed]
        ])
      ], 2)
    ]),
    _: 1
  }, 16, ["error", "error-messages"]);
}
var _VaTextarea = _export_sfc(_sfc_main119, [["render", _sfc_render112]]);

// node_modules/vuestic-ui/dist/es/src/components/va-textarea/index.js
var VaTextarea = withConfigTransport(_VaTextarea);

// node_modules/vuestic-ui/dist/es/src/components/va-menu-list/composables/useMenuKeyboardNavigation.js
var NON_DISABLED_MENU_ITEM_SELECTOR = '[role="menuitem"]:not([aria-disabled="true"])';
var FOCUSED_MENU_ITEM_SELECTOR = '[role="menuitem"]:focus';
var makeMenuItemAttributes = (options) => ({
  role: "menuitem",
  tabindex: -1,
  "aria-disabled": Boolean(options.disabled)
});
var makeMenuContainerAttributes = () => ({
  role: "menu",
  tabindex: 0
});
var useMenuKeyboardNavigation = (container) => {
  useEvent("keydown", ({ key }) => {
    if (!container.value) {
      return;
    }
    const items2 = container.value.querySelectorAll(NON_DISABLED_MENU_ITEM_SELECTOR);
    const focusedItem = container.value.querySelector(FOCUSED_MENU_ITEM_SELECTOR);
    if (!items2.length) {
      return;
    }
    if (!focusedItem) {
      const firstItem = container.value.querySelector(NON_DISABLED_MENU_ITEM_SELECTOR);
      if (firstItem) {
        focusElement(firstItem);
      }
      return;
    }
    if (key === "ArrowDown" || key === "ArrowRight") {
      const focusedElementIndex = Array.from(items2).indexOf(focusedItem);
      focusElement(items2[focusedElementIndex + 1]);
    }
    if (key === "ArrowUp" || key === "ArrowLeft") {
      const focusedElementIndex = Array.from(items2).indexOf(focusedItem);
      focusElement(items2[focusedElementIndex - 1]);
    }
  }, container);
};

// node_modules/vuestic-ui/dist/es/src/components/va-menu-list/components/VaMenuItem.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaMenuItem.css";
var _sfc_main120 = defineComponent({
  name: "VaMenuItem",
  components: { VaIcon },
  props: {
    name: { type: String, default: "" },
    icon: { type: String, defatult: "" },
    rightIcon: { type: String, defatult: "" },
    disabled: { type: Boolean, default: false }
  },
  emits: ["selected"],
  setup(props2) {
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocusGlobal();
    return {
      hasKeyboardFocus,
      keyboardFocusListeners,
      makeMenuItemAttributes
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-menu-list/components/VaMenuItem.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaMenuItem.css";
var _hoisted_174 = { class: "va-menu-item__cell va-menu-item__cell--left" };
var _hoisted_236 = { class: "va-menu-item__cell va-menu-item__cell--center" };
var _hoisted_324 = { class: "va-menu-item__content" };
var _hoisted_414 = { class: "va-menu-item__cell va-menu-item__cell--right" };
function _sfc_render113(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaIcon = resolveComponent("VaIcon");
  return openBlock(), createElementBlock("tr", mergeProps({ class: "va-menu-item" }, _ctx.makeMenuItemAttributes({ disabled: _ctx.disabled }), toHandlers(_ctx.keyboardFocusListeners, true), {
    class: {
      "va-menu-item--disabled": _ctx.disabled,
      "va-menu-item--keyboard-focus": _ctx.hasKeyboardFocus
    },
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("selected")),
    onKeydown: _cache[1] || (_cache[1] = withKeys(($event) => _ctx.$emit("selected"), ["enter", "space"]))
  }), [
    createBaseVNode("td", _hoisted_174, [
      renderSlot(_ctx.$slots, "left-icon", {}, () => [
        _ctx.icon ? (openBlock(), createBlock(_component_VaIcon, {
          key: 0,
          class: "va-menu-item__icon--left",
          name: _ctx.icon
        }, null, 8, ["name"])) : createCommentVNode("", true)
      ])
    ]),
    createBaseVNode("td", _hoisted_236, [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createBaseVNode("a", _hoisted_324, toDisplayString(_ctx.name), 1)
      ])
    ]),
    createBaseVNode("td", _hoisted_414, [
      renderSlot(_ctx.$slots, "right-icon", {}, () => [
        _ctx.rightIcon ? (openBlock(), createBlock(_component_VaIcon, {
          key: 0,
          class: "va-menu-item__icon--right",
          name: _ctx.rightIcon
        }, null, 8, ["name"])) : createCommentVNode("", true)
      ])
    ])
  ], 16);
}
var _VaMenuItem = _export_sfc(_sfc_main120, [["render", _sfc_render113]]);

// node_modules/vuestic-ui/dist/es/src/components/va-menu-list/components/VaMenuGroup.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaMenuGroup.css";
var _sfc_main121 = defineComponent({
  name: "VaMenuGroup",
  props: {
    groupName: {
      type: String,
      required: true
    },
    color: {
      type: String,
      default: "secondary"
    }
  },
  setup(props2) {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props2.color));
    return {
      colorComputed
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-menu-list/components/VaMenuGroup.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaMenuGroup.css";
var _hoisted_175 = { class: "va-menu-list__group-name" };
function _sfc_render114(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(Fragment, null, [
    createBaseVNode("div", {
      class: "va-menu-list__group-name-wrapper",
      colspan: "99999",
      style: normalizeStyle(`--va-color-computed: ${String(_ctx.colorComputed)}`)
    }, [
      createBaseVNode("span", _hoisted_175, toDisplayString(_ctx.groupName), 1)
    ], 4),
    renderSlot(_ctx.$slots, "default", {
      style: normalizeStyle(`--va-color-computed: ${String(_ctx.colorComputed)}`)
    }, void 0, true)
  ], 64);
}
var _VaMenuGroup = _export_sfc(_sfc_main121, [["render", _sfc_render114], ["__scopeId", "data-v-f8fafb35"]]);

// node_modules/vuestic-ui/dist/es/src/components/va-menu-list/VaMenuList.vue_vue_type_script_lang.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaMenuList.css";
var _sfc_main122 = defineComponent({
  name: "VaMenuList",
  components: { VaMenuItem: _VaMenuItem, VaMenuGroup: _VaMenuGroup },
  props: {
    ...useSelectableListProps,
    options: { type: Array, default: () => [] }
  },
  emits: ["selected"],
  setup(props2) {
    const container = ref();
    useMenuKeyboardNavigation(container);
    const { getText, getValue: getValue2, getDisabled, getGroupBy, getTrackBy } = useSelectableList(props2);
    const optionGroups = computed(() => props2.options.reduce((groups, option) => {
      const groupBy = getGroupBy(option);
      if (!groupBy) {
        groups._noGroup.push(option);
      } else {
        if (!groups[groupBy]) {
          groups[groupBy] = [];
        }
        groups[groupBy].push(option);
      }
      return groups;
    }, { _noGroup: [] }));
    const getUnSlottedVNodes = (nodes) => {
      if (Array.isArray(nodes) && nodes[0].type === Fragment) {
        return nodes[0].children;
      }
      return nodes;
    };
    const getVNodeComponentName = (node) => {
      if (typeof node.type === "object" && "name" in node.type && typeof node.type.name === "string") {
        return node.type.name;
      }
      return "";
    };
    const getVNodeKey = (node) => {
      if (typeof node.type === "string") {
        return node.type;
      }
      if (typeof node.type === "object" && "name" in node.type && typeof node.type.name === "string") {
        return node.type.name;
      }
      return String(node.key);
    };
    return {
      container,
      optionGroups,
      makeMenuContainerAttributes,
      getVNodeComponentName,
      getUnSlottedVNodes,
      getVNodeKey,
      getText,
      getValue: getValue2,
      getDisabled,
      getTrackBy
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-menu-list/VaMenuList.js
import "/Users/sophanna/Documents/All-Project-Done/computer-shop/computer_shop_vue/node_modules/vuestic-ui/dist/es/VaMenuList.css";
var _hoisted_176 = { colspan: "9999" };
function _sfc_render115(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaMenuGroup = resolveComponent("VaMenuGroup");
  const _component_VaMenuItem = resolveComponent("VaMenuItem");
  return openBlock(), createElementBlock("table", mergeProps({
    class: "va-menu-list",
    ref: "container"
  }, _ctx.makeMenuContainerAttributes()), [
    createBaseVNode("tbody", null, [
      _ctx.$slots.default ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.getUnSlottedVNodes(_ctx.$slots.default()), (child) => {
        return openBlock(), createElementBlock(Fragment, null, [
          _ctx.getVNodeComponentName(child) === "VaMenuItem" ? (openBlock(), createBlock(resolveDynamicComponent(child), {
            key: _ctx.getVNodeKey(child) + "menuitem"
          })) : _ctx.getVNodeComponentName(child) === "VaDropdown" ? (openBlock(), createBlock(resolveDynamicComponent(child), {
            key: _ctx.getVNodeKey(child) + "menu-dropdown"
          })) : (openBlock(), createElementBlock("td", {
            colspan: "999",
            key: _ctx.getVNodeKey(child),
            class: "va-menu-list__virtual-td"
          }, [
            (openBlock(), createBlock(resolveDynamicComponent(child)))
          ]))
        ], 64);
      }), 256)) : renderSlot(_ctx.$slots, "default", { key: 1 }, () => [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.optionGroups, (options, groupName) => {
          return openBlock(), createElementBlock(Fragment, { key: groupName }, [
            groupName !== "_noGroup" ? renderSlot(_ctx.$slots, "group", { key: 0 }, () => [
              createBaseVNode("tr", null, [
                createBaseVNode("td", _hoisted_176, [
                  createVNode(_component_VaMenuGroup, { "group-name": groupName }, null, 8, ["group-name"])
                ])
              ])
            ]) : createCommentVNode("", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(options, (option) => {
              return openBlock(), createBlock(_component_VaMenuItem, {
                key: _ctx.getTrackBy(option),
                name: _ctx.getText(option),
                icon: option.icon,
                "right-icon": option.rightIcon,
                disabled: _ctx.getDisabled(option),
                onSelected: ($event) => _ctx.$emit("selected", _ctx.getValue(option), option)
              }, {
                "left-icon": withCtx((bind) => [
                  renderSlot(_ctx.$slots, "left-icon", normalizeProps(guardReactiveProps(bind)))
                ]),
                "right-icon": withCtx((bind) => [
                  renderSlot(_ctx.$slots, "right-icon", normalizeProps(guardReactiveProps(bind)))
                ]),
                _: 2
              }, 1032, ["name", "icon", "right-icon", "disabled", "onSelected"]);
            }), 128))
          ], 64);
        }), 128))
      ])
    ])
  ], 16);
}
var _VaMenuList = _export_sfc(_sfc_main122, [["render", _sfc_render115]]);

// node_modules/vuestic-ui/dist/es/src/components/va-menu-list/index.js
var VaMenuList = withConfigTransport(_VaMenuList);
var VaMenuItem = withConfigTransport(_VaMenuItem);
var VaMenuGroup = withConfigTransport(_VaMenuGroup);

// node_modules/vuestic-ui/dist/es/src/composables/useImmediateFocus.js
var useImmediateFocus = (el) => {
  watchEffect(() => {
    if (el.value) {
      nextTick(() => {
        focusElement(unwrapEl(el.value));
      });
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-menu/VaMenu.vue_vue_type_script_lang.js
var VaMenuListProps = extractComponentProps(VaMenuList);
var VaMenuListEmits = extractComponentEmits(VaMenuList);
var VaDropdownProps4 = extractComponentProps(VaDropdown);
var VaDropdownEmits = extractComponentEmits(VaDropdown);
var _sfc_main123 = defineComponent({
  name: "VaMenu",
  components: { VaDropdown, VaDropdownContent, VaMenuList },
  props: {
    ...useComponentPresetProp,
    ...VaMenuListProps,
    ...VaDropdownProps4,
    stickToEdges: { type: Boolean, default: true }
  },
  emits: [
    ...VaDropdownEmits,
    ...VaMenuListEmits
  ],
  setup() {
    const menuList = ref();
    const dropdown = ref();
    useImmediateFocus(menuList);
    const close = () => {
      var _a2;
      (_a2 = dropdown.value) == null ? void 0 : _a2.hide();
      nextTick(() => {
        var _a22;
        const el = unwrapEl((_a22 = dropdown.value) == null ? void 0 : _a22.anchorRef);
        if (el) {
          focusFirstFocusableChild(el);
        }
      });
    };
    const onKeydown = (event) => {
      if (event.key === "Escape") {
        close();
      }
      if (event.key === "ArrowDown" || event.key === "ArrowUp") {
        event.preventDefault();
      }
    };
    return {
      onKeydown,
      dropdown,
      menuList,
      menuListProps: filterComponentProps(VaMenuListProps),
      dropdownProps: filterComponentProps(VaDropdownProps4),
      close
    };
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-menu/VaMenu.js
function _sfc_render116(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaMenuList = resolveComponent("VaMenuList");
  const _component_VaDropdownContent = resolveComponent("VaDropdownContent");
  const _component_VaDropdown = resolveComponent("VaDropdown");
  return openBlock(), createBlock(_component_VaDropdown, mergeProps(_ctx.dropdownProps, { ref: "dropdown" }), {
    anchor: withCtx(() => [
      renderSlot(_ctx.$slots, "anchor")
    ]),
    default: withCtx(() => [
      createVNode(_component_VaDropdownContent, { onKeydown: _ctx.onKeydown }, {
        default: withCtx(() => [
          createVNode(_component_VaMenuList, mergeProps({
            onKeydown: _cache[0] || (_cache[0] = withKeys(withModifiers(() => {
            }, ["prevent", "stop"]), ["enter", "space"]))
          }, _ctx.menuListProps, {
            ref: "menuList",
            onSelected: _cache[1] || (_cache[1] = ($event) => {
              _ctx.$emit("selected", $event);
              _ctx.close();
            })
          }), createSlots({ _: 2 }, [
            _ctx.$slots.default ? {
              name: "default",
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              key: "0"
            } : void 0
          ]), 1040)
        ]),
        _: 3
      }, 8, ["onKeydown"])
    ]),
    _: 3
  }, 16);
}
var _VaMenu = _export_sfc(_sfc_main123, [["render", _sfc_render116]]);

// node_modules/vuestic-ui/dist/es/src/components/va-menu/va-menu.js
var VaMenu = withConfigTransport(_VaMenu);

// node_modules/vuestic-ui/dist/es/src/services/vue-plugin/components.js
var vuesticComponents = Object.freeze(Object.defineProperty({
  __proto__: null,
  VaAccordion,
  VaAffix,
  VaAlert,
  VaAppBar,
  VaAspectRatio,
  VaAvatar,
  VaAvatarGroup,
  VaBacktop,
  VaBadge,
  VaBreadcrumbs,
  VaBreadcrumbsItem,
  VaButton,
  VaButtonDropdown,
  VaButtonGroup,
  VaButtonToggle,
  VaCard,
  VaCardActions,
  VaCardBlock,
  VaCardContent,
  VaCardTitle,
  VaCarousel,
  VaCheckbox,
  VaChip,
  VaCollapse,
  VaColorIndicator,
  VaColorInput,
  VaColorPalette,
  VaConfig,
  VaContent,
  VaCounter,
  VaDataTable,
  VaDateInput,
  VaDatePicker,
  VaDivider,
  VaDropdown,
  VaDropdownContent,
  VaFallback,
  VaFileUpload,
  VaForm,
  VaHover,
  VaIcon,
  VaImage,
  VaInfiniteScroll,
  VaInnerLoading,
  VaInput,
  VaInputWrapper,
  VaLayout,
  VaList,
  VaListItem,
  VaListItemLabel,
  VaListItemSection,
  VaListLabel,
  VaListSeparator,
  VaMenu,
  VaMenuGroup,
  VaMenuItem,
  VaMenuList,
  VaMessageList,
  VaModal,
  VaNavbar,
  VaNavbarItem,
  VaOptionList,
  VaPagination,
  VaParallax,
  VaPopover,
  VaProgressBar,
  VaProgressCircle,
  VaRadio,
  VaRating,
  VaScrollContainer,
  VaSelect,
  VaSeparator,
  VaSidebar,
  VaSidebarItem,
  VaSidebarItemContent,
  VaSidebarItemTitle,
  VaSkeleton,
  VaSkeletonGroup,
  VaSlider,
  VaSpacer,
  VaSplit,
  VaStepper,
  VaSwitch,
  VaTab,
  VaTabs,
  VaTextarea,
  VaTimeInput,
  VaTimePicker,
  VaTimeline,
  VaTimelineItem,
  VaToast,
  VaTreeView,
  VaValue,
  VaViewer,
  VaVirtualScroller
}, Symbol.toStringTag, { value: "Module" }));

// node_modules/vuestic-ui/dist/es/src/services/vue-plugin/utils/use-plugin.js
var isPluginFabric = (plugin) => typeof plugin === "function";
var usePlugin = (app, plugin, ...options) => {
  if (isPluginFabric(plugin)) {
    app.use(plugin(...options));
  } else {
    app.use(plugin);
  }
};

// node_modules/vuestic-ui/dist/es/src/services/vue-plugin/create-vuestic/create-vuestic.js
var createVuestic = defineVuesticPlugin((options = {}) => ({
  install(app) {
    const { config } = options;
    setCurrentApp(app);
    Object.entries(vuesticComponents).forEach(([name, component]) => {
      app.component(name, component);
    });
    usePlugin(app, GlobalConfigPlugin(config));
    usePlugin(app, CachePlugin);
    usePlugin(app, ColorConfigPlugin(config));
    usePlugin(app, ColorsClassesPlugin);
    usePlugin(app, BreakpointConfigPlugin);
    usePlugin(app, VaDropdownPlugin);
    usePlugin(app, VaToastPlugin);
    usePlugin(app, VaModalPlugin);
    setCurrentApp(null);
  }
}));

// node_modules/vuestic-ui/dist/es/src/services/vue-plugin/create-vuestic/create-vuestic-essential.js
var ESSENTIAL_PLUGIN_NAMES = ["GlobalConfigPlugin", "ColorConfigPlugin"];
var createVuesticEssential = defineVuesticPlugin((options = {}) => ({
  install(app) {
    const { config, components, plugins } = options;
    setCurrentApp(app);
    usePlugin(app, (plugins == null ? void 0 : plugins.GlobalConfigPlugin) || GlobalConfigPlugin, config);
    usePlugin(app, (plugins == null ? void 0 : plugins.CachePlugin) || CachePlugin);
    usePlugin(app, (plugins == null ? void 0 : plugins.ColorConfigPlugin) || ColorConfigPlugin, config);
    if (plugins) {
      Object.entries(plugins).forEach(([name, plugin]) => {
        if (ESSENTIAL_PLUGIN_NAMES.includes(name)) {
          return;
        }
        usePlugin(app, plugin);
      });
    }
    if (components) {
      Object.entries(components).forEach(([name, component]) => {
        app.component(name, component);
      });
    }
    setCurrentApp(null);
  }
}));

// node_modules/vuestic-ui/dist/es/src/services/web-components/register-vuestic-web-components-essential.js
var componentsOrder = [
  "VaConfig",
  // VaConfig should be registered before any component, because it provides them config
  "VaForm",
  // VaForm registered before any component, but not before VaConfig
  "VaAccordion",
  "VaFileUpload",
  "VaSidebar",
  "VaTabs"
];
var registerVuesticWebComponentsEssential = (options) => {
  const { css, components } = options;
  Object.entries(components).sort(([nameA], [nameB]) => {
    if (!componentsOrder.includes(nameA) && !componentsOrder.includes(nameB)) {
      return 0;
    }
    let indexA = componentsOrder.indexOf(nameA);
    let indexB = componentsOrder.indexOf(nameB);
    if (indexA === -1) {
      indexA = Number.MAX_SAFE_INTEGER;
    }
    if (indexB === -1) {
      indexB = Number.MAX_SAFE_INTEGER;
    }
    return indexA - indexB;
  }).forEach(([name, component]) => {
    const customElement = defineCustomElement(component);
    if (css && "styles" in component) {
      component.styles.push(css);
    }
    customElements.define(`${kebabCase$1(name)}`, customElement);
  });
};

// node_modules/vuestic-ui/dist/es/src/services/web-components/register-vuestic-web-components.js
var defaultCSS = `
.material-icons {
  font-family: 'Material Icons';
  font-weight: normal;
  font-style: normal;
  line-height: 1;
  letter-spacing: normal;
  text-transform: none;
  display: inline-block;
  white-space: nowrap;
  word-wrap: normal;
  direction: ltr;
  -webkit-font-smoothing: antialiased;
}`;
var registerVuesticWebComponents = (options = {}) => {
  const { css = defaultCSS } = options;
  registerVuesticWebComponentsEssential({
    css,
    components: vuesticComponents
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/fabrics.js
var defineVaDataTableColumns = (columns) => columns;
var defineVaDataTableItems = (items2) => items2;

// node_modules/vuestic-ui/dist/es/src/components/va-modal/hooks/useModal.js
var useModal = () => {
  var _a2;
  const appContext = (_a2 = getCurrentInstance()) == null ? void 0 : _a2.appContext;
  if (!appContext) {
    throw new Error("useModal can be used only in setup function. You can use app.config.globalProperties.$vaModal outside setup function");
  }
  const init = (options) => {
    return createModalInstance(options, appContext);
  };
  const confirm = (options) => {
    if (typeof options === "string") {
      return new Promise((resolve, reject) => {
        createModalInstance({
          message: options,
          onOk() {
            resolve(true);
          },
          onCancel() {
            resolve(false);
          }
        }, appContext);
      });
    }
    return new Promise((resolve, reject) => {
      createModalInstance({
        ...options,
        onOk() {
          var _a22;
          (_a22 = options == null ? void 0 : options.onOk) == null ? void 0 : _a22.call(options);
          resolve(true);
        },
        onCancel() {
          var _a22;
          (_a22 = options == null ? void 0 : options.onCancel) == null ? void 0 : _a22.call(options);
          resolve(false);
        }
      }, appContext);
    });
  };
  return { init, confirm };
};

// node_modules/vuestic-ui/dist/es/src/components/va-rating/components/VaRatingItem/index.js
var VaRatingItem = withConfigTransport$1(_VaRatingItem);

// node_modules/vuestic-ui/dist/es/src/composables/useAppContext.js
var useAppContext = () => {
  const currentInstance = getCurrentInstance();
  return computed(() => {
    var _a2;
    return ((_a2 = getCurrentApp()) == null ? void 0 : _a2._context) || (currentInstance == null ? void 0 : currentInstance.appContext);
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-toast/hooks/useToast.js
var useToast = () => {
  const appContext = useAppContext();
  const createdInThisSetupContext = [];
  const notify = (options) => {
    const id = createToastInstance(options, appContext.value);
    if (id) {
      createdInThisSetupContext.push(id);
    }
    return id;
  };
  const init = (options) => {
    return notify(options);
  };
  const close = (id) => closeById(id);
  const closeAll = (allApps = false) => closeAllNotifications(allApps ? void 0 : appContext.value);
  const closeAllCreatedInThisHook = () => {
    createdInThisSetupContext.forEach((id) => closeById(id));
  };
  return {
    init,
    notify,
    close,
    closeAll,
    closeAllCreatedInThisHook
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useMount.js
var destroy3 = (el, vNode) => {
  if (el) {
    render(null, el);
    el.remove();
  }
  el = null;
};
var mount3 = (component, { props: props2, appContext } = {}) => {
  const el = document == null ? void 0 : document.createElement("div");
  document.body.appendChild(el);
  const vNode = h(component, {
    ...props2,
    stateful: (props2 == null ? void 0 : props2.stateful) ?? true
  });
  if (appContext) {
    vNode.appContext = appContext;
  }
  if (el) {
    render(vNode, el);
  }
  return { vNode, el };
};
var useMount = (component) => {
  var _a2;
  const appContext = (_a2 = getCurrentInstance()) == null ? void 0 : _a2.appContext;
  if (!appContext) {
    throw new Error("useMount can be used only in setup function");
  }
  const createInstance2 = (props2) => {
    const { vNode, el } = mount3(component, { props: props2, appContext });
    return () => {
      nextTick(() => {
        destroy3(el);
      });
    };
  };
  return {
    createInstance: createInstance2
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-menu/hooks/useMenu.js
var useMenu = () => {
  const { createInstance: createInstance2 } = useMount(VaMenu);
  const instances = [];
  const destroyAll = () => instances.forEach((destroy4) => destroy4());
  const show = (props2) => {
    destroyAll();
    props2.event.preventDefault();
    const destroy4 = createInstance2({
      ...props2,
      anchor: props2.event.target,
      cursor: {
        getBoundingClientRect() {
          const resX = props2.event.clientX;
          const resY = props2.event.clientY;
          return {
            width: 0,
            height: 0,
            x: resX,
            y: resY,
            top: resY,
            right: resX,
            bottom: resY,
            left: resX
          };
        },
        contextElement: props2.event.target
      },
      stateful: true,
      modelValue: true,
      preset: "context",
      onBeforeUnmount: () => {
        destroy4();
      }
    });
    instances.push(destroy4);
    return () => {
      destroy4();
      instances.splice(instances.indexOf(destroy4), 1);
    };
  };
  onBeforeUnmount(destroyAll);
  return {
    show
  };
};
export {
  BreakpointConfigPlugin,
  CachePlugin,
  ColorConfigPlugin,
  ColorsClassesPlugin,
  GlobalConfigPlugin,
  TabsViewKey,
  VaAccordion,
  VaAffix,
  VaAlert,
  VaAppBar,
  VaAspectRatio,
  VaAvatar,
  VaAvatarGroup,
  VaBacktop,
  VaBadge,
  VaBreadcrumbs,
  VaBreadcrumbsItem,
  VaButton,
  VaButtonDropdown,
  VaButtonGroup,
  VaButtonToggle,
  VaCard,
  VaCardActions,
  VaCardBlock,
  VaCardContent,
  VaCardTitle,
  VaCarousel,
  VaCheckbox,
  VaChip,
  VaCollapse,
  VaColorIndicator,
  VaColorInput,
  VaColorPalette,
  VaConfig,
  VaContent,
  VaCounter,
  VaDataTable,
  VaDateInput,
  VaDatePicker,
  VaDivider,
  VaDropdown,
  VaDropdownContent,
  VaDropdownPlugin,
  VaFallback,
  VaFileUpload,
  VaFileUploadGalleryItem,
  VaFileUploadKey,
  VaFileUploadList,
  VaFileUploadListItem,
  VaFileUploadSingleItem,
  VaFileUploadUndo,
  VaForm,
  VaHover,
  VaIcon,
  VaImage,
  VaInfiniteScroll,
  VaInnerLoading,
  VaInput,
  VaInputWrapper,
  VaLayout,
  VaList,
  VaListItem,
  VaListItemLabel,
  VaListItemSection,
  VaListLabel,
  VaListSeparator,
  VaMenu,
  VaMenuGroup,
  VaMenuItem,
  VaMenuList,
  VaMessageList,
  VaMessageListWrapper,
  VaModal,
  VaModalPlugin,
  VaNavbar,
  VaNavbarItem,
  VaOptionList,
  VaPagination,
  VaParallax,
  VaPopover,
  VaProgressBar,
  VaProgressCircle,
  VaRadio,
  VaRating,
  VaRatingItem,
  VaScrollContainer,
  VaSelect,
  VaSelectOption,
  VaSelectOptionList,
  VaSeparator,
  VaSidebar,
  VaSidebarItem,
  VaSidebarItemContent,
  VaSidebarItemTitle,
  VaSkeleton,
  VaSkeletonGroup,
  VaSlider,
  VaSpacer,
  VaSplit,
  VaStepper,
  VaSwitch,
  VaTab,
  VaTabs,
  VaTextarea,
  VaTimeInput,
  VaTimePicker,
  VaTimeline,
  VaTimelineItem,
  VaTimelineSeparator,
  VaToast,
  VaToastPlugin,
  VaTreeView,
  VaValue,
  VaViewer,
  VaVirtualScroller,
  VuesticIconAliases,
  VuesticIconFonts,
  presets as colorsPreset,
  createIconsConfig,
  createVuestic,
  createVuesticEssential,
  defineVaDataTableColumns,
  defineVaDataTableItems,
  defineVaStepperSteps,
  defineVuesticConfig,
  registerVuesticWebComponents,
  registerVuesticWebComponentsEssential,
  defaultThresholds as thresholdsPreset,
  useBreakpoint,
  useColors,
  useElementTextColor,
  useForm,
  useGlobalConfig,
  useI18nConfig,
  useIcon as useIcons,
  useMenu,
  useModal,
  useToast
};
//# sourceMappingURL=vuestic-ui.js.map
