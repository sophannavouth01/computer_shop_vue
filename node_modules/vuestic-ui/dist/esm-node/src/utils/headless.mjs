import { Comment, h, Text, Suspense, Teleport, Fragment } from "vue";
const toNode = (v, attrs) => {
  if (!v) {
    return null;
  }
  if (!("type" in v) || v.type === Text || typeof v === "string") {
    return h("div", attrs, v);
  }
  if (v.type === Comment) {
    return v;
  }
  if ("$el" in v) {
    return toNode(v.$el, attrs);
  }
  if (v.type === Suspense) {
    return h(v.ssContent, attrs);
  }
  if (v.type === Teleport) {
    if (v.children === null) {
      return v;
    }
    const anchor = toNode(v.children[0], attrs);
    if (anchor) {
      v.children[0] = h(anchor, attrs);
    }
    return v;
  }
  if (v.type === Fragment) {
    if (v.children === null) {
      return v;
    }
    if (v.children.length === 1) {
      return h(Fragment, v.props, [toNode(v.children[0], attrs)]);
    }
    return h("div", attrs, v);
  }
  if (typeof v.type.render === "function") {
    const component = h(v);
    if (Array.isArray(component.children) && component.children.length > 1) {
      return h("div", attrs, component.children);
    }
  }
  return h(v, attrs);
};
const renderSlotNode = (slot, slotBind = {}, nodeAttributes = {}) => {
  const children = slot == null ? void 0 : slot(slotBind);
  if (!children) {
    return null;
  }
  const nonCommentChildren = children.filter((v) => v.type !== Comment);
  if (nonCommentChildren.length === 0) {
    return null;
  }
  if (nonCommentChildren.length === 1) {
    return toNode(nonCommentChildren[0], nodeAttributes);
  }
  return h("div", nodeAttributes, children);
};
const renderSlotNodes = (slot, slotBind = {}, nodeAttributes = {}) => {
  const children = slot == null ? void 0 : slot(slotBind);
  if (!children) {
    return null;
  }
  return children.map((v) => toNode(v, nodeAttributes));
};
export {
  renderSlotNode as a,
  renderSlotNodes as r
};
//# sourceMappingURL=headless.mjs.map
