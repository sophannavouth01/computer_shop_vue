import { getCurrentInstance, computed, shallowReadonly, normalizeClass, normalizeStyle } from "vue";
import { u as useComponentConfigProps } from "../component-config/utils/use-component-config-props.mjs";
import { o as omit } from "../../../vendor.mjs";
const toCamelCase = (str) => str.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
const findCamelCased = (obj, key) => {
  const found = Object.keys(obj).find((k) => toCamelCase(k) === key);
  return found && obj[found];
};
const createPropsWithCustomConfig = (instance, propsFromConfig) => {
  const instanceProps = instance.props;
  return new Proxy(instanceProps, {
    get: (target, key) => {
      var _a;
      if (typeof key !== "string") {
        return target[key];
      }
      const incomingProps = instance.vnode.props || {};
      const originalProp = target[key];
      const propFromConfig = (_a = propsFromConfig.value) == null ? void 0 : _a[key];
      const incomingProp = findCamelCased(incomingProps, key);
      if (incomingProp !== void 0) {
        return originalProp;
      }
      if (propFromConfig !== void 0) {
        return propFromConfig;
      }
      return originalProp;
    }
  });
};
const createAttrsWithCustomConfig = (instance, propsFromConfig) => {
  const instanceAttrs = instance.attrs;
  return new Proxy(instanceAttrs, {
    get: (target, key) => {
      var _a;
      if (typeof key !== "string") {
        return target[key];
      }
      if (key === "class") {
        return normalizeClass([propsFromConfig.value.class, instanceAttrs.class]);
      }
      if (key === "style") {
        return normalizeStyle([propsFromConfig.value.style, instanceAttrs.style]);
      }
      const attrFromConfig = (_a = propsFromConfig.value) == null ? void 0 : _a[key];
      if (attrFromConfig !== void 0) {
        return attrFromConfig;
      }
      return target[key];
    },
    ownKeys(target) {
      return [.../* @__PURE__ */ new Set([...Object.keys(instanceAttrs), ...Object.keys(propsFromConfig.value)])];
    },
    getOwnPropertyDescriptor(target, key) {
      return Reflect.getOwnPropertyDescriptor(propsFromConfig.value, key) ?? Reflect.getOwnPropertyDescriptor(instanceAttrs, key);
    }
  });
};
const createProxyComponent = (component) => {
  const customSetup = (originalProps, ctx) => {
    var _a;
    const instance = getCurrentInstance();
    const propsFromConfig = useComponentConfigProps(component, originalProps);
    const attrsFromConfig = computed(() => {
      return omit(propsFromConfig.value, Object.keys(originalProps));
    });
    const props = createPropsWithCustomConfig(instance, propsFromConfig);
    const attrs = createAttrsWithCustomConfig(instance, attrsFromConfig);
    instance.props = props;
    instance.attrs = attrs;
    return (_a = component.setup) == null ? void 0 : _a.call(component, shallowReadonly(props), {
      ...ctx,
      attrs
    });
  };
  return new Proxy(component, {
    get(target, key) {
      if (key === "setup") {
        return customSetup;
      }
      return target[key];
    }
  });
};
export {
  createProxyComponent as c
};
//# sourceMappingURL=createProxyComponent.mjs.map
