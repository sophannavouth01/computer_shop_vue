import { defineComponent, computed, ref, toRef, watchEffect, h, Teleport, Fragment, nextTick } from "vue";
import { p as pick, k as kebabCase } from "../../../vendor.mjs";
import { a as renderSlotNode } from "../../utils/headless.mjs";
import { u as useMouseNavigation, a as useKeyboardNavigation } from "./hooks/useDropdownNavigation.mjs";
import { u as useAnchorSelector } from "./hooks/useAnchorSelector.mjs";
import { u as useCursorAnchor } from "./hooks/useCursorAnchor.mjs";
import { u as useDropdown } from "./hooks/useDropdown.mjs";
import { w as warn } from "../../utils/console.mjs";
import { u as useFocusOutside } from "../../composables/useFocusOutside.mjs";
import { u as useTeleported } from "../../composables/useTeleported.mjs";
import { u as useZIndex } from "../../composables/useZIndex.mjs";
import { a as usePlacementAliasesProps } from "../../composables/usePlacementAliases.mjs";
import { c as createStatefulProps, u as useStatefulEmits, b as useStateful } from "../../composables/useStateful.mjs";
import { u as useHTMLElementSelector } from "../../composables/useHTMLElementSelector.mjs";
import { u as useBem } from "../../composables/useBem.mjs";
import { u as useDebounceFn } from "../../composables/useDebounce.mjs";
import { u as useClickOutside } from "../../composables/useClickOutside.mjs";
import { u as useTranslation } from "../../composables/useTranslation.mjs";
import { u as useIsMounted } from "../../composables/useIsMounted.mjs";
import { u as useHTMLElement } from "../../composables/useHTMLElement.mjs";
const _sfc_main = defineComponent({
  name: "VaDropdown",
  props: {
    ...usePlacementAliasesProps,
    ...createStatefulProps(true),
    modelValue: { type: Boolean, default: false },
    anchor: { type: [String, Object], default: void 0 },
    anchorSelector: { type: String, default: "" },
    innerAnchorSelector: { type: String, default: "" },
    trigger: {
      type: String,
      default: "click",
      validator: (value) => ["click", "right-click", "hover", "dblclick", "none"].includes(value)
    },
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    closeOnClickOutside: { type: Boolean, default: true },
    closeOnFocusOutside: { type: Boolean, default: true },
    closeOnAnchorClick: { type: Boolean, default: true },
    closeOnContentClick: { type: Boolean, default: true },
    hoverOverTimeout: { type: Number, default: 30 },
    hoverOutTimeout: { type: Number, default: 200 },
    isContentHoverable: { type: Boolean, default: true },
    offset: { type: [Array, Number], default: 0 },
    keepAnchorWidth: { type: Boolean, default: false },
    verticalScrollOnOverflow: { type: Boolean, default: true },
    cursor: { type: [Boolean, Object], default: false },
    autoPlacement: { type: Boolean, default: true },
    stickToEdges: { type: Boolean, default: false },
    /** Viewport where dropdown will be rendered. Autoplacement will be calculated relative to `target` */
    target: { type: [String, Object], default: void 0 },
    /** Element where dropdown content will be rendered. */
    teleport: { type: [String, Object], default: void 0 },
    /** Not reactive */
    keyboardNavigation: { type: Boolean, default: false },
    ariaLabel: { type: String, default: "$t:toggleDropdown" },
    role: { type: String, default: "button" }
  },
  emits: [...useStatefulEmits, "anchor-click", "anchor-right-click", "content-click", "click-outside", "focus-outside", "close", "open", "anchor-dblclick"],
  setup(props, { emit }) {
    const { valueComputed: statefulVal } = useStateful(props, emit, "modelValue");
    const valueComputed = computed({
      get: () => statefulVal.value && !props.disabled && !props.readonly,
      set(val) {
        statefulVal.value = val;
        if (val) {
          emit("open");
        } else {
          emit("close");
        }
      }
    });
    const isMounted = useIsMounted();
    const { anchorRef } = useAnchorSelector(props);
    const cursorAnchor = useCursorAnchor(anchorRef, valueComputed);
    const floating = useHTMLElement("floating");
    const body = useHTMLElementSelector(ref("body"));
    const target = useHTMLElementSelector(computed(() => props.target));
    const teleport = useHTMLElementSelector(computed(() => props.teleport));
    const anchorClass = useBem("va-dropdown", () => pick(props, ["disabled"]));
    const teleportTarget = computed(() => {
      if (teleport.value) {
        return teleport.value;
      }
      if (target.value) {
        return target.value;
      }
      if (anchorRef.value) {
        const root = anchorRef.value.getRootNode();
        if (root instanceof ShadowRoot) {
          const el = [...root.children].find((c) => c.tagName !== "STYLE");
          if (el) {
            return el;
          }
        }
      }
      return body.value;
    });
    const teleportDisabled = computed(() => {
      return props.disabled;
    });
    const showFloating = computed(() => isMounted.value && valueComputed.value);
    const { debounced: debounceHover, cancel: cancelHoverDebounce } = useDebounceFn(toRef(props, "hoverOverTimeout"));
    const { debounced: debounceUnHover, cancel: cancelUnHoverDebounce } = useDebounceFn(toRef(props, "hoverOutTimeout"));
    const onClick = (e) => {
      if (props.trigger !== "click" && kebabCase(props.trigger) !== "right-click" || props.disabled) {
        return;
      }
      if (valueComputed.value) {
        emitAndClose("anchor-click", props.closeOnAnchorClick, e);
      } else {
        if (props.trigger !== "click") {
          return;
        }
        valueComputed.value = true;
        emit("anchor-click", e);
      }
    };
    const onContextmenu = (e) => {
      if (kebabCase(props.trigger) !== "right-click" || props.disabled) {
        return;
      }
      e.preventDefault();
      if (valueComputed.value) {
        emitAndClose("anchor-right-click", props.closeOnAnchorClick, e);
        if (props.cursor) {
          nextTick(() => {
            valueComputed.value = true;
          });
        }
      } else {
        valueComputed.value = true;
        emit("anchor-right-click", e);
      }
    };
    const onDblclick = (e) => {
      if (kebabCase(props.trigger) !== "dblclick" || props.disabled) {
        return;
      }
      e.preventDefault();
      if (valueComputed.value) {
        emitAndClose("anchor-dblclick", props.closeOnAnchorClick, e);
        if (props.cursor) {
          nextTick(() => {
            valueComputed.value = true;
          });
        }
      } else {
        valueComputed.value = true;
        emit("anchor-dblclick", e);
      }
    };
    const onMouseenter = () => {
      if (props.trigger !== "hover" || props.disabled) {
        return;
      }
      debounceHover(() => {
        valueComputed.value = true;
      });
      cancelUnHoverDebounce();
    };
    const onMouseleave = () => {
      if (props.trigger !== "hover" || props.disabled) {
        return;
      }
      if (props.isContentHoverable) {
        debounceUnHover(() => {
          valueComputed.value = false;
        });
      } else {
        valueComputed.value = false;
      }
      cancelHoverDebounce();
    };
    useMouseNavigation(anchorRef, {
      click: onClick,
      contextmenu: onContextmenu,
      dblclick: onDblclick,
      mouseenter: onMouseenter,
      mouseleave: onMouseleave
    });
    if (props.keyboardNavigation) {
      useKeyboardNavigation(anchorRef, valueComputed);
    }
    const emitAndClose = (eventName, close, e) => {
      emit(eventName, e);
      if (close) {
        valueComputed.value = false;
      }
    };
    const floatingListeners = {
      onMouseover: () => props.isContentHoverable && onMouseenter(),
      onMouseout: () => onMouseleave(),
      onClick: () => emitAndClose("content-click", props.closeOnContentClick)
    };
    useClickOutside([anchorRef, floating], () => {
      if (props.closeOnClickOutside && valueComputed.value) {
        emitAndClose("click-outside", props.closeOnClickOutside);
      }
    });
    useFocusOutside([floating], () => {
      if (props.closeOnFocusOutside && valueComputed.value) {
        emitAndClose("focus-outside", props.closeOnFocusOutside);
      }
    }, { onlyKeyboard: true });
    const anchorComputed = computed(() => {
      if (typeof props.cursor === "object") {
        return props.cursor;
      }
      return props.cursor ? cursorAnchor.value : anchorRef.value;
    });
    const { floatingStyles } = useDropdown(
      anchorComputed,
      floating,
      target,
      computed(() => ({
        placement: props.placement,
        offset: props.offset,
        autoPlacement: props.autoPlacement,
        stickToEdges: props.stickToEdges,
        keepAnchorWidth: props.keepAnchorWidth,
        verticalScrollOnOverflow: props.verticalScrollOnOverflow
      }))
    );
    const hide = () => {
      valueComputed.value = false;
    };
    const show = () => {
      valueComputed.value = true;
    };
    const {
      zIndex,
      register: registerZIndex,
      unregister: unregisterZIndex
    } = useZIndex();
    watchEffect(() => {
      if (valueComputed.value && isMounted.value) {
        registerZIndex();
      } else {
        unregisterZIndex();
      }
    });
    return {
      ...useTranslation(),
      ...useTeleported(),
      anchorRef,
      anchorClass,
      floating,
      floatingStyles,
      teleportDisabled,
      showFloating,
      teleportTarget,
      floatingListeners,
      isMounted,
      valueComputed,
      hide,
      show,
      zIndex
    };
  },
  render() {
    const slotBind = {
      isOpened: this.valueComputed,
      hide: this.hide,
      show: this.show,
      toggle: () => this.valueComputed ? this.hide() : this.show(),
      getAnchorWidth: () => {
        var _a;
        return ((_a = this.anchorRef) == null ? void 0 : _a.offsetWidth) + "px";
      },
      getAnchorHeight: () => {
        var _a;
        return ((_a = this.anchorRef) == null ? void 0 : _a.offsetHeight) + "px";
      }
    };
    const floatingSlotNode = this.showFloating && renderSlotNode(this.$slots.default, slotBind, {
      ref: "floating",
      class: "va-dropdown__content-wrapper",
      style: [this.floatingStyles, { zIndex: this.zIndex }],
      ...this.teleportedAttrs,
      ...this.floatingListeners
    });
    const anchorSlotVNode = renderSlotNode(this.$slots.anchor, slotBind, {
      ref: "anchorRef",
      role: this.$props.role,
      class: ["va-dropdown", ...this.anchorClass.asArray.value],
      style: { position: "relative" },
      "aria-label": this.tp(this.$props.ariaLabel),
      "aria-disabled": this.$props.disabled,
      "aria-expanded": this.$props.role && this.$props.role !== "none" ? !!this.showFloating : void 0,
      ...this.teleportFromAttrs,
      ...this.$attrs
    });
    if (typeof this.$props.cursor === "object" && floatingSlotNode) {
      return h(
        Teleport,
        {
          to: this.teleportTarget,
          disabled: this.teleportDisabled
        },
        [floatingSlotNode]
      );
    }
    if (!this.$props.anchorSelector && !anchorSlotVNode) {
      warn("VaDropdown: #anchor slot is missing");
      return;
    }
    if (this.showFloating && !floatingSlotNode) {
      warn("VaDropdown: default slot is missing");
      return;
    }
    return h(Fragment, {}, [
      anchorSlotVNode,
      floatingSlotNode && h(
        Teleport,
        {
          to: this.teleportTarget,
          disabled: this.teleportDisabled
        },
        [floatingSlotNode]
      )
    ]);
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaDropdown.vue_vue_type_script_lang.mjs.map
