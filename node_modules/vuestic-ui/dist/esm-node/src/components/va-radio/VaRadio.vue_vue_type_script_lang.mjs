import { defineComponent, shallowRef, computed } from "vue";
import { g as generateUniqueId } from "../../utils/uuid.mjs";
import { V as VaMessageListWrapper } from "../va-message-list/VaMessageListWrapper.mjs";
import { u as useSelectableEmits, a as useSelectableProps, b as useSelectable } from "../../composables/useSelectable.mjs";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.mjs";
import { u as useSelectableListProps, a as useSelectableList } from "../../composables/useSelectableList.mjs";
import { u as useColors } from "../../composables/useColors.mjs";
const _sfc_main = defineComponent({
  name: "VaRadio",
  components: { VaMessageListWrapper },
  emits: useSelectableEmits,
  props: {
    ...useSelectableProps,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    modelValue: {
      type: [Boolean, Array, String, Object, Number],
      default: null
    },
    options: {
      type: Array,
      default: () => []
    },
    name: { type: String, default: "" },
    label: { type: String, default: void 0 },
    leftLabel: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    option: {
      type: [Object, String, Number],
      default: void 0
    },
    vertical: { type: Boolean, default: false }
  },
  setup(props, { emit }) {
    const { getColor } = useColors();
    const elements = {
      container: shallowRef(),
      input: shallowRef(),
      label: shallowRef()
    };
    const {
      computedError,
      computedErrorMessages,
      validationAriaAttributes,
      onBlur,
      onFocus
    } = useSelectable(props, emit, elements);
    const { getText: originalGetText, getDisabled: originalGetDisabled, getValue } = useSelectableList(props);
    const getText = (option) => {
      if (props.options.length > 0) {
        return originalGetText(option);
      }
      return props.label ?? originalGetText(option);
    };
    const getDisabled = (option) => originalGetDisabled(option) || props.disabled;
    const isNoOption = computed(() => props.options.length === 0 && !props.option);
    const isChecked = (option) => {
      if (isNoOption.value) {
        return props.modelValue;
      }
      return props.modelValue === getValue(option);
    };
    const computedOptions = computed(() => {
      if (isNoOption.value) {
        return [{}];
      }
      if (props.option) {
        return [props.option];
      } else {
        return props.options;
      }
    });
    const radioClass = (option) => ({
      "va-radio--left-label": props.leftLabel,
      "va-radio--selected": isChecked(option),
      "va-radio--readonly": props.readonly,
      "va-radio--disabled": props.disabled,
      "va-radio--indeterminate": props.indeterminate,
      "va-radio--error": computedError.value,
      "va-radio--single-option": isNoOption.value
    });
    const selectOption = (option, event) => {
      var _a;
      if (isNoOption.value) {
        emit("update:modelValue", ((_a = event == null ? void 0 : event.target) == null ? void 0 : _a.checked) || false);
        return;
      }
      emit("update:modelValue", option);
    };
    const labelStyle = computed(() => {
      return {
        color: computedError.value ? getColor("danger") : ""
      };
    });
    const inputStyle = computed(() => {
      const style = {
        background: getColor(props.color),
        borderColor: getColor(props.color)
      };
      if (computedError.value) {
        style.borderColor = getColor("danger");
      }
      return style;
    });
    const iconBackgroundComputedStyles = computed(() => ({
      backgroundColor: getColor(props.color)
    }));
    const iconDotComputedStyles = computed(() => {
      return {
        borderColor: computedError.value ? getColor("danger") : getColor(props.color),
        backgroundColor: getColor(props.color)
      };
    });
    const iconComputedStyles = computed(() => {
      return { borderColor: computedError.value ? getColor("danger") : getColor(props.color) };
    });
    const computedName = computed(() => props.name || generateUniqueId());
    const inputAttributesComputed = (option) => {
      const disabled = getDisabled(option);
      return {
        name: computedName.value,
        disabled,
        readonly: props.readonly,
        tabindex: disabled ? -1 : 0
      };
    };
    const flexDirection = computed(() => props.vertical ? "column" : "row");
    return {
      flexDirection,
      getDisabled,
      isChecked,
      computedOptions,
      radioClass,
      labelStyle,
      inputStyle,
      computedError,
      computedErrorMessages,
      iconBackgroundComputedStyles,
      iconDotComputedStyles,
      iconComputedStyles,
      selectOption,
      onFocus,
      onBlur,
      inputAttributesComputed,
      computedName,
      roleComputed: computed(() => {
        var _a;
        return ((_a = props.options) == null ? void 0 : _a.length) > 0 ? "radiogroup" : "";
      }),
      getText,
      getValue
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaRadio.vue_vue_type_script_lang.mjs.map
