import { defineComponent, ref, computed, watchEffect, shallowRef } from "vue";
import { u as useSidebar } from "./hooks/useSidebar.mjs";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.mjs";
import { V as VaConfig } from "../va-config/VaConfig.mjs";
import { u as useElementWidth } from "../../composables/useElementWidth.mjs";
import { u as useColors } from "../../composables/useColors.mjs";
import { u as useTextColor } from "../../composables/useTextColor.mjs";
import { g as getGradientBackground } from "../../services/color/utils.mjs";
import { u as useBem } from "../../composables/useBem.mjs";
import { u as useClickOutside } from "../../composables/useClickOutside.mjs";
const _sfc_main = defineComponent({
  name: "VaSidebar",
  props: {
    ...useComponentPresetProp,
    activeColor: { type: String, default: "primary" },
    hoverColor: { type: String, default: void 0 },
    hoverOpacity: {
      type: Number,
      default: 0.2,
      validator: (v) => v >= 0 && v <= 1
    },
    borderColor: { type: String, default: void 0 },
    color: { type: String, default: "background-element" },
    textColor: { type: String },
    gradient: { type: Boolean, default: false },
    minimized: { type: Boolean, default: false },
    hoverable: { type: Boolean, default: false },
    width: { type: String, default: "16rem" },
    minimizedWidth: { type: String, default: "4rem" },
    modelValue: { type: Boolean, default: true },
    animated: { type: [Boolean, String], default: true },
    closeOnClickOutside: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"],
  components: { VaConfig },
  setup(props, { emit }) {
    const { getColor } = useColors();
    useSidebar(props);
    const isHovered = ref(false);
    const isMinimized = computed(() => props.minimized || props.hoverable && !isHovered.value);
    const menu = ref();
    const currentMenuWidth = useElementWidth(menu);
    const doShowMenu = computed(() => {
      if (props.modelValue === true) {
        return true;
      }
      if (currentMenuWidth.value === null) {
        return true;
      }
      return currentMenuWidth.value > 0;
    });
    const sidebarWidth = ref();
    const getSidebarWidth = () => {
      if (!props.modelValue) {
        return 0;
      }
      return isMinimized.value ? props.minimizedWidth : props.width;
    };
    const menuWidth = computed(() => isMinimized.value ? props.minimizedWidth : props.width);
    watchEffect(() => {
      const width = getSidebarWidth();
      setTimeout(() => {
        sidebarWidth.value = width;
      });
    });
    const backgroundColorComputed = computed(() => getColor(props.color));
    const { textColorComputed } = useTextColor(backgroundColorComputed);
    const computedStyle = computed(() => {
      const backgroundColor = getColor(backgroundColorComputed.value);
      const color = textColorComputed.value;
      return {
        color,
        backgroundColor,
        backgroundImage: props.gradient ? getGradientBackground(backgroundColor) : void 0,
        overflowX: currentMenuWidth.value === sidebarWidth.value ? void 0 : "hidden",
        width: sidebarWidth.value,
        minWidth: sidebarWidth.value
      };
    });
    const computedClass = useBem("va-sidebar", () => ({
      minimized: isMinimized.value,
      animated: Boolean(props.animated),
      "animated-right": props.animated === "right",
      "animated-left": props.animated === "left" || props.animated === true
    }));
    const updateHoverState = (newHoverState) => {
      isHovered.value = props.hoverable && newHoverState;
    };
    const rootElement = shallowRef();
    useClickOutside([rootElement], () => {
      if (props.closeOnClickOutside && props.modelValue) {
        setTimeout(() => {
          emit("update:modelValue", false);
        }, 0);
      }
    });
    return {
      menu,
      menuWidth,
      doShowMenu,
      computedClass,
      computedStyle,
      updateHoverState,
      rootElement,
      vaSidebarItemProps: computed(() => ({
        textColor: props.textColor,
        activeColor: props.activeColor,
        hoverColor: props.hoverColor,
        borderColor: props.borderColor,
        hoverOpacity: props.hoverOpacity
      }))
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaSidebar.vue_vue_type_script_lang.mjs.map
