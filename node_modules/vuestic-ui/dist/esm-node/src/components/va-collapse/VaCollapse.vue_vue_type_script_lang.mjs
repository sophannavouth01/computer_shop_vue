import { defineComponent, shallowRef, ref, computed, watch } from "vue";
import { p as pick } from "../../../vendor.mjs";
import { a as useAccordionItem } from "../va-accordion/hooks/useAccordion.mjs";
import { g as generateUniqueId } from "../../utils/uuid.mjs";
import { V as VaIcon } from "../va-icon/index.mjs";
import { u as useSelectableEmits } from "../../composables/useSelectable.mjs";
import { u as useResizeObserver } from "../../composables/useResizeObserver.mjs";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.mjs";
import { a as useStatefulProps, b as useStateful } from "../../composables/useStateful.mjs";
import { u as useColors } from "../../composables/useColors.mjs";
import { u as useBem } from "../../composables/useBem.mjs";
import { u as useTextColor } from "../../composables/useTextColor.mjs";
const _sfc_main = defineComponent({
  name: "VaCollapse",
  components: {
    VaIcon
  },
  props: {
    ...useComponentPresetProp,
    ...useStatefulProps,
    modelValue: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    header: { type: String, default: "" },
    icon: { type: String, default: "" },
    color: { type: String, default: void 0 },
    bodyColor: { type: String, default: void 0 },
    textColor: { type: String, default: "" },
    bodyTextColor: { type: String, default: "" },
    iconColor: { type: String, default: "secondary" },
    colorAll: { type: Boolean, default: false },
    stateful: { type: Boolean, default: true }
  },
  emits: ["update:modelValue", ...useSelectableEmits],
  setup(props, { emit }) {
    const body = shallowRef();
    const { valueComputed } = useStateful(props, emit, "modelValue");
    const { getColor, getTextColor, setHSLAColor } = useColors();
    const { accordionProps, valueProxy: computedModelValue = valueComputed } = useAccordionItem();
    const bodyHeight = ref();
    useResizeObserver([body], () => {
      var _a;
      bodyHeight.value = ((_a = body.value) == null ? void 0 : _a.clientHeight) ?? 0;
    });
    const height = computed(() => computedModelValue.value ? bodyHeight.value : 0);
    const getTransition = () => {
      const duration = height.value / 1e3 * 0.2;
      return `${duration > 0.2 ? duration : 0.2}s`;
    };
    const contentBackground = computed(() => {
      if (props.bodyColor) {
        return getColor(props.bodyColor);
      }
      return props.color && props.colorAll ? setHSLAColor(getColor(props.color), { a: 0.07 }) : void 0;
    });
    const headerBackground = computed(() => {
      return props.color ? getColor(props.color) : void 0;
    });
    const uniqueId = computed(generateUniqueId);
    const headerIdComputed = computed(() => `header-${uniqueId.value}`);
    const panelIdComputed = computed(() => `panel-${uniqueId.value}`);
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    const headerAttributes = computed(() => ({
      id: headerIdComputed.value,
      tabindex: tabIndexComputed.value,
      "aria-controls": panelIdComputed.value,
      "aria-expanded": computedModelValue.value,
      "aria-disabled": props.disabled,
      role: "button"
    }));
    const isHeightChanging = ref(false);
    watch(height, (newValue, oldValue) => {
      if (oldValue === void 0) {
        return;
      }
      isHeightChanging.value = true;
    });
    const onTransitionEnd = (e) => {
      if (e.propertyName === "height" && e.target === e.currentTarget) {
        isHeightChanging.value = false;
      }
    };
    const computedClasses = useBem("va-collapse", () => ({
      ...pick(props, ["disabled"]),
      expanded: computedModelValue.value,
      active: computedModelValue.value,
      popout: !!(accordionProps.value.popout && computedModelValue.value),
      inset: !!(accordionProps.value.inset && computedModelValue.value),
      "height-changing": isHeightChanging.value,
      "colored-body": Boolean(contentBackground.value),
      "colored-header": Boolean(headerBackground.value)
    }));
    const toggle = () => {
      if (props.disabled) {
        return;
      }
      computedModelValue.value = !computedModelValue.value;
    };
    const { textColorComputed } = useTextColor(headerBackground);
    const headerStyle = computed(() => ({
      color: textColorComputed.value,
      backgroundColor: headerBackground.value
    }));
    const contentStyle = computed(() => {
      return {
        visibility: bodyHeight.value > 0 ? "visible" : "hidden",
        height: `${height.value}px`,
        transitionDuration: getTransition(),
        background: computedModelValue.value ? contentBackground.value : "",
        color: props.bodyTextColor ? getColor(props.bodyTextColor) : contentBackground.value ? getColor(getTextColor(contentBackground.value)) : "currentColor"
      };
    });
    return {
      onTransitionEnd,
      body,
      height,
      toggle,
      computedModelValue,
      headerIdComputed,
      headerAttributes,
      panelIdComputed,
      tabIndexComputed,
      computedClasses,
      headerStyle,
      contentStyle
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaCollapse.vue_vue_type_script_lang.mjs.map
