{"version":3,"file":"useStateful.js","sources":["../../../../src/composables/useStateful.ts"],"sourcesContent":["import { ref, computed, watch, PropType, Ref, getCurrentInstance, watchEffect } from 'vue'\nimport { NOT_PROVIDED, useUserProvidedProp } from './useUserProvidedProp'\n\nexport type StatefulProps = {\n  stateful: boolean\n}\n\nexport type StatefulOptions<T> = {\n  eventName?: string\n  /** Prefer to set default value for prop, not here. */\n  defaultValue?: T\n}\n\ntype NonUndefined<T extends any> = T extends undefined ? never : T\n\n/**\n * You could add these props to any component by destructuring them inside props option.\n * @example\n * props: { ...useStatefulProps, componentsOwnProp, etc. }\n * It's better to add props at the beginning, to make sure that Component own props will be used instead in case of collision\n */\nexport const useStatefulProps = {\n  stateful: { type: Boolean as PropType<boolean>, default: false },\n  modelValue: { type: undefined as any },\n}\n\nexport const createStatefulProps = (statefulDefault = false) => {\n  return {\n    stateful: { type: Boolean as PropType<boolean>, default: statefulDefault },\n  }\n}\n\nexport const useStatefulEmits = ['update:modelValue'] as const\n\n/**\n * Returns `valueComputed` that is proxy for `modelValue` or given key of the props\n * if `stateful` prop is `false`\n * Record<any, any> & Record<'modelValue', T>\n */\nexport const useStateful = <\n  T,\n  D extends any,\n  O extends StatefulOptions<D>,\n  Key extends string = 'modelValue',\n  P extends StatefulProps & Record<Key, T> = StatefulProps & Record<Key, T>\n>(\n    props: P,\n    emit: (name: `update:${Key}`, ...args: any[]) => void,\n    key: Key = 'modelValue' as Key,\n    options: O = {} as O,\n  ) => {\n  const { eventName, defaultValue } = options\n  const event = (eventName || `update:${key.toString()}`) as `update:${Key}`\n\n  const passedProp = useUserProvidedProp(key, props)\n\n  const defaultValuePassed = 'defaultValue' in options\n\n  const valueState = ref(\n    passedProp.value === NOT_PROVIDED\n      ? defaultValuePassed ? defaultValue : props[key]\n      : passedProp.value,\n  ) as Ref<P[Key]>\n\n  let unwatchModelValue: ReturnType<typeof watch>\n  const watchModelValue = () => {\n    unwatchModelValue = watch(() => props[key], (modelValue) => {\n      valueState.value = modelValue\n    })\n  }\n\n  watch(() => props.stateful, (stateful: boolean) => {\n    stateful ? watchModelValue() : unwatchModelValue?.()\n  }, { immediate: true })\n\n  const valueComputed = computed({\n    get: () => {\n      if (props.stateful) { return valueState.value }\n\n      return props[key]\n    },\n    set: (value) => {\n      if (props.stateful) { valueState.value = value }\n\n      emit(event, value)\n    },\n  })\n\n  return { valueComputed }\n}\n"],"names":[],"mappings":";;AAqBO,MAAM,mBAAmB;AAAA,EAC9B,UAAU,EAAE,MAAM,SAA8B,SAAS,MAAM;AAAA,EAC/D,YAAY,EAAE,MAAM,OAAiB;AACvC;AAEa,MAAA,sBAAsB,CAAC,kBAAkB,UAAU;AACvD,SAAA;AAAA,IACL,UAAU,EAAE,MAAM,SAA8B,SAAS,gBAAgB;AAAA,EAAA;AAE7E;AAEa,MAAA,mBAAmB,CAAC,mBAAmB;AAOvC,MAAA,cAAc,CAOvB,OACA,MACA,MAAW,cACX,UAAa,OACV;AACC,QAAA,EAAE,WAAW,aAAiB,IAAA;AACpC,QAAM,QAAS,aAAa,UAAU,IAAI,SAAS;AAE7C,QAAA,aAAa,oBAAoB,KAAK,KAAK;AAEjD,QAAM,qBAAqB,kBAAkB;AAE7C,QAAM,aAAa;AAAA,IACjB,WAAW,UAAU,eACjB,qBAAqB,eAAe,MAAM,GAAG,IAC7C,WAAW;AAAA,EAAA;AAGb,MAAA;AACJ,QAAM,kBAAkB,MAAM;AAC5B,wBAAoB,MAAM,MAAM,MAAM,GAAG,GAAG,CAAC,eAAe;AAC1D,iBAAW,QAAQ;AAAA,IAAA,CACpB;AAAA,EAAA;AAGH,QAAM,MAAM,MAAM,UAAU,CAAC,aAAsB;AACtC,eAAA,oBAAoB;AAAA,EAAoB,GAClD,EAAE,WAAW,KAAA,CAAM;AAEtB,QAAM,gBAAgB,SAAS;AAAA,IAC7B,KAAK,MAAM;AACT,UAAI,MAAM,UAAU;AAAE,eAAO,WAAW;AAAA,MAAM;AAE9C,aAAO,MAAM,GAAG;AAAA,IAClB;AAAA,IACA,KAAK,CAAC,UAAU;AACd,UAAI,MAAM,UAAU;AAAE,mBAAW,QAAQ;AAAA,MAAM;AAE/C,WAAK,OAAO,KAAK;AAAA,IACnB;AAAA,EAAA,CACD;AAED,SAAO,EAAE,cAAc;AACzB;"}