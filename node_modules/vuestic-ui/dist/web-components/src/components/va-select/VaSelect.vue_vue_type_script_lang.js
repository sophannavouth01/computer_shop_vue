import { defineComponent, shallowRef, computed, watch, ref, nextTick } from "vue";
import { p as pick } from "../../../vendor.js";
import { V as VaInputWrapper } from "../va-input-wrapper/index.js";
import { V as VaDropdown } from "../va-dropdown/index.js";
import { V as VaIcon } from "../va-icon/index.js";
import { V as VaSelectOptionList } from "./components/VaSelectOptionList/index.js";
import { V as VaSelectContent } from "./components/VaSelectContent/index.js";
import { u as useMaxVisibleOptionsProps, a as useMaxVisibleOptions } from "./hooks/useMaxVisibleOptions.js";
import { u as useToggleIconProps, a as useToggleIcon } from "./hooks/useToggleIcon.js";
import { u as useStringValueProps, a as useStringValue } from "./hooks/useStringValue.js";
import { u as useAutocompleteProps, a as useAutocomplete } from "./hooks/useAutocomplete.js";
import { u as useSelectAria } from "./hooks/useSelectAria.js";
import { f as focusElement, b as blurElement } from "../../utils/focus.js";
import { u as unwrapEl } from "../../utils/unwrapEl.js";
import { i as isNilValue } from "../../utils/isNilValue.js";
import { w as warn } from "../../utils/console.js";
import { V as VaDropdownContent } from "../va-dropdown/components/VaDropdownContent/index.js";
import { u as useMaxSelectionsProps, a as useMaxSelections } from "../../composables/useMaxSelections.js";
import { e as extractComponentProps } from "../../utils/component-options/extract-component-options.js";
import { a as useDropdownableEmits, u as useDropdownableProps, b as useDropdownable } from "../../composables/useDropdownable.js";
import { u as useValidationEmits, b as useValidationProps, a as useValidation } from "../../composables/useValidation.js";
import { a as useClearableEmits, u as useClearableProps, b as useClearable } from "../../composables/useClearable.js";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.js";
import { u as useSelectableListProps, a as useSelectableList } from "../../composables/useSelectableList.js";
import { u as useLoadingProps } from "../../composables/useLoading.js";
import { u as useFormFieldProps } from "../../composables/useFormField.js";
import { u as useThrottleProps } from "../../composables/useThrottle.js";
import { u as useTranslation } from "../../composables/useTranslation.js";
import { u as useFocusDeep } from "../../composables/useFocusDeep.js";
import { u as useSyncProp } from "../../composables/useSyncProp.js";
import { u as useBem } from "../../composables/useBem.js";
import { f as filterComponentProps } from "../../utils/component-options/filter-props.js";
const VaInputWrapperProps = extractComponentProps(VaInputWrapper);
const _sfc_main = defineComponent({
  name: "VaSelect",
  components: {
    VaSelectContent,
    VaSelectOptionList,
    VaIcon,
    VaDropdown,
    VaDropdownContent,
    VaInputWrapper
  },
  emits: [
    "update:modelValue",
    "update-search",
    "create-new",
    "scroll-bottom",
    "update:search",
    ...useDropdownableEmits,
    ...useValidationEmits,
    ...useClearableEmits
  ],
  props: {
    ...VaInputWrapperProps,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    ...useValidationProps,
    ...useLoadingProps,
    ...useMaxSelectionsProps,
    ...useClearableProps,
    ...useFormFieldProps,
    ...useMaxVisibleOptionsProps,
    ...useToggleIconProps,
    ...useThrottleProps,
    ...useStringValueProps,
    ...useAutocompleteProps,
    ...useDropdownableProps,
    modelValue: {
      type: [String, Number, Array, Object, Boolean],
      default: ""
    },
    // Dropdown placement
    placement: {
      ...useDropdownableProps.placement,
      default: "bottom"
    },
    allowCreate: {
      type: [Boolean, String],
      default: false,
      validator: (mode) => [true, false, "unique"].includes(mode)
    },
    color: { type: String, default: "primary" },
    multiple: { type: Boolean, default: false },
    searchable: { type: Boolean, default: false },
    width: { type: String, default: "100%" },
    maxHeight: { type: String, default: "256px" },
    noOptionsText: { type: String, default: "$t:noOptions" },
    hideSelected: { type: Boolean, default: false },
    tabindex: { type: [String, Number], default: 0 },
    virtualScroller: { type: Boolean, default: false },
    selectedTopShown: { type: Boolean, default: false },
    highlightMatchedText: { type: Boolean, default: true },
    minSearchChars: { type: Number, default: 0 },
    autoSelectFirstOption: { type: Boolean, default: false },
    // Input style
    placeholder: { type: String, default: "" },
    searchPlaceholderText: { type: String, default: "$t:search" },
    ariaLabel: { type: String, default: "$t:select" },
    ariaSearchLabel: { type: String, default: "$t:optionsFilter" },
    ariaClearLabel: { type: String, default: "$t:reset" },
    search: { type: String, default: void 0 }
  },
  setup(props, { emit, slots }) {
    const { tp, t } = useTranslation();
    const optionList = shallowRef();
    const input = shallowRef();
    const searchBar = shallowRef();
    const isInputFocused = useFocusDeep(input);
    const { getValue, getText, getTrackBy } = useSelectableList(props);
    const onScrollBottom = () => emit("scroll-bottom");
    const [searchVModel] = useSyncProp("search", props, emit, "");
    const showSearchInput = computed(() => props.searchable || props.allowCreate && !props.autocomplete);
    watch(searchVModel, (value) => {
      emit("update-search", value);
      if (!props.autocomplete) {
        hoveredOption.value = null;
      }
    });
    const getOptionByValue = (value) => {
      if (isNilValue(value) || typeof value === "object") {
        return value;
      }
      const optionByValue = props.options.find((option) => value === getValue(option));
      if (optionByValue === void 0) {
        warn(`[VaSelect]: can not find option in options list (${JSON.stringify(props.options)}) by provided value (${JSON.stringify(value)})!`);
        return value;
      }
      return optionByValue;
    };
    const {
      toggleHiddenOptionsState,
      isAllOptionsShown,
      visibleSelectedOptions,
      hiddenSelectedOptionsAmount,
      allSelectedOptions
    } = useMaxVisibleOptions(props, getOptionByValue);
    const valueComputed = computed({
      get() {
        if (props.multiple) {
          return allSelectedOptions.value;
        }
        const value = getOptionByValue(props.modelValue);
        if (Array.isArray(value)) {
          warn("Model value should be a string, number, boolean or an object for a single Select.");
          if (value.length) {
            return value.at(-1);
          }
        }
        return value;
      },
      set(option) {
        if (Array.isArray(option)) {
          emit("update:modelValue", option.map(getValue));
        } else {
          emit("update:modelValue", getValue(option));
        }
      }
    });
    const valueString = useStringValue(props, visibleSelectedOptions, getText);
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueComputed);
    const showClearIcon = computed(() => {
      if (!canBeCleared.value) {
        return false;
      }
      if (props.multiple && Array.isArray(valueComputed.value)) {
        return !!valueComputed.value.length;
      }
      return true;
    });
    const filteredOptions = computed(() => {
      if (!props.options) {
        return [];
      }
      if (props.selectedTopShown) {
        return props.options.slice().sort((a, b) => {
          const isASelected = checkIsOptionSelected(a);
          const isBSelected = checkIsOptionSelected(b);
          if (isASelected && isBSelected) {
            return 0;
          }
          if (isASelected && !isBSelected) {
            return -1;
          }
          return 1;
        });
      }
      if (props.hideSelected) {
        return props.options.filter((option) => !checkIsOptionSelected(option));
      }
      return props.options;
    });
    const checkIsOptionSelected = (option) => {
      if (isNilValue(valueComputed.value)) {
        return false;
      }
      if (Array.isArray(valueComputed.value)) {
        return !isNilValue(valueComputed.value.find((valueItem) => compareOptions(valueItem, option)));
      }
      return compareOptions(valueComputed.value, option);
    };
    const compareOptions = (option1, option2) => {
      const one = getValue(option1);
      const two = getValue(option2);
      if (one === two) {
        return true;
      }
      if (typeof one === "string" && typeof two === "string") {
        return one === two;
      }
      if (one === null || two === null) {
        return false;
      }
      if (typeof one === "object" && typeof two === "object") {
        return getTrackBy(one) === getTrackBy(two);
      }
      return false;
    };
    const isValueComputedArray = (v) => Array.isArray(v.value);
    const selectOption = (option) => {
      if (hoveredOption.value === null) {
        hideAndFocus();
        return;
      }
      if (showSearchInput.value) {
        searchVModel.value = "";
      }
      if (props.multiple && isValueComputedArray(valueComputed)) {
        const { exceedsMaxSelections, addOption } = useMaxSelections(valueComputed, ref(props.maxSelections));
        const isSelected = checkIsOptionSelected(option);
        if (isSelected) {
          valueComputed.value = valueComputed.value.filter((optionSelected) => !compareOptions(option, optionSelected));
        } else {
          if (exceedsMaxSelections()) {
            return;
          }
          valueComputed.value = addOption(option);
        }
      } else {
        valueComputed.value = typeof option !== "object" ? option : { ...option };
        hideAndFocus();
      }
      focusAutocompleteInput();
    };
    const addNewOption = () => {
      var _a;
      const hasAddedOption = (_a = props.options) == null ? void 0 : _a.some((option) => [searchVModel.value, autocompleteValue.value].includes(getText(option)));
      const allowedToCreateCheck = !((props.allowCreate === "unique" || props.autocomplete) && hasAddedOption);
      if (allowedToCreateCheck) {
        emit("create-new", searchVModel.value || autocompleteValue.value);
        searchVModel.value = "";
        autocompleteValue.value = "";
      }
    };
    const hoveredOption = ref(null);
    const selectHoveredOption = () => {
      if (isNilValue(hoveredOption.value)) {
        return;
      }
      if (!isOpenSync.value) {
        handleDropdownOpen();
        return;
      }
      selectOption(hoveredOption.value);
    };
    const selectOrAddOption = () => {
      const allowedToCreate = !!props.allowCreate && (searchVModel.value || autocompleteValue.value);
      if (hoveredOption.value !== null) {
        selectHoveredOption();
      } else if (allowedToCreate) {
        addNewOption();
      }
    };
    const focusPreviousOption = () => {
      var _a;
      return (_a = optionList.value) == null ? void 0 : _a.focusPreviousOption();
    };
    const focusNextOption = () => {
      var _a;
      return (_a = optionList.value) == null ? void 0 : _a.focusNextOption();
    };
    const { isOpenSync, dropdownProps } = useDropdownable(props, emit, {
      defaultCloseOnValueUpdate: computed(() => !props.multiple)
    });
    const dropdownPropsComputed = computed(() => ({
      ...dropdownProps.value,
      closeOnContentClick: false,
      stateful: false,
      offset: [1, 0],
      keepAnchorWidth: true,
      keyboardNavigation: true,
      innerAnchorSelector: ".va-input-wrapper__field"
    }));
    const showDropdownContentComputed = computed({
      get: () => isOpenSync.value,
      set: (show) => {
        show ? handleDropdownOpen() : handleDropdownClose();
      }
    });
    const handleDropdownOpen = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      isOpenSync.value = true;
      scrollToSelected();
      focusSearchOrOptions();
    };
    const handleDropdownClose = () => {
      isOpenSync.value = false;
      if (!props.autocomplete) {
        searchVModel.value = "";
      }
      nextTick(() => {
        validate();
        isInputFocused.focusIfNothingIfFocused();
      });
    };
    const hideAndFocus = () => {
      handleDropdownClose();
      isInputFocused.value = true;
    };
    const focusSearchBar = () => {
      var _a;
      (_a = searchBar.value) == null ? void 0 : _a.focus();
    };
    const focusOptionList = () => {
      var _a, _b;
      (_a = optionList.value) == null ? void 0 : _a.focus();
      !props.modelValue && ((_b = optionList.value) == null ? void 0 : _b.focusFirstOption());
    };
    const focusSearchOrOptions = async () => {
      await nextTick();
      if (showSearchInput.value) {
        focusSearchBar();
      } else {
        focusOptionList();
      }
    };
    const onInputBlur = () => {
      if (showDropdownContentComputed.value) {
        return;
      }
      onBlur();
      isInputFocused.value ? isInputFocused.value = false : validate();
    };
    const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex);
    const openSelectButtonTabIndexComputed = computed(() => props.disabled || props.autocomplete ? -1 : 0);
    const scrollToSelected = () => {
      const selected = valueComputed.value;
      const nothingSelected = typeof selected !== "object" && Array.isArray(selected) && !selected.length;
      if (nothingSelected) {
        return;
      }
      const scrollTo = Array.isArray(selected) ? selected[selected.length - 1] : selected;
      hoveredOption.value = scrollTo;
      nextTick(() => {
        var _a;
        return (_a = optionList.value) == null ? void 0 : _a.scrollToOption(scrollTo);
      });
    };
    let hintedSearchQuery = "";
    let hintedSearchQueryTimeoutIndex;
    const navigationKeys = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Enter", " "];
    const onHintedSearch = (event) => {
      if (navigationKeys.some((key) => key === event.key)) {
        return;
      }
      const isLetter = event.key.length === 1;
      const isDeleteKey = event.key === "Backspace" || event.key === "Delete";
      clearTimeout(hintedSearchQueryTimeoutIndex);
      if (isDeleteKey) {
        hintedSearchQuery = hintedSearchQuery ? hintedSearchQuery.slice(0, -1) : "";
      } else if (isLetter) {
        hintedSearchQuery += event.key;
      }
      if (showSearchInput.value) {
        searchVModel.value = hintedSearchQuery;
        return;
      }
      if (hintedSearchQuery) {
        const appropriateOption = props.options.find((option) => getText(option).toLowerCase().startsWith(hintedSearchQuery.toLowerCase()));
        if (appropriateOption) {
          hoveredOption.value = appropriateOption;
        }
      }
      hintedSearchQueryTimeoutIndex = setTimeout(() => {
        hintedSearchQuery = "";
      }, 1e3);
    };
    const optionsListPropsComputed = computed(() => ({
      ...pick(props, ["textBy", "trackBy", "groupBy", "valueBy", "disabledBy", "color", "virtualScroller", "highlightMatchedText", "minSearchChars", "delay", "selectedTopShown"]),
      autoSelectFirstOption: props.autoSelectFirstOption || props.autocomplete,
      search: searchVModel.value || autocompleteValue.value,
      tabindex: tabIndexComputed.value,
      selectedValue: valueComputed.value,
      options: filteredOptions.value,
      getSelectedState: checkIsOptionSelected,
      noOptionsText: tp(props.noOptionsText)
    }));
    const { toggleIcon, toggleIconColor } = useToggleIcon(props, isOpenSync);
    const isFocused = computed(() => isInputFocused.value || isOpenSync.value);
    const inputWrapperClassComputed = useBem("va-select-anchor", () => ({
      nowrap: !!(props.maxVisibleOptions && !slots.content)
    }));
    const vaInputWrapperProps = filterComponentProps(VaInputWrapperProps);
    const inputWrapperPropsComputed = computed(() => ({
      ...vaInputWrapperProps.value,
      error: computedError.value,
      errorMessages: computedErrorMessages.value,
      focused: isFocused.value,
      "aria-label": props.ariaLabel || (props.modelValue ? `${t("selectedOption")}: ${props.modelValue}` : t("noSelectedOption"))
    }));
    const selectContentPropsComputed = computed(() => ({
      ...pick(props, ["placeholder", "autocomplete", "multiple", "disabled", "readonly"]),
      tabindex: tabIndexComputed.value,
      value: visibleSelectedOptions.value,
      valueString: valueString.value,
      hiddenSelectedOptionsAmount: hiddenSelectedOptionsAmount.value,
      isAllOptionsShown: isAllOptionsShown.value,
      focused: isInputFocused.value,
      autocompleteInputValue: autocompleteValue.value,
      getText
    }));
    const autocompleteValue = useAutocomplete(searchVModel, props, visibleSelectedOptions, isOpenSync, getText);
    const setAutocompleteValue = (v) => autocompleteValue.value = v;
    const focus = () => {
      if (props.disabled) {
        return;
      }
      focusElement(unwrapEl(input.value));
    };
    const blur = () => {
      if (showDropdownContentComputed.value) {
        showDropdownContentComputed.value = false;
      }
      nextTick(() => {
        if (props.disabled) {
          return;
        }
        blurElement(unwrapEl(input.value));
      });
    };
    const reset = () => withoutValidation(() => {
      if (props.multiple) {
        valueComputed.value = Array.isArray(props.clearValue) ? props.clearValue : [];
      } else {
        valueComputed.value = props.clearValue;
      }
      searchVModel.value = "";
      emit("clear");
      resetValidation();
      nextTick(() => {
        isInputFocused.value = true;
      });
    });
    const focusAutocompleteInput = (e) => {
      if (props.autocomplete && !props.disabled && !props.readonly) {
        e == null ? void 0 : e.stopImmediatePropagation();
        isInputFocused.value = true;
        isOpenSync.value = true;
      }
    };
    const toggleDropdown = (e) => {
      if (props.disabled || props.readonly) {
        return;
      }
      const isInInput = e.target && "tagName" in e.target && e.target.tagName === "INPUT";
      if (e.code === "Space" && isInInput) {
        return;
      }
      e.preventDefault();
      showDropdownContentComputed.value = !showDropdownContentComputed.value;
    };
    const deleteLastSelected = () => {
      if (!Array.isArray(valueComputed.value)) {
        return;
      }
      valueComputed.value = valueComputed.value.slice(0, -1);
    };
    const {
      validate,
      computedError,
      computedErrorMessages,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus, value: valueComputed });
    const { popupId } = useSelectAria();
    const searchInput = searchVModel;
    const onInputFocus = onFocus;
    return {
      popupId,
      input,
      optionList,
      searchBar,
      reset,
      focus,
      blur,
      toggleDropdown,
      deleteLastSelected,
      focusAutocompleteInput,
      tp,
      t,
      onInputFocus,
      onInputBlur,
      focusOptionList,
      focusSearchBar,
      searchInput,
      showSearchInput,
      hoveredOption,
      tabIndexComputed,
      valueString,
      showClearIcon,
      toggleIcon,
      selectOption,
      selectOrAddOption,
      selectHoveredOption,
      focusPreviousOption,
      focusNextOption,
      showDropdownContentComputed,
      handleDropdownOpen,
      handleDropdownClose,
      hideAndFocus,
      toggleIconColor,
      onHintedSearch,
      onScrollBottom,
      clearIconProps,
      dropdownPropsComputed,
      visibleSelectedOptions,
      optionsListPropsComputed,
      toggleHiddenOptionsState,
      setAutocompleteValue,
      inputWrapperPropsComputed,
      inputWrapperClassComputed,
      selectContentPropsComputed,
      openSelectButtonTabIndexComputed,
      // for e2e tests
      getOptionByValue,
      compareOptions,
      getText
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaSelect.vue_vue_type_script_lang.js.map
