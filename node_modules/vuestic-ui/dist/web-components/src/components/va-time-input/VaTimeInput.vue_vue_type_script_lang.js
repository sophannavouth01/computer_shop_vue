import { defineComponent, shallowRef, computed, nextTick } from "vue";
import { o as omit } from "../../../vendor.js";
import { u as useTimeParser } from "./hooks/time-text-parser.js";
import { u as useTimeFormatter } from "./hooks/time-text-formatter.js";
import { _ as _VaTimePicker } from "../va-time-picker/VaTimePicker.js";
import { V as VaInputWrapper } from "../va-input-wrapper/index.js";
import { V as VaIcon } from "../va-icon/index.js";
import { V as VaDropdown } from "../va-dropdown/index.js";
import { V as VaDropdownContent } from "../va-dropdown/components/VaDropdownContent/index.js";
import { u as useLongPressKey } from "../../composables/useLongPresKey.js";
import { e as extractComponentProps } from "../../utils/component-options/extract-component-options.js";
import { a as useFocusEmits, u as useFocus } from "../../composables/useFocus.js";
import { u as useValidationEmits, b as useValidationProps, a as useValidation } from "../../composables/useValidation.js";
import { a as useClearableEmits, u as useClearableProps, b as useClearable } from "../../composables/useClearable.js";
import { u as useStatefulEmits, a as useStatefulProps, b as useStateful } from "../../composables/useStateful.js";
import { a as useDropdownableEmits, u as useDropdownableProps, b as useDropdownable } from "../../composables/useDropdownable.js";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.js";
import { f as filterComponentProps } from "../../utils/component-options/filter-props.js";
import { u as useTranslation } from "../../composables/useTranslation.js";
const VaInputWrapperProps = extractComponentProps(VaInputWrapper, ["focused", "maxLength", "counterValue"]);
const _sfc_main = defineComponent({
  name: "VaTimeInput",
  components: { VaDropdown, VaDropdownContent, VaTimePicker: _VaTimePicker, VaIcon, VaInputWrapper },
  emits: [
    ...useFocusEmits,
    ...useValidationEmits,
    ...useClearableEmits,
    ...useStatefulEmits,
    ...useDropdownableEmits,
    "update:modelValue"
  ],
  props: {
    ...VaInputWrapperProps,
    ...useDropdownableProps,
    ...useComponentPresetProp,
    ...useClearableProps,
    ...extractComponentProps(_VaTimePicker),
    ...useValidationProps,
    ...useStatefulProps,
    closeOnContentClick: { type: Boolean, default: false },
    offset: { ...useDropdownableProps.offset, default: () => [2, 0] },
    placement: { ...useDropdownableProps.placement, default: "bottom-end" },
    modelValue: { type: Date, default: void 0 },
    clearValue: { type: Date, default: void 0 },
    format: { type: Function },
    parse: { type: Function },
    manualInput: { type: Boolean, default: false },
    leftIcon: { type: Boolean, default: false },
    icon: { type: String, default: "schedule" },
    ariaLabel: { type: String, default: "$t:selectedTime" },
    ariaResetLabel: { type: String, default: "$t:resetTime" },
    ariaToggleDropdownLabel: { type: String, default: "$t:toggleDropdown" }
  },
  inheritAttrs: false,
  setup(props, { emit, slots, attrs }) {
    const input = shallowRef();
    const timePicker = shallowRef();
    const { isOpenSync, dropdownProps } = useDropdownable(props, emit, {
      defaultCloseOnValueUpdate: computed(() => Array.isArray(props.view) && props.view.length === 1)
    });
    const { valueComputed } = useStateful(props, emit);
    const { parse, isValid } = useTimeParser(props);
    const { format } = useTimeFormatter(props);
    const valueText = computed(() => format(valueComputed.value || props.clearValue));
    const doShowDropdown = computed({
      get() {
        if (props.disabled || props.readonly) {
          return false;
        }
        return isOpenSync.value;
      },
      set(v) {
        isOpenSync.value = v;
        if (v) {
          nextTick(() => {
            var _a;
            return (_a = timePicker.value) == null ? void 0 : _a.focus();
          });
        } else {
          nextTick(() => {
            var _a;
            return (_a = input.value) == null ? void 0 : _a.focus();
          });
        }
      }
    });
    const { isFocused, focus, blur, onFocus: focusListener, onBlur: blurListener } = useFocus(input);
    const onInputTextChanged = (e) => {
      var _a;
      if (props.disabled) {
        return;
      }
      const val = (_a = e.target) == null ? void 0 : _a.value;
      if (!val) {
        return reset();
      }
      const v = parse(val);
      if (isValid.value && v) {
        valueComputed.value = v;
      } else {
        valueComputed.value = void 0;
        isValid.value = true;
      }
    };
    const reset = () => withoutValidation(() => {
      emit("update:modelValue", props.clearValue);
      emit("clear");
      resetValidation();
      hideDropdown();
    });
    const {
      computedError,
      computedErrorMessages,
      listeners,
      validationAriaAttributes,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus, value: valueComputed });
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueText);
    const canBeClearedComputed = computed(() => canBeCleared.value && valueText.value !== format(props.clearValue));
    const filteredWrapperProps = filterComponentProps(VaInputWrapperProps);
    const computedInputWrapperProps = computed(() => ({
      ...filteredWrapperProps.value,
      focused: isFocused.value,
      error: computedError.value,
      errorMessages: computedErrorMessages.value,
      readonly: props.readonly || !props.manualInput
    }));
    const viewToNumber = {
      seconds: 1e3,
      minutes: 1e3 * 60,
      hours: 1e3 * 60 * 60
    };
    const onKeyPress = (e) => {
      if (!("key" in e)) {
        return;
      }
      if (e.key === "ArrowDown") {
        valueComputed.value = new Date(Number(valueComputed.value) - viewToNumber[props.view]);
        e.preventDefault();
      }
      if (e.key === "ArrowUp") {
        valueComputed.value = new Date(Number(valueComputed.value) + viewToNumber[props.view]);
        e.preventDefault();
      }
    };
    useLongPressKey(input, {
      onStart: onKeyPress,
      onUpdate: onKeyPress
    });
    const computedInputListeners = {
      focus: () => {
        if (props.disabled) {
          return;
        }
        focusListener();
        if (props.readonly) {
          return;
        }
        onFocus();
        listeners.onFocus();
      },
      blur: () => {
        if (props.disabled) {
          return;
        }
        blurListener();
        if (props.readonly) {
          return;
        }
        onBlur();
        listeners.onBlur();
      }
    };
    const filteredSlots = computed(() => {
      const slotsWithIcons = [
        props.leftIcon && "prependInner",
        (!props.leftIcon || props.clearable) && "icon"
      ];
      return Object.keys(slots).filter((slot) => !slotsWithIcons.includes(slot));
    });
    const hideDropdown = () => {
      doShowDropdown.value = false;
    };
    const showDropdown = (event, cancel, prevent) => {
      doShowDropdown.value = true;
    };
    const checkProhibitedDropdownOpening = (e) => {
      if (isOpenSync.value) {
        return false;
      }
      if (props.disabled || props.readonly) {
        return true;
      }
      return props.manualInput && (e == null ? void 0 : e.code) !== "Space";
    };
    const toggleDropdown = (event) => {
      if (checkProhibitedDropdownOpening(event instanceof KeyboardEvent ? event : void 0)) {
        return;
      }
      doShowDropdown.value = !doShowDropdown.value;
    };
    const cursorStyleComputed = computed(() => {
      if (props.disabled) {
        return {};
      }
      if (props.manualInput) {
        return { cursor: "text" };
      }
      return { cursor: "pointer" };
    });
    const iconTabindexComputed = computed(() => {
      if (!props.manualInput) {
        return -1;
      }
      return props.disabled || props.readonly ? -1 : 0;
    });
    const iconProps = computed(() => ({
      role: "button",
      "aria-hidden": false,
      name: props.icon,
      color: "secondary",
      tabindex: iconTabindexComputed.value
    }));
    const { tp } = useTranslation();
    const inputAttributesComputed = computed(() => ({
      readonly: props.readonly || !props.manualInput,
      disabled: props.disabled,
      tabindex: props.disabled ? -1 : 0,
      value: valueText.value,
      "aria-label": props.label || tp(props.ariaLabel),
      "aria-required": props.requiredMark,
      "aria-disabled": props.disabled,
      "aria-readonly": props.readonly,
      ...validationAriaAttributes.value,
      ...omit(attrs, ["class", "style"])
    }));
    const dropdownPropsComputed = computed(() => ({
      ...dropdownProps.value,
      keyboardNavigation: true,
      innerAnchorSelector: ".va-input-wrapper__field",
      trigger: "none"
    }));
    return {
      tp,
      input,
      timePicker,
      timePickerProps: filterComponentProps(extractComponentProps(_VaTimePicker)),
      dropdownPropsComputed,
      computedInputWrapperProps,
      computedInputListeners,
      isOpenSync,
      doShowDropdown,
      valueComputed,
      valueText,
      onInputTextChanged,
      canBeClearedComputed,
      iconProps,
      clearIconProps,
      filteredSlots,
      inputAttributesComputed,
      cursorStyleComputed,
      hideDropdown,
      showDropdown,
      toggleDropdown,
      reset,
      focus,
      blur
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaTimeInput.vue_vue_type_script_lang.js.map
