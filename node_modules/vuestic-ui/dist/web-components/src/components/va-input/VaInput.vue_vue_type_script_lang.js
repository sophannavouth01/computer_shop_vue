import { defineComponent, shallowRef, computed, toRefs, watch } from "vue";
import { o as omit, p as pick } from "../../../vendor.js";
import { u as useCleaveProps, a as useCleave } from "./hooks/useCleave.js";
import { V as VaInputWrapper } from "../va-input-wrapper/index.js";
import { V as VaIcon } from "../va-icon/index.js";
import { c as combineFunctions } from "../../utils/combine-functions.js";
import { u as useFocusableProps, a as useFocusable } from "../../composables/useFocusable.js";
import { u as useClearableProps, a as useClearableEmits, b as useClearable } from "../../composables/useClearable.js";
import { b as useValidationProps, u as useValidationEmits, a as useValidation } from "../../composables/useValidation.js";
import { u as useDeprecatedCondition } from "../../composables/useDeprecatedCondition.js";
import { u as useEmitProxy } from "../../composables/useEmitProxy.js";
import { e as extractComponentProps } from "../../utils/component-options/extract-component-options.js";
import { u as useFormFieldProps } from "../../composables/useFormField.js";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.js";
import { a as useStatefulProps, u as useStatefulEmits, b as useStateful } from "../../composables/useStateful.js";
import { u as useEvent } from "../../composables/useEvent.js";
import { u as useTranslation } from "../../composables/useTranslation.js";
import { f as filterComponentProps } from "../../utils/component-options/filter-props.js";
const VaInputWrapperProps = extractComponentProps(VaInputWrapper);
const { createEmits: createInputEmits, createListeners: createInputListeners } = useEmitProxy(
  ["change", "keyup", "keypress", "keydown", "focus", "blur", "input"]
);
const { createEmits: createFieldEmits, createListeners: createFieldListeners } = useEmitProxy([
  "click",
  "click-prepend",
  "click-append",
  "click-prepend-inner",
  "click-append-inner"
]);
const _sfc_main = defineComponent({
  name: "VaInput",
  components: { VaInputWrapper, VaIcon },
  props: {
    ...VaInputWrapperProps,
    ...useFormFieldProps,
    ...useFocusableProps,
    ...useValidationProps,
    ...useClearableProps,
    ...useCleaveProps,
    ...useComponentPresetProp,
    ...useStatefulProps,
    // input
    placeholder: { type: String, default: "" },
    tabindex: { type: [String, Number], default: 0 },
    modelValue: { type: [Number, String], default: "" },
    type: { type: String, default: "text" },
    inputClass: { type: String, default: "" },
    pattern: { type: String },
    inputmode: { type: String, default: "text" },
    counter: { type: Boolean, default: false },
    // style
    ariaResetLabel: { type: String, default: "$t:reset" },
    /** Set value to input when model value is updated */
    strictBindInputValue: { type: Boolean, default: false }
  },
  emits: [
    "update:modelValue",
    ...useValidationEmits,
    ...useClearableEmits,
    ...createInputEmits(),
    ...createFieldEmits(),
    ...useStatefulEmits
  ],
  inheritAttrs: false,
  setup(props, { emit, attrs, slots }) {
    useDeprecatedCondition([
      () => props.type !== "textarea" || 'Use VaTextarea component instead of VaInput with type="textarea"'
    ]);
    const input = shallowRef();
    const { valueComputed } = useStateful(props, emit, "modelValue");
    const reset = () => withoutValidation(() => {
      emit("update:modelValue", props.clearValue);
      emit("clear");
      resetValidation();
    });
    const { focus, blur } = useFocusable(input, props);
    const filterSlots = computed(() => {
      const iconSlot = ["icon"];
      return Object.keys(slots).filter((slot) => !iconSlot.includes(slot));
    });
    const {
      isDirty,
      computedError,
      computedErrorMessages,
      listeners: { onBlur, onFocus },
      validationAriaAttributes,
      isLoading,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus, value: valueComputed });
    const { modelValue } = toRefs(props);
    const {
      canBeCleared,
      clearIconProps
    } = useClearable(props, modelValue, input, computedError);
    const { computedValue, onInput } = useCleave(input, props, valueComputed);
    const inputListeners = createInputListeners(emit);
    const inputEvents = {
      ...inputListeners,
      onFocus: combineFunctions(onFocus, inputListeners.onFocus),
      onBlur: combineFunctions(onBlur, inputListeners.onBlur),
      onInput: combineFunctions(onInput, inputListeners.onInput)
    };
    const setInputValue = (newValue) => {
      if (!props.strictBindInputValue) {
        return;
      }
      const target = input.value;
      if (!target) {
        return;
      }
      const selectionStart = target.selectionStart || 0;
      const selectionEnd = target.selectionEnd || 0;
      if (target.value !== newValue) {
        target.value = String(newValue);
      }
      target.setSelectionRange(selectionStart, selectionEnd);
    };
    watch(computedValue, (newValue) => {
      setInputValue(String(newValue));
    });
    useEvent("input", () => {
      setInputValue(String(valueComputed.value));
    }, input);
    const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex);
    const computedChildAttributes = computed(() => ({
      "aria-label": props.inputAriaLabel || props.label,
      "aria-labelledby": props.inputAriaLabelledby,
      "aria-required": props.requiredMark,
      tabindex: tabIndexComputed.value,
      class: props.inputClass,
      "aria-disabled": props.disabled,
      "aria-readonly": props.readonly,
      ...validationAriaAttributes.value,
      ...omit(attrs, ["class", "style"])
    }));
    const computedInputAttributes = computed(() => ({
      ...computedChildAttributes.value,
      ...pick(props, ["type", "disabled", "readonly", "placeholder", "pattern", "inputmode", "minlength", "maxlength"])
    }));
    const valueLengthComputed = computed(
      () => props.counter && typeof computedValue.value === "string" ? computedValue.value.length : void 0
    );
    const onFieldClick = (e) => {
      if (!e.target || !("tagName" in e.target)) {
        return;
      }
      if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") {
        return;
      }
      focus();
    };
    return {
      ...useTranslation(),
      onFieldClick,
      input,
      inputEvents,
      isLoading,
      valueLengthComputed,
      computedChildAttributes,
      computedInputAttributes,
      wrapperProps: filterComponentProps(VaInputWrapperProps),
      computedValue,
      tabIndexComputed,
      // Validations
      computedError,
      computedErrorMessages,
      // Icon
      canBeCleared,
      clearIconProps,
      fieldListeners: createFieldListeners(emit),
      filterSlots,
      isDirty,
      reset,
      focus,
      blur
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaInput.vue_vue_type_script_lang.js.map
