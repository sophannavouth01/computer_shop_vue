import { k as kebabCase, j as camelCase } from "../../../vendor.js";
import { ColorTranslator } from "colortranslator";
const makeColor = (color) => {
  try {
    return new ColorTranslator(color);
  } catch (e) {
    throw new Error(`Color ${color} is not valid. Please, provide valid color.`, {
      cause: e
    });
  }
};
const isCSSVariable = (strColor) => /var\(--.+\)/.test(strColor);
const cssVariableName = (colorName) => `--va-${kebabCase(colorName)}`;
const normalizeColorName = (colorName) => camelCase(colorName);
const colorToRgba = (color, opacity) => {
  return makeColor(color).setA(opacity).RGBA;
};
const getColorLightness = (color) => {
  const { R, G, B } = makeColor(color);
  return Math.sqrt(R * R * 0.241 + G * G * 0.691 + B * B * 0.068);
};
const getBoxShadowColor = (color, opacity = 0.4) => {
  return makeColor(color).setA(opacity).RGBA;
};
const getBoxShadowColorFromBg = (background, opacity = 0.4) => {
  return makeColor(background).setA(opacity).RGBA;
};
const getHoverColor = (color, opacity = 0.2) => {
  return makeColor(color).setA(opacity).RGBA;
};
const getFocusColor = (color, opacity = 0.3) => {
  return makeColor(color).setA(opacity).RGBA;
};
const shiftHSLAColor = (color, offset) => {
  const result = makeColor(color);
  if (offset.h) {
    result.setH(result.H + offset.h);
  }
  if (offset.s) {
    result.setS(result.S + offset.s);
  }
  if (offset.l) {
    result.setL(result.L + offset.l);
  }
  if (offset.a) {
    result.setA(result.A + offset.a);
  }
  return result.HSLA;
};
const setHSLAColor = (color, newColor) => {
  const result = makeColor(color);
  if (newColor.h !== void 0) {
    result.setH(newColor.h);
  }
  if (newColor.s !== void 0) {
    result.setS(newColor.s);
  }
  if (newColor.l !== void 0) {
    result.setL(newColor.l);
  }
  if (newColor.a !== void 0) {
    result.setA(newColor.a);
  }
  return result.HSLA;
};
const shiftGradientColor = (color) => {
  const newColor = ColorTranslator.toHSLA(color, false);
  if (newColor.s < 10) {
    return shiftHSLAColor(newColor, { h: 2, s: 5, l: 10 });
  }
  if (newColor.s < 30) {
    return shiftHSLAColor(newColor, { s: -14, l: 11 });
  }
  if (newColor.h >= 0 && newColor.h < 44 || newColor.h >= 285) {
    return shiftHSLAColor(newColor, { h: 11, s: 27, l: 8 });
  }
  if (newColor.h >= 44 && newColor.h < 85) {
    return shiftHSLAColor(newColor, { h: 3, l: 9 });
  }
  if (newColor.h >= 85 && newColor.h < 165) {
    return shiftHSLAColor(newColor, { h: 16, l: 14 });
  }
  if (newColor.h >= 165 && newColor.h < 285) {
    return shiftHSLAColor(newColor, { h: -15, s: 3, l: 2 });
  }
  throw new Error("This method should handle all colors. But it didn't for some reason.");
};
const getGradientBackground = (color) => {
  const colorLeft = shiftGradientColor(color);
  const colorRight = ColorTranslator.toHSLA(color);
  return `linear-gradient(to right, ${colorLeft}, ${colorRight})`;
};
const getStateMaskGradientBackground = (color, maskColor, maskOpacity) => {
  const mask = colorToRgba(maskColor, maskOpacity);
  return `linear-gradient(0deg, ${mask}, ${mask}), ${color}`;
};
const isColor = (strColor) => {
  const cssColorRegex = /^#([\da-f]{3}){1,2}$|^#([\da-f]{4}){1,2}$|(rgb|hsl)a?\((\s*-?\d+%?\s*,){2}(\s*-?\d+%?\s*,?\s*\)?)(,\s*(0?\.\d+)?|1)?\)/;
  return cssColorRegex.test(strColor.toLocaleLowerCase());
};
const applyColors = (color1, color2) => {
  const c1 = makeColor(color1);
  const c2 = makeColor(color2);
  const weight = c2.A;
  if (weight === 1) {
    return c2.RGBA;
  }
  if (weight === 0) {
    return c1.RGBA;
  }
  c1.setR(Math.round(c1.R * (1 - weight) + c2.R * weight));
  c1.setG(Math.round(c1.G * (1 - weight) + c2.G * weight));
  c1.setB(Math.round(c1.B * (1 - weight) + c2.B * weight));
  return c1.RGBA;
};
const isColorTransparent = (color) => {
  if (!color) {
    return false;
  }
  if (color === "transparent") {
    return true;
  }
  return makeColor(color).A <= 0.1;
};
export {
  getBoxShadowColor as a,
  getFocusColor as b,
  getHoverColor as c,
  colorToRgba as d,
  applyColors as e,
  getBoxShadowColorFromBg as f,
  getGradientBackground as g,
  setHSLAColor as h,
  getStateMaskGradientBackground as i,
  cssVariableName as j,
  isColor as k,
  isCSSVariable as l,
  getColorLightness as m,
  normalizeColorName as n,
  isColorTransparent as o,
  shiftHSLAColor as s
};
//# sourceMappingURL=utils.js.map
