{"version":3,"file":"createProxyComponent.js","sources":["../../../../../src/services/config-transport/createProxyComponent.ts"],"sourcesContent":["import { getCurrentInstance, ComponentInternalInstance, DefineComponent, SetupContext, Ref, shallowReadonly, normalizeClass, normalizeStyle, computed } from 'vue'\nimport { useComponentConfigProps } from '../component-config/utils/use-component-config-props'\nimport omit from 'lodash/omit'\n\n/** Compiled and reactive props. By default they passed to setup fn */\ntype Props = Record<string, unknown>;\n/** Raw props */\ntype RawProps = Record<string, unknown>;\n\nconst toCamelCase = (str: string) => str.replace(/-([a-z])/g, (g) => g[1].toUpperCase())\n\nconst findCamelCased = (obj: Record<string, unknown>, key: string) => {\n  const found = Object.keys(obj).find((k) => toCamelCase(k) === key)\n  return found && obj[found]\n}\n\n/**\n * @param propsFromConfig Ref of custom props. Required to be ref so vue can rerender component on custom props change.\n * @returns new props object, where some props replaced with props from config.\n */\nconst createPropsWithCustomConfig = (instance: ComponentInternalInstance, propsFromConfig: Ref<Props>) => {\n  /**\n   * Reactive and compiled props. Compiled props considering default value, Boolean transformation etc.\n   * It is a default props that passed to setup function.\n   */\n  const instanceProps: Props = instance.props\n\n  return new Proxy(instanceProps, {\n    get: (target, key: string) => {\n      if (typeof key !== 'string') { return target[key] }\n\n      /**\n       * Props passed to VNode. Not compiled at all and not reactive.\n       * VNode props contained only props passed from parent.\n       */\n      const incomingProps: RawProps = instance.vnode.props || {}\n\n      /**\n       * Make sure to access both original and from config prop in get.\n       * Since instanceProps and propsFromConfig both are reactive, we need to know that both of\n       * this objects are dependency of effect where proxy is used.\n       * If original prop will not be accessed vue will not track reactivity for original props object.\n       */\n      const originalProp = target[key]\n      const propFromConfig = propsFromConfig.value?.[key]\n      const incomingProp = findCamelCased(incomingProps, key)\n\n      if (incomingProp !== undefined) {\n        return originalProp\n      }\n\n      // Return prop from config only if user didn't pass props manually\n      if (propFromConfig !== undefined) {\n        return propFromConfig\n      }\n\n      return originalProp\n    },\n  })\n}\n\nconst mergeStyles = (style1: unknown, style2: unknown) => {\n  if (!style1) { return style2 }\n  if (!style2) { return style1 }\n\n  if (typeof style1 === 'string' && typeof style2 === 'string') {\n    return style1 + style2\n  }\n\n  if (Array.isArray(style1) && Array.isArray(style2)) {\n    return [...(style1 || []), ...(style2 || [])]\n  }\n\n  if (typeof style1 === 'object' && typeof style2 === 'object') {\n    return { ...style1, ...style2 }\n  }\n\n  console.warn('[Vuestic UI] Cannot merge styles', style1, style2)\n  throw new Error('[Vuestic UI] Cannot merge styles. It is internal Vuestic error, please open issue on github')\n}\n\nconst createAttrsWithCustomConfig = (instance: ComponentInternalInstance, propsFromConfig: Ref<Props>) => {\n  // Instance.attrs will be patched later, so we save original object here to prevent recursion\n  const instanceAttrs = instance.attrs\n\n  return new Proxy(instanceAttrs, {\n    get: (target, key: string) => {\n      if (typeof key !== 'string') { return target[key] }\n\n      if (key === 'class') {\n        return normalizeClass([propsFromConfig.value.class, instanceAttrs.class])\n      }\n\n      if (key === 'style') {\n        return normalizeStyle([propsFromConfig.value.style, instanceAttrs.style])\n      }\n\n      const attrFromConfig = propsFromConfig.value?.[key]\n\n      if (attrFromConfig !== undefined) {\n        return attrFromConfig\n      }\n\n      return target[key]\n    },\n    ownKeys (target) {\n      // TODO: Optimize\n      return [...new Set([...Object.keys(instanceAttrs), ...Object.keys(propsFromConfig.value)])]\n    },\n    getOwnPropertyDescriptor (target, key) {\n      return Reflect.getOwnPropertyDescriptor(propsFromConfig.value, key) ?? Reflect.getOwnPropertyDescriptor(instanceAttrs, key)\n    },\n  })\n}\n\nexport const createProxyComponent = <T extends DefineComponent>(component: T) => {\n  const customSetup = (originalProps: Props, ctx: SetupContext) => {\n    const instance = getCurrentInstance()! // Not null during setup call\n    const propsFromConfig = useComponentConfigProps(component, originalProps)\n    const attrsFromConfig = computed(() => {\n      return omit(propsFromConfig.value, Object.keys(originalProps))\n    })\n\n    const props = createPropsWithCustomConfig(instance, propsFromConfig)\n    const attrs = createAttrsWithCustomConfig(instance, attrsFromConfig)\n\n    /**\n     * Patch instance props with Proxy.\n     * This will change props object during render and in Devtools.\n     */\n    instance.props = props\n    instance.attrs = attrs\n\n    return component.setup?.(shallowReadonly(props), {\n      ...ctx,\n      attrs,\n    })\n  }\n\n  return new Proxy(component, {\n    get (target, key: any) {\n      if (key === 'setup') { return customSetup }\n\n      return target[key]\n    },\n  })\n}\n"],"names":[],"mappings":";;;AASA,MAAM,cAAc,CAAC,QAAgB,IAAI,QAAQ,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,YAAa,CAAA;AAEvF,MAAM,iBAAiB,CAAC,KAA8B,QAAgB;AAC9D,QAAA,QAAQ,OAAO,KAAK,GAAG,EAAE,KAAK,CAAC,MAAM,YAAY,CAAC,MAAM,GAAG;AAC1D,SAAA,SAAS,IAAI,KAAK;AAC3B;AAMA,MAAM,8BAA8B,CAAC,UAAqC,oBAAgC;AAKxG,QAAM,gBAAuB,SAAS;AAE/B,SAAA,IAAI,MAAM,eAAe;AAAA,IAC9B,KAAK,CAAC,QAAQ,QAAgB;;AACxB,UAAA,OAAO,QAAQ,UAAU;AAAE,eAAO,OAAO,GAAG;AAAA,MAAE;AAMlD,YAAM,gBAA0B,SAAS,MAAM,SAAS,CAAA;AAQlD,YAAA,eAAe,OAAO,GAAG;AACzB,YAAA,kBAAiB,qBAAgB,UAAhB,mBAAwB;AACzC,YAAA,eAAe,eAAe,eAAe,GAAG;AAEtD,UAAI,iBAAiB,QAAW;AACvB,eAAA;AAAA,MACT;AAGA,UAAI,mBAAmB,QAAW;AACzB,eAAA;AAAA,MACT;AAEO,aAAA;AAAA,IACT;AAAA,EAAA,CACD;AACH;AAsBA,MAAM,8BAA8B,CAAC,UAAqC,oBAAgC;AAExG,QAAM,gBAAgB,SAAS;AAExB,SAAA,IAAI,MAAM,eAAe;AAAA,IAC9B,KAAK,CAAC,QAAQ,QAAgB;;AACxB,UAAA,OAAO,QAAQ,UAAU;AAAE,eAAO,OAAO,GAAG;AAAA,MAAE;AAElD,UAAI,QAAQ,SAAS;AACnB,eAAO,eAAe,CAAC,gBAAgB,MAAM,OAAO,cAAc,KAAK,CAAC;AAAA,MAC1E;AAEA,UAAI,QAAQ,SAAS;AACnB,eAAO,eAAe,CAAC,gBAAgB,MAAM,OAAO,cAAc,KAAK,CAAC;AAAA,MAC1E;AAEM,YAAA,kBAAiB,qBAAgB,UAAhB,mBAAwB;AAE/C,UAAI,mBAAmB,QAAW;AACzB,eAAA;AAAA,MACT;AAEA,aAAO,OAAO,GAAG;AAAA,IACnB;AAAA,IACA,QAAS,QAAQ;AAEf,aAAO,CAAC,GAAG,oBAAI,IAAI,CAAC,GAAG,OAAO,KAAK,aAAa,GAAG,GAAG,OAAO,KAAK,gBAAgB,KAAK,CAAC,CAAC,CAAC;AAAA,IAC5F;AAAA,IACA,yBAA0B,QAAQ,KAAK;AAC9B,aAAA,QAAQ,yBAAyB,gBAAgB,OAAO,GAAG,KAAK,QAAQ,yBAAyB,eAAe,GAAG;AAAA,IAC5H;AAAA,EAAA,CACD;AACH;AAEa,MAAA,uBAAuB,CAA4B,cAAiB;AACzE,QAAA,cAAc,CAAC,eAAsB,QAAsB;;AAC/D,UAAM,WAAW;AACX,UAAA,kBAAkB,wBAAwB,WAAW,aAAa;AAClE,UAAA,kBAAkB,SAAS,MAAM;AACrC,aAAO,KAAK,gBAAgB,OAAO,OAAO,KAAK,aAAa,CAAC;AAAA,IAAA,CAC9D;AAEK,UAAA,QAAQ,4BAA4B,UAAU,eAAe;AAC7D,UAAA,QAAQ,4BAA4B,UAAU,eAAe;AAMnE,aAAS,QAAQ;AACjB,aAAS,QAAQ;AAEjB,YAAO,eAAU,UAAV,mCAAkB,gBAAgB,KAAK,GAAG;AAAA,MAC/C,GAAG;AAAA,MACH;AAAA,IAAA;AAAA,EACD;AAGI,SAAA,IAAI,MAAM,WAAW;AAAA,IAC1B,IAAK,QAAQ,KAAU;AACrB,UAAI,QAAQ,SAAS;AAAS,eAAA;AAAA,MAAY;AAE1C,aAAO,OAAO,GAAG;AAAA,IACnB;AAAA,EAAA,CACD;AACH;"}