import { ref, watch, provide, computed, inject, onMounted, onBeforeUnmount } from "vue";
const AccordionServiceKey = Symbol("AccordionService");
const useAccordion = (props, state) => {
  const items = ref([]);
  const onItemMounted = (item) => {
    items.value.push(item);
  };
  const onItemUnmounted = (item) => {
    items.value = items.value.filter((i) => i !== item);
  };
  const getItemValue = (item) => {
    return state.value[items.value.indexOf(item)] ?? false;
  };
  const setItemValue = (item, value) => {
    const index = items.value.indexOf(item);
    if (index === -1) {
      return;
    }
    if (!props.multiple) {
      state.value = state.value.map((el, i) => {
        if (i === index) {
          return value;
        }
        return false;
      });
    } else {
      state.value[index] = value;
    }
  };
  watch(items, (newItems) => {
    state.value = newItems.map((item) => getItemValue(item));
  }, { deep: true });
  provide(AccordionServiceKey, {
    isInsideAccordion: true,
    onItemMounted,
    onItemUnmounted,
    getItemValue,
    setItemValue,
    props: computed(() => props)
  });
  return { items };
};
const useAccordionItem = () => {
  const accordion = inject(AccordionServiceKey, void 0);
  if (!accordion) {
    return { accordionProps: ref({}) };
  }
  const item = {};
  onMounted(() => accordion.onItemMounted(item));
  onBeforeUnmount(() => accordion.onItemUnmounted(item));
  const valueProxy = computed({
    get: () => accordion.getItemValue(item),
    set: (value) => accordion.setItemValue(item, value)
  });
  return {
    valueProxy,
    accordionProps: accordion.props
  };
};
export {
  useAccordionItem as a,
  useAccordion as u
};
//# sourceMappingURL=useAccordion.js.map
