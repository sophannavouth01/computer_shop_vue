{"version":3,"file":"VaInput.js","sources":["../../../../../src/components/va-input/VaInput.vue"],"sourcesContent":["<template>\n  <va-input-wrapper\n    v-bind=\"{\n      ...fieldListeners,\n      ...wrapperProps,\n    }\"\n    class=\"va-input\"\n    :class=\"$attrs.class\"\n    :style=\"$attrs.style\"\n    :loading=\"$props.loading || isLoading\"\n    :error=\"computedError\"\n    :error-messages=\"computedErrorMessages\"\n    :error-count=\"errorCount\"\n    :counter-value=\"valueLengthComputed\"\n    @click=\"onFieldClick\"\n  >\n    <!-- Simply proxy slots to VaInputWrapper -->\n    <template\n      v-for=\"name in filterSlots\"\n      :key=\"name\"\n      v-slot:[name]=\"slotScope\"\n    >\n      <slot :name=\"name\" v-bind=\"slotScope\" />\n    </template>\n\n    <template #icon=\"slotScope\">\n      <va-icon\n        v-if=\"canBeCleared\"\n        role=\"button\"\n        :aria-label=\"tp($props.ariaResetLabel)\"\n        v-bind=\"clearIconProps\"\n        @click.stop=\"reset\"\n        @keydown.enter.stop=\"reset\"\n        @keydown.space.stop=\"reset\"\n      />\n      <slot name=\"icon\" v-bind=\"slotScope\" />\n    </template>\n\n    <input\n      v-if=\"!$slots.content\"\n      ref=\"input\"\n      class=\"va-input__content__input\"\n      v-bind=\"{ ...computedInputAttributes, ...inputEvents }\"\n      :value=\"computedValue\"\n    >\n  </va-input-wrapper>\n</template>\n\n<script lang=\"ts\">\nimport { computed, defineComponent, InputHTMLAttributes, nextTick, shallowRef, toRefs, watch } from 'vue'\nimport omit from 'lodash/omit.js'\nimport pick from 'lodash/pick.js'\n\nimport { extractComponentProps, filterComponentProps } from '../../utils/component-options'\n\nimport {\n  useComponentPresetProp,\n  useFormFieldProps,\n  useValidation, useValidationProps, useValidationEmits, ValidationProps,\n  useEmitProxy,\n  useClearable, useClearableProps, useClearableEmits,\n  useTranslation,\n  useStateful, useStatefulProps, useStatefulEmits, useDeprecatedCondition,\n  useFocusable, useFocusableProps, useEvent,\n} from '../../composables'\nimport { useCleave, useCleaveProps } from './hooks/useCleave'\n\nimport type { AnyStringPropType } from '../../utils/types/prop-type'\n\nimport { VaInputWrapper } from '../va-input-wrapper'\nimport { VaIcon } from '../va-icon'\nimport { combineFunctions } from '../../utils/combine-functions'\n\nconst VaInputWrapperProps = extractComponentProps(VaInputWrapper)\n\nconst { createEmits: createInputEmits, createListeners: createInputListeners } = useEmitProxy(\n  ['change', 'keyup', 'keypress', 'keydown', 'focus', 'blur', 'input'],\n)\n\nconst { createEmits: createFieldEmits, createListeners: createFieldListeners } = useEmitProxy([\n  'click',\n  'click-prepend',\n  'click-append',\n  'click-prepend-inner',\n  'click-append-inner',\n])\n\nexport default defineComponent({\n  name: 'VaInput',\n\n  components: { VaInputWrapper, VaIcon },\n\n  props: {\n    ...VaInputWrapperProps,\n    ...useFormFieldProps,\n    ...useFocusableProps,\n    ...useValidationProps as ValidationProps<string>,\n    ...useClearableProps,\n    ...useCleaveProps,\n    ...useComponentPresetProp,\n    ...useStatefulProps,\n\n    // input\n    placeholder: { type: String, default: '' },\n    tabindex: { type: [String, Number], default: 0 },\n    modelValue: { type: [Number, String], default: '' },\n    type: { type: String as AnyStringPropType<'text' | 'password'>, default: 'text' },\n    inputClass: { type: String, default: '' },\n    pattern: { type: String },\n    inputmode: { type: String, default: 'text' },\n    counter: { type: Boolean, default: false },\n\n    // style\n    ariaResetLabel: { type: String, default: '$t:reset' },\n\n    /** Set value to input when model value is updated */\n    strictBindInputValue: { type: Boolean, default: false },\n  },\n\n  emits: [\n    'update:modelValue',\n    ...useValidationEmits,\n    ...useClearableEmits,\n    ...createInputEmits(),\n    ...createFieldEmits(),\n    ...useStatefulEmits,\n  ],\n\n  inheritAttrs: false,\n\n  setup (props, { emit, attrs, slots }) {\n    useDeprecatedCondition([\n      () => props.type !== 'textarea' || 'Use VaTextarea component instead of VaInput with type=\"textarea\"',\n    ])\n\n    const input = shallowRef<HTMLInputElement>()\n\n    const { valueComputed } = useStateful(props, emit, 'modelValue')\n\n    const reset = () => withoutValidation(() => {\n      emit('update:modelValue', props.clearValue)\n      emit('clear')\n      resetValidation()\n    })\n\n    const { focus, blur } = useFocusable(input, props)\n\n    const filterSlots = computed(() => {\n      const iconSlot = ['icon']\n      return Object.keys(slots).filter(slot => !iconSlot.includes(slot))\n    })\n\n    const {\n      isDirty,\n      computedError,\n      computedErrorMessages,\n      listeners: { onBlur, onFocus },\n      validationAriaAttributes,\n      isLoading,\n      withoutValidation,\n      resetValidation,\n    } = useValidation(props, emit, { reset, focus, value: valueComputed })\n\n    const { modelValue } = toRefs(props)\n    const {\n      canBeCleared,\n      clearIconProps,\n    } = useClearable(props, modelValue, input, computedError)\n\n    const { computedValue, onInput } = useCleave(input, props, valueComputed)\n\n    const inputListeners = createInputListeners(emit)\n\n    const inputEvents = {\n      ...inputListeners,\n      onFocus: combineFunctions(onFocus, inputListeners.onFocus),\n      onBlur: combineFunctions(onBlur, inputListeners.onBlur),\n      onInput: combineFunctions(onInput, inputListeners.onInput),\n    }\n\n    const setInputValue = (newValue: string) => {\n      if (!props.strictBindInputValue) {\n        return\n      }\n\n      const target = input.value\n\n      if (!target) {\n        return\n      }\n\n      // Similar to cleave solution\n      // When user types, we update input value according to computedValue, if value is different\n      // This causes cursor to move to the end of the input\n      // To prevent this, we save cursor position and restore it after value is updated\n      const selectionStart = target.selectionStart || 0\n      const selectionEnd = target.selectionEnd || 0\n\n      if (target.value !== newValue) {\n        target.value = String(newValue)\n      }\n      target.setSelectionRange(selectionStart, selectionEnd)\n    }\n\n    watch(computedValue, (newValue) => {\n      setInputValue(String(newValue))\n    })\n\n    useEvent('input', () => {\n      setInputValue(String(valueComputed.value))\n    }, input)\n\n    const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex)\n\n    const computedChildAttributes = computed(() => ({\n      'aria-label': props.inputAriaLabel || props.label,\n      'aria-labelledby': props.inputAriaLabelledby,\n      'aria-required': props.requiredMark,\n      tabindex: tabIndexComputed.value,\n      class: props.inputClass,\n      'aria-disabled': props.disabled,\n      'aria-readonly': props.readonly,\n      ...validationAriaAttributes.value,\n      ...omit(attrs, ['class', 'style']),\n    }) as InputHTMLAttributes)\n\n    const computedInputAttributes = computed(() => ({\n      ...computedChildAttributes.value,\n      ...pick(props, ['type', 'disabled', 'readonly', 'placeholder', 'pattern', 'inputmode', 'minlength', 'maxlength']),\n    }) as InputHTMLAttributes)\n\n    const valueLengthComputed = computed(() =>\n      props.counter && typeof computedValue.value === 'string' ? computedValue.value.length : undefined,\n    )\n\n    const onFieldClick = (e: MouseEvent) => {\n      if (!e.target || !('tagName' in e.target)) {\n        return\n      }\n\n      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {\n        return\n      }\n\n      focus()\n    }\n\n    return {\n      ...useTranslation(),\n      onFieldClick,\n      input,\n      inputEvents,\n      isLoading,\n\n      valueLengthComputed,\n      computedChildAttributes,\n      computedInputAttributes,\n      wrapperProps: filterComponentProps(VaInputWrapperProps),\n      computedValue,\n      tabIndexComputed,\n\n      // Validations\n      computedError,\n      computedErrorMessages,\n\n      // Icon\n      canBeCleared,\n      clearIconProps,\n\n      fieldListeners: createFieldListeners(emit),\n      filterSlots,\n      isDirty,\n      reset,\n      focus,\n      blur,\n    }\n  },\n})\n</script>\n"],"names":["_resolveComponent","_openBlock","_createBlock","_mergeProps","_createSlots","_withCtx","_withModifiers","_createCommentVNode","_renderSlot","_normalizeProps","_guardReactiveProps","_createElementBlock"],"mappings":";;;;;;sCA6CqBA,iBA5CnB,kBAAA;SAC8CC,UAAY,GAAAC,YAAA,6BAAAC,WAAA;AAAA,IAAA,GAAA,KAAA;AAAA,IAIxD,GAAK,KAAC;AAAA,EAAA,GAEL;AAAA,IACA,OAAO,CAAQ,YAAA,KAAC,OAAW,KAAA;AAAA,IAC3B,OAAO,KAAA,OAAA;AAAA,IACP,SAAgB,KAAA,OAAA,WAAA,KAAA;AAAA,IAChB,OAAA,KAAA;AAAA,IACA,kBAAe,KAAA;AAAA,IACf,eAAO,KAAA;AAAA,IAAA,iBAAA,KAAA;AAAA,IAWG,SAAI,KAAA;AAAA,EAEL,CAAA,GAAAC,YAAA;AAAA,IADR,MAAAC,QAAA,CAAA,cAAA;AAAA,MAAA,KAAA,gBAAAJ,UAAA,GAEeC,YAAA,oBAAAC,WAAA;AAAA,QACZ,KAAA;AAAA,QACO,MAAA;AAAA,QACP,cAAK,aAAO,OAAK,cAAA;AAAA,MAAA,GACjB,KAAO,gBAAA;AAAA,QAAA,SAAAG,cAAA,KAAa,OAAK,CAAA,MAAA,CAAA;AAAA,QAAA,WAAA;AAAA;;;MAGW,CAAA,GAAA,MAAA,IAAA,CAAA,cAAA,WAAA,WAAA,CAAA,KAAAC,mBAAA,IAAA,IAAA;AAAA,MASxCC,WAAA,KAAA,QAAA,QAAAC,eAAAC,mBAAA,SAAA,CAAA,CAAA;AAAA,IAAA,CAAA;AAAA,IAND,SAAAL,QAAA,MAAA;AAAA,MAAA,CAAA,KAAA,OAAA,WAAAJ,UAAA,GAEaU,mBAAA,SAAAR,WAAA;AAAA,QACX,KAAK;AAAA,QAAA,KAAA;AAAA;;;;;eArBE,KAAM,aAAA,CAAA,SAAA;;;;;;;;;;;"}