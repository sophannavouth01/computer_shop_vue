import { defineComponent, shallowRef, computed } from "vue";
import { p as pick } from "../../../vendor.js";
import { V as VaInputWrapper } from "../va-input-wrapper/index.js";
import { f as focusElement, b as blurElement } from "../../utils/focus.js";
import { e as extractComponentProps } from "../../utils/component-options/extract-component-options.js";
import { u as useFormFieldProps } from "../../composables/useFormField.js";
import { a as useStatefulProps, b as useStateful } from "../../composables/useStateful.js";
import { b as useValidationProps, u as useValidationEmits, a as useValidation } from "../../composables/useValidation.js";
import { f as filterComponentProps } from "../../utils/component-options/filter-props.js";
import { u as useEmitProxy } from "../../composables/useEmitProxy.js";
const positiveNumberValidator = (val) => {
  if (val > 0 && (val | 0) === val) {
    return true;
  }
  throw new Error(`\`minRows|maxRows\` must be a positive integer greater than 0, but ${val} is provided`);
};
const { createEmits, createListeners } = useEmitProxy([
  "input",
  "change",
  "click",
  "update:modelValue"
]);
const VaInputWrapperProps = extractComponentProps(VaInputWrapper);
const _sfc_main = defineComponent({
  name: "VaTextarea",
  components: { VaInputWrapper },
  props: {
    ...useFormFieldProps,
    ...VaInputWrapperProps,
    ...useStatefulProps,
    ...useValidationProps,
    modelValue: { type: [String, Number], default: "" },
    placeholder: { type: String },
    autosize: { type: Boolean, default: false },
    minRows: {
      type: Number,
      default: 1,
      validator: positiveNumberValidator
    },
    maxRows: {
      type: Number,
      validator: positiveNumberValidator
    },
    resize: {
      type: Boolean,
      default: true
    },
    clearValue: {
      type: [String],
      default: ""
    }
  },
  emits: [...createEmits(), ...useValidationEmits],
  setup(props, { emit }) {
    const textarea = shallowRef();
    const { valueComputed } = useStateful(props, emit, "modelValue", {
      defaultValue: ""
    });
    const focus = () => {
      focusElement(textarea.value);
    };
    const blur = () => {
      blurElement(textarea.value);
    };
    const reset = () => withoutValidation(() => {
      emit("update:modelValue", props.clearValue);
      emit("clear");
      resetValidation();
    });
    const {
      computedError,
      computedErrorMessages,
      listeners: validationListeners,
      validationAriaAttributes,
      isLoading,
      resetValidation,
      withoutValidation
    } = useValidation(props, emit, {
      value: valueComputed,
      focus,
      reset
    });
    const isResizable = computed(() => {
      return props.resize && !props.autosize;
    });
    const computedRowsCount = computed(() => {
      if (!props.autosize) {
        return void 0;
      }
      const rows = valueComputed.value ? valueComputed.value.toString().split("\n").length : 1;
      if (!props.maxRows) {
        return rows;
      }
      return Math.max(props.minRows, Math.min(rows, props.maxRows));
    });
    const computedStyle = computed(() => ({
      resize: isResizable.value ? void 0 : "none"
    }));
    const computedProps = computed(() => ({
      ...pick(props, ["disabled", "readonly", "placeholder", "ariaLabel"])
    }));
    return {
      isResizable,
      validationListeners,
      validationAriaAttributes,
      computedError,
      computedErrorMessages,
      isLoading,
      computedRowsCount,
      valueComputed,
      vaInputWrapperProps: filterComponentProps(VaInputWrapperProps),
      textarea,
      computedStyle,
      listeners: createListeners(emit),
      computedProps,
      focus,
      blur
    };
  }
});
export {
  _sfc_main as _
};

import '../../../VaTextarea.css';
//# sourceMappingURL=VaTextarea.vue_vue_type_script_lang.js.map
